<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="ScriptLibrary">
  <record id="name=&quot;SOAP&quot;" recordid="SOAP">
    <name type="string">SOAP</name>
    <script type="string">//--------------------------------------------------------------------------------------------
//
//  libSOAP.js - Javascript routines to support consumption of Web Services 
//
//               Copyright 2004 - 2005  Peregrine Systems, Inc.
//               Copyright 2006 - 2007  Hewlett-Packard
//
//--------------------------------------------------------------------------------------------
function init()
{
  // This exists to provide a way for code in other packages 
  // to ensure that lib.SOAP has been loaded and that functions, etc.
  // defined in here are introduced into the caller's JS namespace
}

function WSDL2js4( url, fTypecheck, userid, password )
{

  var resultObj = {};
  
  resultObj.msgs       = fTypecheck.strings;
  resultObj.memberName = "";
  resultObj.scriptText = "";

  resultObj.rc = WSDL2js( url, resultObj, userid, password );
  
  fTypecheck.string1 = resultObj.scriptText;
  fTypecheck.string  = resultObj.memberName;

  return resultObj.rc;
}

function WSDL2js2( url, fTypecheck )  
{
  var resultObj = {};
  
  resultObj.msgs       = fTypecheck.strings;
  resultObj.memberName = "";
  resultObj.scriptText = "";

  resultObj.rc = WSDL2js( url, resultObj );
  
  fTypecheck.string1 = resultObj.scriptText;
  fTypecheck.string  = resultObj.memberName;

  return resultObj.rc;
}

// Routine to handle messages. 
  
function issueMsg( result, msg )
{      
  if ( result.bCalledFromMenu )
  {
    result.msgs.push( msg );
  }
  else {
    print( msg );
  }
}
//----------------------------------------------------------------------------
//
//  WSDL2js - This function is the the only one that should be called by
//            user-written code. The rest of the material in this package
//            exists to support this function and the Javascript functions 
//            generated by it. Returns true or false to indicate success/failure
//            and updates the "resultObj" argument to return information to caller
//            including the name of the resulting script library member, and messages
//
//--------------------------------------------------------------------

function WSDL2js( wsdlURL, resultObj, userid, password )
{ 
  if ( resultObj == undefined )
  {
    resultObj = {};
  
    resultObj.msgs = [];
    resultObj.memberName = "";
    resultObj.scriptText = "";
    bCalledFromMenu = false; // running stand alone, not called from menu, no prompt re saving WSDL
  }
  else {
    bCalledFromMenu = true;
  }
    
  initWSDL2JS();
  
  var result = {};
  
  // Note that userid and password are usually not passed
  // and so are undefined
  
  result.userid = userid;
  result.password = password;
       
  var strWSDLsrc;
  var bWSDLsrcIsFile = false;
  
  if ( wsdlURL.startsWith( "http" ) )
  {
    var headers = [];

    try
    {
      if ( result.userid != undefined )
      {
        var authHeader = new Header();
           
        authHeader.name = "Authorization";
        authHeader.value = "Basic " + lib.Base64Encoder.encode( result.userid + ":" + result.password );//base64Encode( result.userid + ":" + result.password ); 
      
        headers.push( authHeader );  
      }
            
      strWSDLsrc = doHTTPRequest( "GET", wsdlURL, headers, null, 10, 10, 10 );
    }
    catch( e )
    {     
      resultObj.msgs.push( "WSDL request failed with exception " + e );
      return false;
    }
  }
  else
  if ( wsdlURL.startsWith( "file:" ) )
  {
     strWSDLsrc = wsdlURL.after("file://");
     bWSDLsrcIsFile = true;
  }
  else
  {
    resultObj.msgs.push( "Invalid WSDL endpoint URL - does not start with http:// or file://" );
    return false;
  }
  
  // Parse wsdl

  result.js = "";
  result.soapNSPrefix = "";
  result.msgs = resultObj.msgs;
  
  result.bWSDLsrcIsFile = bWSDLsrcIsFile;
  result.strWSDLsrc     = strWSDLsrc;
  result.bCalledFromMenu = bCalledFromMenu;
  result.wsdlURL = wsdlURL;
  
  if ( ! parseWSDL( strWSDLsrc, bWSDLsrcIsFile, result ) )
  {
    resultObj.msgs.push( "WSDL2JS: parseWSDL failed!" );
    return false;
  }
  else
  {
    resultObj.msgs.push( "WSDL2JS succeeded" );
  }
 
  if ( result.serviceName == undefined )
  {
     throw( "No serviceName defined!!" );
  }
  
  resultObj.memberName = result.serviceName;
  resultObj.scriptText = result.js;
  
  if ( ! bCalledFromMenu ) // just save the generated code; overwrite any existing member
  {
    var scriptLib = new SCFile( "ScriptLibrary" );
  
    var rc = scriptLib.doSelect( "name=\"" + result.serviceName + "\" and package=\"SOAP\"" );
    
    if ( rc == RC_SUCCESS )
    {
      rc = scriptLib.doDelete();
    } 
  
    scriptLib.name = result.serviceName; 
    scriptLib._package = "SOAP"; 
    scriptLib.script = result.js;
  
    rc = scriptLib.doSave();
  
    if ( rc == RC_SUCCESS )
    {
      print( "Member '" + result.serviceName + "' added to ScriptLibrary" );
    }
   
/*   // Write the generated code to a temp file
   
   var strFilePath = "C:\\temp\\" + result.serviceName + ".js";
   
   print( "Writing file " + strFilePath );
   
   var len = writeFile( strFilePath, "t", result.js );
   
   print( "writeFile returned ", len );
*/  

  }
  return true;
}

//----------------------------------------------------------------------------
//
//  parseWSDL - Takes a string of WSDL XML or a path to a WSDL file
//              Parses the WSDL and populates the "result" object
//              with Javascript code generated from the WSDL. 
//
//--------------------------------------------------------------------
function parseWSDL( strWSDLXml, bIsFile, result )
{
  var strWSDLPath;
  var docElem;
  
  var xmlDoc = new XML();
     
  result.xmlDoc = xmlDoc;

  if ( bIsFile )
  {
    strWSDLPath  = strWSDLXml;
       
    strWSDLXml = readFile( strWSDLPath, "t" );
    
    if ( typeof strWSDLXml != "string" )  // readFile returns integer return code on error
    {
      issueMsg( result, "Unable to open WSDL file " + strWSDLPath );
     
      return false;
    }
  }
    
  //print( "Initial WSDL to be parsed is:" + strWSDLXml );
    
  if ( ! xmlDoc.setContent( strWSDLXml, false ) )
  {    
    issueMsg( result, "Error parsing WSDL" );

    return false;
  }
  else // Successfully read and parsed the WSDL
  {     
    strWSDLXml = "";
    
    docElem = xmlDoc.getDocumentElement();
         
    if ( bIsFile )  // we read the WSDL from a local disk file
    {
       // Save the absolute path to the WSDL file in an attribute
       // and add the attribute to the document element
       
      docElem.addAttribute( "absolutePath", strWSDLPath );      
    }
    
    visitNode( docElem, result );
    
    // let's fix the rpc request name problem here
    // the visitNode function is messy enough already
    var name;
	for (name in SOAPOperations) {
		var oper = SOAPOperations[name];
		if (oper instanceof SOAPOperation &amp;&amp; oper.style == 'rpc') {
			pendingObjects[oper.requestMessageName].funcName = name;
			pendingObjects[oper.requestMessageName].xmlName = name;
			oper.requestMessageName = name;
		}
	}
  }

// Emit the service function first so it is easier for the user to look at...
// It is helpful to look at this when trying to understand the methods, etc.

 emitServiceFunction( result );

 emitInvokeFunction( result );
 emitSOAPOperationFunction( result );
 
 emitSOAPBodyObject( result );
 emitSOAPEnvelopeObject( result );
 emitSOAPFaultObject( result );
 emitSOAPHeaderObject( result );
 emitPendingFunctionObjects( 0, result );
 
 emitStandardMethods( result );
 emitSOAPLibInit( result );

 return true;
}

//--------------------------------------------------------------------------------
//
//  Supporting routines used by the WSDL2JS routines and by the generated objects
//              with material generated from the WSDL. 
//
//--------------------------------------------------------------------------------
var undefined;  // leave this unset so we can compare to undefined  

// Add a "startsWith" method to Javascript string object

String.prototype.startsWith = function( str )
{
  var strIntern = this.valueOf();
  
  if ( strIntern.substr(0,str.length) == str ) {
    return true;
  }
}

// Add an "endsWith" method to Javascript string object

String.prototype.endsWith = function( str )
{
  var strIntern = this.valueOf();
  
  if ( strIntern.substr(strIntern.length-str.length) == str )
    return true;
}

// Add a "before" method to Javascript string object

String.prototype.before = function( str )
{
  var strIntern = this.valueOf();
  
  var strLen = str.length;
  
  var i = strIntern.indexOf( str );
  
  if ( i &gt;= 0 )
  {
    return strIntern.substring(0,i);
  }
  return "";
}

// Add an "after" method to Javascript string object

String.prototype.after = function( str )
{
  var strIntern = this.valueOf();
  
  var strLen = str.length;
  
  var i = strIntern.indexOf( str );
  
  if ( i &gt;= 0 )
  {
    return strIntern.substr(i+strLen);
  }
  return "";
}

// Recursive routine to serialize a Javascript object hierarchy as XML
// N.B. the object hierarchy must conform to our Javascript object model;
// It won't work with an arbitrary Javascript object hierarchy

function serialize( obj, result, bEmitTypeAttrs )
{ 
  // First time logic to initialize the output XML buffer and nesting level counter

  if ( result.xml == undefined )
  {
    result.depth = 0;
    result.depthList = [];
    result.indent = 0;

    result.xml = "&lt;" + obj.getXmlName(); 
  }

function outputIndent( result )
{
  return;
  /* Disable pretty-printing of XML
  
  result.xml += "\n";

  for (var k=1; k&lt;result.indent; k++) 
  {
    result.xml += " ";
  }
  */
}

function outputAttributeValue( strValueIn )
{
  var strValueOut = "";
  
  var len = strValueIn.length;
  var i;
  
  for ( i = 0; i &lt; len; i++ ) 
  {
    var c  = strValueIn.charAt(i);
	var cc = strValueIn.charCodeAt(i);

	if ( cc &gt; 62 ) // '&gt;'
	{
	  strValueOut += c;
	}
	else 
	{
      if ( c == '"' ) {
		strValueOut += "&amp;quot;";
      }  
	  else if ( c == '&lt;' ) {
		strValueOut += "&amp;lt;";
      }
      else if ( c == '&amp;' ) {
		strValueOut += "&amp;amp;";
	  }  
	  else if ( c == '&gt;' ) {
        strValueOut += "&amp;gt;";
      } 
      else {
		strValueOut += c;
      }		 
	}	
  }
  return strValueOut;
}

function outputAttributes( node, result )
{  
  var bEmittedAnything = false;

  var ii;  
  for ( ii = 0; ii &lt; node.$$attributes.length; ii++ )
  {   
   var attrVal  = String( node[node.$$attributes[ii]] );
   
   if ( attrVal.length &gt; 0 )
   {
     var attrName = transformXmlName(node, node.$$attributes[ii], null);
     
     if ( ! bEmitTypeAttrs &amp;&amp; attrName == "xsi:type" )
     {
       // Suppression of xsi:type attributes was requested, so skip this attribute
     }
     else
     {
       result.xml += " ";   
       result.xml += attrName;
       result.xml += "=\"";
       result.xml += outputAttributeValue( attrVal );
       result.xml += "\"";
     
       if ( attrName != "xsi:type" )
       {
         bEmittedAnything = true;
       }
     }
   }
  }
  return bEmittedAnything;
}

  // Lookup object name and see if we have to substitute
  // a different value, e.g. contact_name becomes contact.name
  
  function transformXmlName( obj, property, parent )
  {     
    var nspref;
    var newName;
     
    if ( parent == null )  // this is an attribute
    {
      // if the attribute has an XmlName, it is already prefixed
      
      newName = obj.$$xmlNames[ property ];
      
      if ( newName != undefined )
      {
        return newName;
      }
      
      return property;
    }
  
    if ( isArrayObject(parent) )
    {        
      return property;
    }
    
    if ( property == "soap_Body" )  // this was a bug in prior versions
    {
       throw( "Please rerun WSDL2JS for this web service!" );
    }
    
    // See if there is an xmlName for this element. For example, the schema might define
    // the element as "sort" but the function object uses _sort because sort is a JS reserved word.
    
    // "keys" is a native function of Array in new JS engine, need to handle specially 
    if (property != "keys") {
        newName = parent.$$xmlNames[ property ];
    }
    
    if ( newName == undefined )
    {
      newName = property;
    }
      
    // Get namespace prefix

    if ( parent.$$elementFormDefault == "qualified" )
    {
      if ( parent.$$refs[ property ] &amp;&amp; property != "keys")
      {
        nspref = obj["$$nsPrefix"];   // ref objects are not in the parent objects namespace
      }
      else
      {     
        nspref = parent["$$nsPrefix"];
    
        if ( nspref == undefined )
        {     
          nspref = obj["$$nsPrefix"];   
        }
      }    
    } 
    // if the script author hammers an object via assignment, we may lose our namespace prefix info
    // if so, don't return &lt;undefined:Foo&gt;, return &lt;Foo&gt;
    
    if ( nspref == undefined )
    {
      return newName;
    }
    else {     
      return nspref + ":" + newName;
    }
  }


function nodeHasAttributes( node )
{
  return ( node.$$attributes != undefined &amp;&amp; node.$$attributes.length &gt; 0 );
}

function nodeHasChildren( node )
{
  return ( node.$$elementChildren != undefined &amp;&amp; node.$$elementChildren.length &gt; 0 );
}

function nodeIsText( node )
{
  if ( (node instanceof Object) == false ) {
    return true;
  }

  return ( node.$$value != undefined &amp;&amp; node.$$value != null );
}

// node is suppressible if has minOccurs zero and no value

function nodeIsSuppressible( node, tag, parent )
{  
  if ( parent != null &amp;&amp; parent != undefined &amp;&amp; parent.$$minOccurs != undefined)
  {
    var minOccursTab = parent.$$minOccurs;
     
    var minOccursVal = minOccursTab[ tag ];
        
    if ( minOccursVal != undefined &amp;&amp; minOccursVal == 0 &amp;&amp;  node.$$value == undefined )
    {   
       return true;
    }
  }
  return false;
}

function doChild( node, tag, parent, result )
{     
  var bEmittedAnyValue = false;
  
  if ( node == undefined ) {
    return false;
  }
 
  // Suppress minOccurs=0 child elements which have no content
  if ( ! nodeHasChildren(node) &amp;&amp; nodeIsSuppressible( node, tag, parent ) )
  {
     return false; // skip this element
  } 
  
  result.bClosingTagEmitted = false;
  result.bTrimEmptyTag = false;
  
  // We are going to emit some XML, so save the previous length so we can retract it if needed
  
  var xmlPrevLen = result.xml.length;
  
    
  result.depthList[result.depth]=tag;
  result.depth += 1;
  
  if ( ! isArrayObject(node) )
  {
    // newline, indent, and "&lt;" before each element
 
    outputIndent( result );

    result.xml += "&lt;";
    result.xml += transformXmlName(node,tag,parent);
  }
  else
  {
    node.isArray = true;
    node.tag = transformXmlName(node,tag,parent);
  }
        
  bEmittedAnyValue = obj_walk( node, result );
  
  result.depth -= 1;
  
  tag = result.depthList[result.depth];
  
  if ( ! result.bClosingTagEmitted )
  {
    // if we just emitted a text node value, don't newline and indent

    if ( ! nodeIsText(node) )  
    {
      if ( ! isArrayObject(node) ) {
        outputIndent( result );
      }
    }

    if ( ! isArrayObject(node) )
    {
      result.xml += ("&lt;/" + transformXmlName(node,tag,parent) + "&gt;"); 
    }
  }
  
  if ( ! bEmittedAnyValue &amp;&amp; result.bTrimEmptyTag  )
  {    
    if ( nodeIsSuppressible( node, tag, parent ) )
    {         
      result.xml = result.xml.substr( 0, xmlPrevLen );
    }
  }
  
  return bEmittedAnyValue;
}

function outputElementTextValue( strValueIn )
{  
  var strValueOut = "";
  
  var len = strValueIn.length;
    
  var i;
  
  for ( i = 0; i &lt; len; i++ ) 
  {
    var c  = strValueIn.charAt(i);
	var cc = strValueIn.charCodeAt(i);

	if ( cc &gt; 62 ) // '&gt;'
	{
	  strValueOut += c;
	}
	else 
	{
	  if ( c == '&lt;' ) {
		strValueOut += "&amp;lt;";
      }
      else if ( c == '&amp;' ) {
		strValueOut += "&amp;amp;";
	  }
	  else if ( c == '&gt;' ) {
        strValueOut += "&amp;gt;";
      }
      else {
		strValueOut += c;
      }
	}	
  }
  return strValueOut;
}

function obj_walk( node, result ) 
{  
  var tag;
  var i;
  var bAnyValueEmitted = false;
  var bAnyValueThisChild = false;
       
  var hasText       = nodeIsText( node );
  var hasChildren   = nodeHasChildren( node );
  var hasAttributes = nodeHasAttributes( node );

  result.indent += 2;

  // Note: we have already output the current node's tag when we get here

  if ( hasAttributes )
  {
    bAnyValueEmitted = outputAttributes( node, result );
  }

  if ( ! hasText &amp;&amp; ! hasChildren &amp;&amp; ! node.isArray )
  {  
    result.xml += " /&gt;";
    
    result.bClosingTagEmitted = true;
  }
  else
  {  // either has text (leaf) or has children (child elements) or is a native array object
     // if not nativeArray, emit &gt; for starting tag, emit, then after emitting, output an ending tag

    if ( ! node.isArray ) {
      result.xml += "&gt;";
    }

    if ( hasText )
    {
      if ( node.$$value === undefined )
      {
        result.xml += outputElementTextValue( String(node) );
      }
      else
      {
        result.xml += outputElementTextValue( String(node.$$value) );
      }
     
      bAnyValueEmitted = true;
    }    
    else if ( node.isArray )
    {       
       prevLen = result.xml.length;
       
       // Output array elements
       
       for ( i = 0; i &lt; node.length; i++ )
       {
         if ( bAnyValueThisChild = doChild( node[i], node.tag, node, result ) )
         {
            bAnyValueEmitted = true;
         }          
       }
    }
    else  // have children
    {                  
      for ( i = 0; i &lt; node.$$elementChildren.length; i++ )
      {        
        tag = node.$$elementChildren[i];  
                       
        if ( bAnyValueThisChild = doChild( node[tag], tag, node, result ) )
        {
           bAnyValueEmitted = true;
        }    
      } // for children
     
      if ( ! bAnyValueEmitted )
      {  
         result.bTrimEmptyTag = true;
      } 
      result.bClosingTagEmitted = false;
       
    } // else have children
    
   } // else has either text or children

  result.indent -= 2;

  // Special case code for final tag 

  if ( result.depth == 0 )
  {    
    outputIndent( result );
    
    result.xml += "&lt;/" + node.getXmlName() + "&gt;";
  }  
  
  return bAnyValueEmitted;

} // obj_walk

 obj_walk( obj, result );

} // serialize

//--- Function to get object name out of constructor

function objectName( obj )
{
  if ( obj == null ) {
    return null;
  }

  return obj.constructor.name;
 }

 // Returns true if 'obj' has Array constructor

 function isArrayObject( obj )
 {
   if ( obj == null ) {
     return false;
   }

   return ( obj.constructor == Array );
 }

//---- Generate object by name

function generateObject( name )
{
  try
  {
    return eval( "new " + name + "( true )" );
  }
  catch( e )
  {
      throw( "Error trying to generate object " + name + ": " + e.toString() );
  }
}

var jsWords = null;

function isJSreservedWord( varName )
{
  if ( jsWords == null || jsWords == undefined )
  {
    jsWords = {};

  
    jsKeyWords = ["break", "case", "catch",     "continue", "default", "delete", 
                  "do",    "else", "false",     "finally",  "for",     "function",
                  "if",    "in",   "instanceof","new",      "null",    "return",
                  "shift", "switch","this", "throw",     "true",     "try",     "typeof",
                  "var",   "void", "while",     "with",

        "abstract",
        "boolean",
        "byte",
        "char",
        "class",
        "const",
        "debugger",
        "double",
        "enum",
        "export",
        "extends",
        "filter",
        "final",
        "float",
        "goto",
        "implements",
        "import",
        "int",
        "interface",
        "long",
        "native",
        "package",
        "private",
        "protected",
        "public",
        "short",
        "sort",
        "static",
        "super",
        "synchronized",
        "throws",
        "transient",
        "volatile"
    ]; 

    var i;
    for ( i=0; i&lt;jsKeyWords.length; i++ )
    {
      jsWords[ jsKeyWords[i] ] = true;
    }
  }
  
  if ( jsWords[ varName] != undefined ) {
    return true;
  }
  
  return false;
}

function isValidJsIdentifier( token )
{
  if ( isJSreservedWord(token) )
  {
    return false;
  }
  
  if (/^[a-z$_][\w$]*$/i.test(token))
  {
    return true;
  }

  return false;  
}

function stripPrefix( elemName )
{
  var ii = elemName.indexOf( ":" );

  if ( ii != -1 )
  {
     return elemName.substr(ii+1);
  }
  return elemName;
}

function transformName( varName )
{  
  // Have to transform names here. Mainly, get rid of . characters used by SC
  // Also get rid of names like "shift" in the location file, which is a JS reserved word
  // Also get rid of hyphens, which are legal in XML names but obviously clash with JS subtraction operator
  // Finally, get rid of embedded blanks, which although not present in XML, can be present
  // in WSDL names such as service names

  var re;
  
  if ( isJSreservedWord( varName ) )    // Javascript reserved words
  {
    varName = "_" + varName;
  }
  else
  {
    if ( varName.indexOf( "." ) != -1 )  // dots
    {
      re = /\./g ;

      varName = varName.replace( re, "_" );
    }

    if ( varName.indexOf( ":" ) != -1 )  // colons
    {
      re = /\:/g ;

      varName = varName.replace( re, "_" );
    }

    if ( varName.indexOf( "-" ) != -1 )  // hyphens
    {
      re = /\-/g ;

      varName = varName.replace( re, "_" );
    }

    if ( varName.indexOf( " " ) != -1 )  // embedded blanks
    {
      re = /\ /g ;

      varName = varName.replace( re, "_" );
    }
    
    if ( varName.indexOf( "/" ) != -1 )  // slashes
    {
      re = /\//g ;

      varName = varName.replace( re, "_" );
    }    
  }
  return varName;
}

// Determine if this is a SOAP Header element.

function isSOAPHeader( elem )
{
  return ( elem.getNodeName() == "Header" &amp;&amp; ( elem.isDocumentElement() || elem.getParentNode().getNodeName() == "Envelope" ) );
}

// Recursively add incoming SOAP Header XML elements to the soap_Header object as XML objects

function deserializeHeader( headerElem, headerObj )
{ 
 var child = headerElem.getFirstChildElement();
 
 while( child != null )
 {   
   var nodeName  = transformName( child.getNodeName() );
   
   headerObj[ nodeName ] = child;
   
   child = child.getNextSiblingElement();
 }
}

// Recursive routine to deserialize a SOAP response into Javascript objects

function deserialize( serviceName, elem, obj )
{
 
 hrefObj = []; // global variable
 var node;
 
 var newObj;
 
 var isFault = false;
 
 var responseObj = null;
    
 if ( elem.isDocumentElement() )
 {   
   // We can't rely on rpc-encoded services to respond with a predictable SOAP Body Element
   // so if this is an rpc-style SOAP operation, invoke passes the expected object name via "obj" when it calls deserialize
   
   responseObj = obj.responseObj;
   
   // Always allocate a SOAP envelope when we are just beginning to walk the XML document
   newObj = obj.soap_Envelope = generateObject( "lib." + serviceName + ".soap_Envelope" );
   
   obj = newObj; // soap_Envelope is now the current object
            
   // If the XML came from gSOAP, we may start with either a soap:Header or a soap:Body (not a soap:Envelope)
   // But if we were entered with XML from a test script, we may have a soap_Envelope
  
   if ( elem.getNodeName() == "Envelope" )
   {     
     elem = elem.getFirstChildElement();
   } 
   
   // If the current element is a SOAP Header element, make a soap_Header object
   // and give it an XML object containing whatever is contained in the soap header element
   
   if ( isSOAPHeader( elem ) )
   {     
     newObj = generateObject( "lib." + serviceName + ".soap_Header" );

     deserializeHeader( elem, newObj );
     
     obj.setContent( newObj );  // add soap_Header object to soap_Envelope object
     
     elem = elem.getNextSiblingElement();  // elem should now be soap body
   }
   
   // The current element should now be soap:Body, create a soap_Body object
   // and do a setContent on the soap_Envelope with it
    
   newObj = generateObject( "lib." + serviceName + ".soap_Body" );
  
   obj.addContent( newObj );  // add the soap_Body object to the soap_Envelope object
          
   obj = newObj;
        
   // The current object is now soap_Body, so make the current element
   // the one contained in the soap Body 
   
   elem = elem.getFirstChildElement();
   
   var elemName = elem.getNodeName();
           
   // See if this is a SOAP fault
   
   if ( elemName == "Fault" )
   {
      newObj = generateObject( "lib." + serviceName + ".soap_Fault" );
      isFault = true;
   }
   else
   {     
     if ( responseObj != null )
     {  
        newObj = generateObject( "lib." + serviceName + "." + responseObj );
     }
     else 
     // This is a document style service. So we trust that the soap Body element name
     // matches a function object we generated from the WSDL
     {
       var elemNameTrans = transformName( elemName );

       newObj = generateObject( "lib." + serviceName + "." + elemNameTrans );
     }
   }
         
   obj.setContent( newObj );
   
   obj = newObj;  // current object is now the element contained in the soap body
 }
 
 doElement( serviceName, elem, obj, isFault );  
 
 // We might have a second SOAP Body child if this is an rpc style service using href
 
 elem = elem.getNextSiblingElement();
  
 
 while ( elem != null )
 {
    // Look for an id attribute
    
    var idAttr = elem.getAttributeNode( "id" );
    
    
    
    var id = null;
    
    if ( idAttr != null )
    {
       id = "#"+idAttr.getNodeValue();
    }
    
    if ( id != null )
    {    
      // Find the object with corresponding href value
           
      var childObj =  hrefObj[id];
      if ( childObj != null &amp;&amp; childObj[ "href" ] != null )
      {        
        var href = childObj.href;
        
        if ( href ==  id )
        {
            doElement( serviceName, elem, childObj, false );
        }
      }
    }
    elem = elem.getNextSiblingElement();
 }

}

// Deserialize an element and its children

function doElement( serviceName, elem, obj, isFault)
{
 var newObj = null;
   
 var ii = 0;
 
 // Do attributes
 
 var node = elem.getFirstAttribute();
 
 while( node != null )
 {   
   var attrName  = node.getQualifiedName();
   var attrValue = node.getNodeValue();
   var mangledName = transformName(attrName);
           
   if ( ! attrName.startsWith("SOAP-ENV:") // our objects already have these objects with "soap:" prefix
     &amp;&amp; ! attrName.startsWith("xmlns") )   // our objects already have all the right namespace definitions
   {   
      obj[ mangledName ] = attrValue;   
   }

   if ( attrName.startsWith("href") )
   {
      var href = attrValue;
      hrefObj[href] = obj;
 
   }   
   node = elem.getNextAttribute();
 }
 
 // Do any possible element value
 
 var nodeValue = elem.getNodeValue();
 
 // If this is the detail node of a SOAP Fault, it is an XML object
 
 if ( isFault &amp;&amp; elem.getNodeName() == "detail" )
 {
   obj.setContent( elem.toXMLString() );
   return;
 }
 
 if ( typeof nodeValue == "string" &amp;&amp; nodeValue.length &gt; 0 &amp;&amp; obj.setValue != undefined )
 {                 
   obj.setValue( nodeValue );
 }        
 
 // Do child elements
 
 var child = elem.getFirstChildElement();
 
 while( child != null )
 {   
   var nodeName  = child.getNodeName();
   var nodeValue = child.getNodeValue();
         
   var mangledName = transformName(nodeName);
     
   if (!obj[ mangledName ] &amp;&amp; isArrayObject(obj.item)) {
   		newObj = obj.item.newInstance(true);
   		obj[mangledName] = obj.item;
   		obj[mangledName + "_newInstance"] = obj.item_newInstance;
   } else if ( isArrayObject( obj[ mangledName ] ) )
   {         
     newObj = obj[ mangledName + "_newInstance" ]( true );
   }       
   else
   {             
     newObj = obj[ mangledName ];  
       
     if ( newObj == null )
     {            
       if ( obj[ "getChildFunc" ] != null )
       {
          // Just-in-time child object generation
          
          var childFunc = obj.getChildFunc( mangledName );
                              
          obj[ mangledName ] = newObj = new childFunc( true );
          
          
          if ( newObj[ "$$value" ] != undefined )
          {
             newObj.$$value = undefined;
          }
       }
       else
       {                  
         if ( obj[ "_return" ] != undefined )
         {
           issueMsg( result,  "Warning: unrecognized XML element in response: " + nodeName );
           issueMsg( result,  "Warning: contents of " + nodeName + " stored in _return instead" );
         
           newObj = obj[ "_return" ];
         }
         else {
           throw( "Error! Unrecognized XML element in SOAP response: " + nodeName );
         }
       }
         
     }
   }
                
   doElement( serviceName, child, newObj, isFault );
   
   child = child.getNextSiblingElement();
 }  
 
} // doElement

//////////////////////////////////////////////////////////////////////////////////////////
//
//  WSDL2JS - Generate Javascript objects from WSDL
//
//            Copyright 2004 Peregrine Systems, Inc.
//
/////////////////////////////////////////////////////////////////////////////////////////
var SOAPOperations;
var WSDLMessages;
var funcObjStack;
var globalNamespaceCounter;
var globalNamespaceURIs;
var localNamespaceURIs;
var globalNamespacePrefixes;
var schemas_processed;
var simpleTypeLiteral;
var pendingObjects;

var schemaNSPrefix;

var jsTypes;

var os_info =  system.functions.version().toArray();

function initWSDL2JS()
{
 SOAPOperations = [];
 WSDLMessages = [];
 funcObjStack = [];
 pendingObjects = {};
 
 globalNamespaceCounter = 0;
 localNamespaceURIs = [];
 globalNamespaceURIs = [];
 globalNamespacePrefixes = [];
 
 schemas_processed = [];
 simpleTypeLiteral = [];
 
 schemas_processed[ "http://www.w3.org/2005/05/xmlmime" ] = true; // This is not resolveable except by proxy

 simpleTypeLiteral["string"] = "\"\";";
 simpleTypeLiteral["float"]  = "0;";
 simpleTypeLiteral["boolean"] = "false;";
 simpleTypeLiteral["double"] = "0;";
 simpleTypeLiteral["integer"] = "0;";
 simpleTypeLiteral["int"] = "0;";
 
 jsTypes = [];

 jsTypes[ "string"  ] = "String";

 jsTypes[ "boolean" ] = "Boolean";
 
 jsTypes[ "int"     ] = "Number";
 jsTypes[ "unsignedInt" ] = "Number";
 
 jsTypes[ "integer" ] = "Number";
 jsTypes[ "long"    ] = "Number";
 jsTypes[ "unsignedLong" ] = "Number";
 
 jsTypes[ "short"   ] = "Number";
 jsTypes[ "unsignedShort" ] = "Number";
 
 jsTypes[ "byte"    ] = "Number";
 jsTypes[ "unsignedByte" ] = "Number";
 
 
 jsTypes[ "negativeInteger"    ] = "Number";
 jsTypes[ "nonNegativeInteger" ] = "Number";
 jsTypes[ "positiveInteger"    ] = "Number";
 jsTypes[ "nonPositiveInteger" ] = "Number";
 
 jsTypes[ "float"   ] = "Number";
 jsTypes[ "double"  ] = "Number";
 jsTypes[ "decimal" ] = "Number";
 
 jsTypes[ "date"    ] = "Date";
 jsTypes[ "time"    ] = "Date";
 jsTypes[ "dateTime"] = "Date"; 
 jsTypes[ "duration"] = "Date";
 
}

function nodeHasAttribute( xmlNode, attrName, attrValue )
{
  var attr = xmlNode.getAttributeNode( attrName );

  if ( attr != null &amp;&amp; attr.getNodeValue() == attrValue )
  {
    return true;
  }
  return false;
}

function isSimpleType( type )
{
  return simpleTypeLiteral[type] != undefined;
}

function isArrayType( baseVal )
{
  return baseVal.match( /.*Array.*/ ) != null;
}

function functionObject( result, funcName, xmlName, xmlLevel )
{  
  this.namespace = result.targetNSURI;
  this.nsPrefix  = globalNamespacePrefixes[ this.namespace ];
  this.elementFormDefault = result.elementFormDefault;
  
  if ( this.nsPrefix == undefined )
  {
    issueMsg( result, "Error! namespace prefix not found for namespace " + this.namespace );
  }
  
  this.schemaNSPrefix = result.schemaNSPrefix;
  this.schemaNSisDefault = result.schemaNSisDefault;
  this.funcName = funcName;
  this.xmlName = xmlName;
  this.xmlLevel = xmlLevel;
  this.emitted = false;

  this.hasSimpleContent = false;
  this.hasComplexContent = false;
  
  this.isExtendedType = false;
  this.isRestrictedType = false;
  this.isXMLSchemaType = false;
  
  this.extensionBase = null;
  this.restrictionBase = null;
  
  this.members = [];
  this.attributes = [];
  this.enumerations = [];
}

function SOAPOperation( name )
{
  this.name = name;
  this.SOAPAction = null;
  this.style = null;
  this.requestMessageName = null;
  this.responseMessageName = null;
}

function WSDLMessage( name )
{
  this.name = name;
  this.elemName = null;
  this.parts = [];
}

// Using the Array of SOAP Operation info which we collected
// from the WSDL portType and binding elements,
// emit entries for the SOAPOperations array into the function for the service name

function emitSOAPOperationEntries( result )
{
  var obj;
  for ( obj in SOAPOperations )
  {
    var soapOp = SOAPOperations[ obj ];

    if( soapOp &amp;&amp; soapOp instanceof SOAPOperation ) {
	    
	    result.js += "\n  this.SOAPOperations[ \"" + soapOp.name + "\" ] = new soap_Operation( ";
	
	    result.js += "\"" + soapOp.name                + "\", ";
	    result.js += "\"" + soapOp.SOAPAction          + "\", ";
	    result.js += "\"" + soapOp.style               + "\", ";
	    result.js += "\"" + soapOp.requestMessageName  + "\", ";
	    result.js += "\"" + soapOp.responseMessageName + "\" );";
    }
  }
}

// Emit functions for manipulating the service location (host, port, proto)

function emitLocationFunctions( result )
{
  var locationFunctions = "\n\
  this.getProto = function( )\n\
  {\n\
    return this.location.before(\"://\");\n\
  }\n\
   \n\
  this.getHost = function( )\n\
  {\n\
    var hostport = this.location.after(\"://\");\n\
    var h;\n\
    return ( (h = hostport.before(\":\")) ? h : hostport );\n\
  }\n\
   \n\
  this.getPort = function( )\n\
  {\n\
    var hostport = this.location.after(\"//\");\n\
    var p;\n\
    return ( (p = hostport.after(\":\")) ? p : 80 );\n\
  }\n\
   \n\
  this.setHost = function( host )\n\
  {\n\
    var port  = this.getPort();\n\
    var proto = this.getProto();\n\
   \n\
    this.location = proto + \"://\" + host + \":\" + port;\n\
  }\n\
   \n\
  this.setPort = function( port )\n\
  {\n\
    var host  = this.getHost();\n\
    var proto = this.getProto();\n\
   \n\
    this.location = proto + \"://\" + host + \":\" + port;\n\
  }\n";
 
  result.js += locationFunctions;
}

function emitAttachmentFunctions( result )
{
  var attachmentFunctions = "\n\
   this.setAttachments = function( attachments )\n\
  {\n\
    this.attachments = attachments;\n\
  }\n\
  \n\
  this.getAttachments = function()\n\
  {\n\
    return this.attachments;\n\
  }\n";
  
  result.js += attachmentFunctions;
}

// Emit the function for the service name, ie a function whose name is the service, 
// such as "function GoogleSearchService()" or function CASMSOAPServer()"

function emitServiceFunction( result )
{
  result.js += "\nfunction " + result.serviceName + "( )\n{\n" ;

  result.js += "  this.location = new String( \"" + result.locationURI + "\" );\n\n";

  result.js += "  this.user = null;\n";
  result.js += "  this.password = null;\n";
  
  result.js += "  this.connectTimeOut = 10;\n";
  result.js += "  this.sendTimeOut = 10;\n";
  result.js += "  this.recvTimeOut = 10;\n";
  
  result.js += "  this.soapEnvelope = null;\n";
  result.js += "  this.soapBody = null;\n";
  result.js += "  this.soapHeader = null;\n";
  
  result.js += "  this.acceptfastinfoset = true;\n";
  
  result.js += "  this.attachments = [];\n";
  
  result.js += "  this.resultXML = null;\n";
  
  result.js += "  this.invoke = invoke;\n";
  result.js += "  this.SOAPOperations = [];\n";
  result.js += "  this.getSOAPOperation = function( reqName )\n\
  {\n\
     var soapOp = this.SOAPOperations[ reqName ];\n\
  \n\
     if ( soapOp != null )\n\
     {\n\
       return soapOp;\n\
     }\n\
  \n\
    for ( var op in this.SOAPOperations )\n\
    {\n\
       soapOp = this.SOAPOperations[op];\n\
  \n\
       if ( soapOp.requestObj === reqName )\n\
         return soapOp;\n\
    }\n\
    throw( \"Can't find SOAP Operation for \" + reqName );\n\
  }\n\n";
  
  result.js += "  this.setAcceptfastinfoset = function( acceptfastinfoset )\n\
  {\n\
    this.acceptfastinfoset = acceptfastinfoset;\n\
  }\n\
  \n\
  this.getAcceptfastinfoset = function()\n\
  {\n\
    return this.acceptfastinfoset;\n\
  }\n";
  

  emitSOAPOperationEntries( result );
  
  emitLocationFunctions( result );
  
  emitAttachmentFunctions( result );

  closeFunction( result );
}

// Emit the "soap_Operation" function object used by each SOAPOperation array entry

function emitSOAPOperationFunction( result )
{
  result.js += "\nfunction soap_Operation( name, SOAPAction, style, requestObj, responseObj )\n{\n" ;

  result.js += "  this.name       = name;\n";
  result.js += "  this.SOAPAction = SOAPAction;\n";
  result.js += "  this.style      = style;\n";
  result.js += "  this.requestObj = requestObj;\n";
  result.js += "  this.responseObj= responseObj;";

  closeFunction( result );
}

// Emit the invoke function. This is all static text, so we just define it as a string
/*
  if ( soapOp.style == \"rpc\" )\n\
  {\n\
    resultObj.responseObj = soapOp.responseObj;\n\
  }\n\
  else\n\
  {\n\
    resultObj.responseObj = null;\n\
  }\n\
*/
function emitInvokeFunction( result )
{
var invokeFunction = "\n\
function invoke( requestObj, headerObj, bEmitXsiTypeAttributes )\n\
{\n\
  var bEmitTypeAttrs = true;\n\
\n\
  if ( bEmitXsiTypeAttributes != undefined &amp;&amp; bEmitXsiTypeAttributes != null )\n\
  {\n\
    bEmitTypeAttrs = bEmitXsiTypeAttributes;\n\
  }\n\
\n\
  var soapOp = this.getSOAPOperation( requestObj.getName() );\n\
 \n\
  this.soapEnvelope = new soap_Envelope();\n\
  this.soapBody = new soap_Body();\n\
 \n\
  this.soapBody.setContent( requestObj );\n\
 \n\
  if ( headerObj != undefined &amp;&amp; headerObj != null )\n\
  {\n\
    this.soapHeader = new soap_Header();\n\
    this.soapHeader.setContent( headerObj );\n\
    this.soapEnvelope.setContent( this.soapHeader, this.soapBody );\n\
  }\n\
  else\n\
    this.soapEnvelope.setContent( this.soapBody );\n\
 \n\
  var result = {};\n\
 \n\
  lib.SOAP.serialize( this.soapEnvelope, result, bEmitTypeAttrs );\n\
 \n\
  this.resultXML = doSOAPRequest( this.location, soapOp.SOAPAction, result.xml,\n\
                              this.user, this.password,\n\
                              this.connectTimeOut, this.sendTimeOut, this.recvTimeOut,\n\
                              this.attachments, this.acceptfastinfoset );\n\
\n\
  if ( soapOp.responseObj == \"null\" )  // one-way MEP ? \n\
  {\n\
    return null;\n\
  }\n\
 \n\
  var resultObj = {};\n\
 \n\
  resultObj.responseObj = soapOp.responseObj;\n\
 \n\
  try\n\
  {\n\
    lib.SOAP.deserialize( \"" + result.serviceName + "\", this.resultXML.getDocumentElement(), resultObj );\n\
  }\n\
  catch( e )\n\
  {\n\
    print( \"Error deserializing response: \" + e.toString() );\n\
    return null;\n\
  }\n\
   \n\
  try\n\
  {\n\
    this.soapEnvelope = resultObj[\"soap_Envelope\"];\n\
    this.soapBody = this.soapEnvelope[ \"Body\" ];\n\
   \n\
    if ( this.soapEnvelope[ \"Header\" ] != undefined )\n\
    {\n\
      this.soapHeader = this.soapEnvelope[ \"Header\" ];\n\
    }\n\
    else\n\
      this.soapHeader = null;\n\
    \n\
    return this.soapBody.getContent();\n\
  }\n\
  catch( e )\n\
  {\n\
    print( \"Error extracting response object: \" + e.toString() );\n\
    return null;\n\
  }\n\
}\n";

  result.js += invokeFunction;
}

// Function to check whether a pending function object already has
// a member with a particular name, type, and maxOccurs value

function funcObjHasMember( funcObj, memberName, typeName, maxOccursValue )
{
  var i, length = funcObj.members ? funcObj.members.length : 0;
  for( i = 0; i &lt; length; i++ )
  {
    var xmlNode = funcObj.members[i];
       
    var varName          = xmlNode.getAttributeValue( "name" );
    var varType          = xmlNode.getAttributeValue( "type" );
    var varMaxOccursAttr = xmlNode.getAttributeNode( "maxOccurs" );
    var varMaxOccurs     = null;
         
    if ( varMaxOccursAttr != null )
    {
      varMaxOccurs = varMaxOccursAttr.getNodeValue();
    }
    
    if ( memberName == varName &amp;&amp; typeName == varType &amp;&amp; maxOccursValue == varMaxOccurs ) {
      return true;
    }
  }       
  return false;
}

// Copy all the members from one function object to another

function copyMembers( targetFuncObj, sourceFuncObj )
{
  var i, length = sourceFuncObj.members ? sourceFuncObj.members.length : 0;
  for( i = 0; i &lt; length; i++ )
  {
    var xmlNode = sourceFuncObj.members[i];
    
    targetFuncObj.members.push( xmlNode );
  }
}

function copyAttributes( targetFuncObj, sourceFuncObj )
{
  var i, length = sourceFuncObj.attributes ? sourceFuncObj.attributes.length : 0;
  for( i = 0; i &lt; length; i++ )
  {         
    var xmlNode = sourceFuncObj.attributes[ i ];

    targetFuncObj.attributes.push( xmlNode );
  }
}
 
function getType( funcObj )
{
  var i, length = funcObj.attributes ? funcObj.attributes.length : 0;
  for( i = 0; i &lt; length; i++ )
  {         
     var xmlNode = funcObj.attributes[ i ];
     
     if ( xmlNode.getAttributeValue( "name" ) == "xsi:type" )
     {
       return xmlNode.getAttributeValue( "fixed" );
     }
  }
  return null;
}
 
function isKnownType( typeName )
{  
  var o = pendingObjects[ typeName ];
  
  return ( o != null );
}
 
function isKnownComplexType( typeName )
{  
  var o = pendingObjects[ typeName ];
  
  return ( o != null &amp;&amp; o.hasComplexContent );
}
 
// Emit attributes into the current function  

function emitAttributes( pendingObj, result )
{
  var i, length = pendingObj.attributes ? pendingObj.attributes.length : 0;
  for( i = 0; i &lt; length; i++ )
  {         
     var xmlNode = pendingObj.attributes[ i ];

     emitAttribute( pendingObj, xmlNode, result );
  }
}
      
// Emit member variables into the current function

function emitMembers( pendingObj, nsOverride, result )
{    
  var i, length = pendingObj.members ? pendingObj.members.length : 0;
  for( i = 0; i &lt; length; i++ )
   {
     var xmlNode = pendingObj.members[ i ];
       
     var varName          = xmlNode.getAttributeValue( "name" );             
     var varType          = xmlNode.getAttributeValue( "type" );
          
     var varMinOccursAttr = xmlNode.getAttributeNode( "minOccurs" );
     var varMinOccurs;
     var varMaxOccursAttr = xmlNode.getAttributeNode( "maxOccurs" );
     var varMaxOccurs;
 
     var varRefAttr       = xmlNode.getAttributeNode( "ref" );
     var varDefaultAttr   = xmlNode.getAttributeNode( "default" );    
     var varDefaultValue  = null;
  
     if ( varMinOccursAttr != null )
     {
       varMinOccurs = varMinOccursAttr.getNodeValue();
     }
                  
     if ( varMaxOccursAttr != null )
     {
       varMaxOccurs = varMaxOccursAttr.getNodeValue();
     }
        
     if ( varDefaultAttr != null )
     {
       varDefaultValue = varDefaultAttr.getNodeValue();
     }
      
      // If this is a ref, we may need to grab the ref value and use it as the name and the type
  
     if ( varRefAttr != null )
     {
       refValue = varRefAttr.getNodeValue();
           
       if ( refValue != "soapenc:arrayType" )
       {
         varName = varType = stripNSPrefix(refValue,result);
                  
         result.js += "\n  this.$$refs[ \"" + varName + "\" ] = true;" ; 
       }
     }
                 
     var isArrayType = false;

     // If maxOccurs is present and is unbounded or greater than 1, this object is an array type
     
     if ( varMaxOccursAttr != null &amp;&amp; ( varMaxOccurs == "unbounded" || parseInt(varMaxOccurs, 10) &gt; 1 ) )
     {
       isArrayType = true;
     }
     
     // If minOccurs is present and is zero, capture that information
     // Note: we could don't capture all minOccurs values since that seems like unnecessary overhead
     else
     if ( varMinOccursAttr != null &amp;&amp; parseInt(varMinOccurs, 10) == 0 )
     {
       result.js += "\n  this.$$minOccurs[ \"" + varName + "\" ] = 0;" ;
     }
                  
     emitMemberVariable( pendingObj, varName, varType, varDefaultValue, isArrayType, nsOverride, result );
  }
}

// Emit enumerations into the current function

function emitEnumerations( pendingObj, result )
{
   var en;
   for ( en in pendingObj.enumerations )
   {
     var xmlNode = pendingObj.enumerations[ en ];
         
     if( ! isXmlNodeType( xmlNode ) ) { // verify indeed an xml node type 
    	 continue;
     }
     
     var enumType = xmlNode.getAttributeValue( "type" );
        
     if ( isXMLSchemaType( enumType, result ) &amp;&amp; enumType.indexOf(":") &lt; 0 )
     {       
       if ( schemaNSPrefix != null ) // could be null if no namespace prefix was ever defined for XML schema
       {
         enumType = schemaNSPrefix + ":" + enumType; // use global schemaNSPrefix; last schema seen might not define
       }
       else
       {
         enumType = jsTypeFor( enumType );
       }
     }
  
     enumType = transformName( enumType );
     
     var  newName = transformName( en );

     if ( ! isValidJsIdentifier(newName) )
     {
       newName = "enum_" + newName;
     }
     
     if ( newName != en )
     {
       emitNameTransform( en, newName, result );
     }
     result.js += "\n  this." + newName + " = new " + enumType + "( \"" + en + "\" );";
   }
}

// Emit all the pending function objects for XML level &gt;= current level

function emitPendingFunctionObjects( xmlLevel, result )
{   
  var xmlNode = null;

  var obj;  
  for ( obj in pendingObjects )
  {
    var pendingObj = pendingObjects[ obj ];

    if( ! ( pendingObj &amp;&amp; pendingObjects.hasOwnProperty( obj ) ) ) {
        continue;
    }

    // restore schemaNSPrefix info that was in effect when we created this object
    // so that isXMLSchemaType works properly for complex wsdl that uses
    // different prefixes in different imported schema files, or no prefix in some,
    // or defines both xmlns= and xmlns:xxx= for XML schema types

    result.schemaNSPrefix    = pendingObj.schemaNSPrefix;
    result.schemaNSisDefault = pendingObj.schemaNSisDefault;

    if ( pendingObj &amp;&amp; !pendingObj.emitted &amp;&amp; pendingObj.xmlLevel &gt;= xmlLevel )
    {
      // Start emitting a function for the current object

      if ( ! pendingObj.isXMLSchemaType )
      {
        //if ( pendingObj.isRestrictedType &amp;&amp; pendingObj.members.length == 0 )
        if ( ! pendingObj.isExtendedType &amp;&amp; pendingObj.members.length == 0 )
        {        
 
          // No members. Could be because a complex type was not known when first seen
          // Check to see if type is known now.
            
          var typeName = getType( pendingObj );
            
          if ( typeName != null )
          {
            typeName = stripNSPrefix( typeName, result );
            
            if ( isKnownComplexType( typeName ) )
            {
              pendingObj.hasComplexContent = true;
             
              copyMembers( pendingObj,    pendingObjects[ typeName ] );
              copyAttributes( pendingObj, pendingObjects[ typeName ] );
            
            }
            else
            {
              pendingObj.hasSimpleContent = true;
            }
          }
          else
          if ( ! pendingObj.hasComplexContent ) // We can have complex types that are empty, if so, donâ€™t force simple content!
          {
            pendingObj.hasSimpleContent = true;
          }
        }
      }
      
      startFunction( pendingObj, result );
      
      emitAttributes( pendingObj, result );
      
      // If this is an extended complex type, do extension now
      
      if ( pendingObj.isExtendedType &amp;&amp; ! isXMLSchemaType( pendingObj.extensionBase, result ) )
      {
        var extensionType = stripNSPrefix(pendingObj.extensionBase,result);
        
        // See if we have a pending function object that matches the extension base type
        
        if ( pendingObjects[ extensionType ] != undefined )
        {
          // Emit member variables for the fields defined by the extension base type
          
          var nsOverride = pendingObjects[ extensionType ].nsPrefix;
          
          emitMembers( pendingObjects[ extensionType ], nsOverride, result );
          
          emitAttributes( pendingObjects[ extensionType ], result );
        }
        else {
          issueMsg( result,  "Warning: could not find extension base type " + extensionType );
        }
      }
      
      // Emit member variables

      emitMembers( pendingObj, undefined, result );
      
      // Emit enumerations
      
      emitEnumerations( pendingObj, result );

      // We have emitted this functionObject, so mark it as emitted

      pendingObj.emitted = true;

      closeFunction( result );
    }
  }
}

function startFunction( functionObject, result )
{
  var funcName = transformName( functionObject.funcName );
      
  var soap = false;
  
  if ( functionObject.funcName.startsWith("soap:") )
  {
    soap = true;
    
    result.js += "\nfunction " + funcName + "( ) \n{" ;
  
    result.js += "\n  this.$$nsPrefix = \"soap\";"; 
    result.js += "\n  this.$$elementFormDefault = \"qualified\";";
  }
  else
  {     
    result.js += "\nfunction " + funcName + "( " + (functionObject.hasSimpleContent ? "val" : "") + " ) \n{" ;
  
    if ( functionObject.isXMLSchemaType )
    {
      result.js += "\n  this.$$nsPrefix = \"xsd\";";
    }
    else
    {
      result.js += "\n  this.$$nsPrefix = \"" + functionObject.nsPrefix + "\";";  
    }
      
    result.js += "\n  this.$$elementFormDefault = \"" + functionObject.elementFormDefault + "\";";
  }

  result.js += "\n  this.$$attributes = [];";

  result.js += "\n  this.$$xmlNames = [];";
  result.js += "\n  this.$$objNames = [];";   
  
  // To be able to suppress empty minOccurs=0 elements
  
  result.js += "\n  this.$$minOccurs = [];";
  
  // To identify ref= objects during serialization
  
  result.js += "\n  this.$$refs = [];";    
  
  if ( functionObject.hasSimpleContent )
  {
   result.js += "\n  this.getValue = getValue;";
   result.js += "\n  this.setValue = setValue;";
   result.js += "\n  this.$$value = val;" ;
   
   // objects which might be passed to invoke() as SOAP Header content
   // need this material
   
   if ( functionObject.isSOAPHeaderPart )
   {
       result.js += "\n  this.getName = getName;";
       result.js += "\n  this.getXmlName = getXmlName;";
       result.js += "\n  this.$$name = \"" + funcName + "\";";
       result.js += "\n  this.$$xmlNames[ \"" + funcName + "\" ] = \"" + functionObject.xmlName + "\";"; 
   }
  }
  else
  if ( functionObject.hasComplexContent )
  {
    result.js += "\n  this.getName = getName;";
    result.js += "\n  this.getXmlName = getXmlName;";
    result.js += "\n  this.setContent = setContent;";
    result.js += "\n  this.addContent = addContent;";
    result.js += "\n  this.getContent = getContent;";
    result.js += "\n  this.isFault = isFault;";
 
    result.js += "\n  this.$$elementChildren = [];";

    result.js += "\n  this.$$name = \"" + funcName + "\";";

    if ( soap )
    {
      result.js += "\n  this.$$xmlNames[ \"" + funcName + "\" ] = \"" + functionObject.funcName + "\";";
    }
    else
    {   
      result.js += "\n  this.$$xmlNames[ \"" + funcName + "\" ] = \"" + functionObject.xmlName + "\";";  
 
      // For just-in-time child object generation
  
     result.js += "\n  this.$$childElementFunctions = [];";
     result.js += "\n  this.getChildFunc = getChildFunc; "; 
     result.js += "\n  if ( arguments.length &gt; 0 )\n  {"; 
     result.js += "\n    this.$$deserializing = arguments[0];\n  }";
    }
     
  }
}

function emitAttribute( functionObject, xmlNode, result )
{
   var attrValue = null;
   var typeAttrValue = null;
   var nameAttrValue = null;
   
   var nameAttr    = xmlNode.getAttributeNode("name");
   var varRefAttr  = xmlNode.getAttributeNode("ref" );
   var typeAttr    = xmlNode.getAttributeNode("type");
   var useAttr     = xmlNode.getAttributeNode("use");
   var fixedAttr   = xmlNode.getAttributeNode("fixed");
   var defaultAttr = xmlNode.getAttributeNode("default");

   if ( nameAttr != null ) {
     nameAttrValue = nameAttr.getNodeValue();
   }
       
    // See if there is a default or fixed value for the attribute

    if ( defaultAttr != null )
    { 
      attrValue = defaultAttr.getNodeValue();
    }
    else
    if ( fixedAttr != null )
    { 
      attrValue = fixedAttr.getNodeValue();
    }

   if ( typeAttr == null )
   {
     if ( functionObject.isRestrictedType )
     {                     
       typeAttrValue = functionObject.restrictionBase;
     }
     else
     {
       // could be &lt;xs:attribute ref=.... /&gt; 
       
      if ( varRefAttr != null )
      {          
         nameAttrValue = stripNSPrefix( varRefAttr.getNodeValue(),result);
         
         typeAttrValue = "xsd:string"; 
       }
       else
       {
         //could be list data type
         /**
          &lt;s:attribute name="objectIds" use="required"&gt;
            &lt;s:simpleType&gt;
              &lt;s:list itemType="s:int" /&gt;
            &lt;/s:simpleType&gt;
          &lt;/s:attribute&gt;
         */
          // treat it as string like "000001 000002"
          typeAttrValue = "xsd:string";
       }          
     }
   }
   else {
     typeAttrValue = typeAttr.getNodeValue();
   }
   
   if ( typeAttrValue == null )
   {
     throw( functionObject.funcName + ": Can't handle attribute " + nameAttr.getNodeValue() );
   }
        
   emitAttribute2( nameAttrValue, attrValue, typeAttrValue, result );
}

function emitAttribute2( attrName, attrValue, attrType, result )
{ 
    var oldName = attrName;

    if ( attrName == "xmlns" &amp;&amp; attrValue != result.targetNSURI )
    {
      var oldAttrValue = attrValue;
      attrValue = result.targetNSURI;
    }
    else
    if ( attrName == "xsi:type" &amp;&amp; attrValue == null )
    {
      oldAttrValue = attrValue;
      attrValue = attrType;
    }
    
    attrName = transformName( attrName );

    result.js += "\n  this." + attrName + " = new ";

    result.js += jsTypeFor(attrType,result) + "(" + (attrValue != null ? "\""+attrValue+"\"" : "") + ");" ;

    result.js += "\n  this.$$attributes.push( \"" + attrName + "\" );" ;

    if ( attrName != oldName )
    {
      emitNameTransform( oldName, attrName, result );
    }
}

function emitMemberVariable( pendingObj, varName, varType, varDefaultValue, isArrayType, nsOverride, result )
{
  var bIsXMLSchemaType = false;
  var unmangledType;
  var oldName;
  var arrayOfVarType;
  var arrayOfVarTypeIsSimpleType = false;
  
  var soap = false;
  
  if ( pendingObj.funcName.startsWith("soap:") )
  {
    soap = true;
  }
  
  varName = stripNSPrefix( varName, result );
  
  oldName = varName;
  
  varName = transformName( varName );

  if ( varName != oldName )
  {
    emitNameTransform( oldName, varName, result );
  }

  // May need to strip "[]" off the end of the type - happens with rpc-encoded services
  
  if ( isArrayType )
  {
    if ( varType.endsWith( "]" ) )
    {
      varType = stripBracketsFromType( varType );
    }
  }

  if ( ! isXMLSchemaType( varType, result ) )
  {
    varType = stripNSPrefix( varType, result ); // strip possible target NS prefix
  }
  else // Make sure we have NS prefix for all XML schema types. 
       // Don't emit "new string()" just because no namespace prefix was defined for XML schema namespace
  {
     bIsXMLSchemaType = true;
     
     if ( varType.indexOf(":") &lt; 0 )
     {
       if ( schemaNSPrefix != null ) // could be null if no namespace prefix was ever defined for XML schema
       {
         varType = schemaNSPrefix + ":" + varType; // use global schemaNSPrefix; last schema seen might not define
       }
     }
  }
  
  unmangledType = varType;
  
  if ( isArrayType )
  {
    arrayOfVarType = transformName(varType);
    
    var tmpFuncObj = pendingObjects[ varType ];
    
    if ( tmpFuncObj == null )
    {     
      tmpFuncObj = pendingObjects[ arrayOfVarType ];
    }
    
    if ( tmpFuncObj != null )
    { 
      arrayOfVarTypeIsSimpleType = tmpFuncObj.hasSimpleContent; 
    }
    else
    {
      arrayOfVarTypeIsSimpleType = false;
    }
    
    varType = "Array";
  }
  else
  {
   varType = transformName( varType );  
   
   if ( pendingObj.hasComplexContent &amp;&amp; ! soap )
   { 
     result.js += "\n  if ( this.$$deserializing == undefined )\n  {";
   }
  }
  
  result.js += "\n  this." + varName + " = ";

  if ( varDefaultValue != null )
  {   
    var isString = false;
    var tmpFuncObj = pendingObjects[ varType ];
    
    if ( tmpFuncObj != null &amp;&amp; tmpFuncObj.isRestrictedType )
    {
      isString = isXMLSchemaType(tmpFuncObj.restrictionBase, result) 
              &amp;&amp; jsTypeFor(tmpFuncObj.restrictionBase, result) == "String";
    }
    else
    {      
      isString = bIsXMLSchemaType &amp;&amp; jsTypeFor(unmangledType,result) == "String";
    }
    
    if ( isString ) {
      result.js += "new " + varType + "( \"" + varDefaultValue + "\" );" ;
    }
    else {
      result.js += "new " + varType + "( "   + varDefaultValue + " );" ;
    }
  }
  else {
    result.js += "new " + varType + "();" ;
  }

  if ( isArrayType )
  {
    result.js += "  // of " + arrayOfVarType ;
    
    result.js += "\n  this." + varName + ".$$nsPrefix = \"" + pendingObj.nsPrefix + "\"";
    
    result.js += "\n // method to create a new member of the " + varName + " array";
    result.js += "\n  this." + varName + ".newInstance = function( bDeserializing )\n  {";
    result.js += "\n    var newObj = new " + arrayOfVarType + "( " + ( arrayOfVarTypeIsSimpleType ? "" : "bDeserializing" ) + " );" ;
    result.js += "\n    this.push( newObj );" ;
    result.js += "\n    return newObj;\n  }" ;
    
    // Continue to emit the old "_newInstance" method for backward compatibility
    
    result.js += "\n // _newInstance syntax (deprecated) for backward compatibility";
    result.js += "\n  this." + varName + "_newInstance = function( bDeserializing )\n  {";
    result.js += "\n    var newLen = this." + varName + ".push( new " + arrayOfVarType + "( " + ( arrayOfVarTypeIsSimpleType ? "" : "bDeserializing" ) + " ) );" ;
    result.js += "\n    return this." + varName + "[ newLen-1 ];\n  }" ;    
    
    if ( varName == "item" )
    {
      result.js += "\n  this.length = function()\n  {";
      result.js += "\n    return this.item.length;\n  }" ;
      result.js += "\n  this." + arrayOfVarType + " = this.item;";
      result.js += "\n  this." + arrayOfVarType + "_newInstance = this.item_newInstance;";
      result.js += "\n  this." + arrayOfVarType + ".newInstance = this.item.newInstance;";      
    }
  }
  else
  {
     if ( pendingObj.hasComplexContent &amp;&amp; ! soap )
     {
       result.js += "\n  }";
      
       result.js += "\n  this.$$childElementFunctions[ \"" + varName + "\" ] = " + varType + ";";
     }
  }
 
/*     
  if ( nsOverride != undefined )
  {
     result.js += "\n  this." + varName + ".$$nsPrefix = \"" + nsOverride + "\"";
      
     result.js += "\n  this.$$refs[ \"" + varName + "\" ] = true;" ;
  }
 */
  
  result.js += "\n  this.$$elementChildren.push( \"" + varName + "\" );" ; 
}

function closeFunction( result )
{
    result.js += "\n}\n";        
}

function stripBracketsFromType( varType )
{
   var offs = varType.length - 1;
    
   while( offs &gt; 0 &amp;&amp; varType.charAt(offs) == "]" || varType.charAt(offs) == "[" || varType.charAt(offs) == " " )
   {
     offs--;
   }

   return varType.substr(0,offs+1);
}

// Returns true if the type has a namespace prefix which matches a prefix previously
// declared as the XML Schema namespace. 

function isXMLSchemaType( varType, result )
{
  var typeHasPrefix = ( varType.indexOf( ":" ) &gt; 0 );

  if ( typeHasPrefix )
  {
     var typePrefix = varType.before( ":" );

     if ( typePrefix == result.schemaNSPrefix || typePrefix == schemaNSPrefix || typePrefix == result.WSDLXMLSchemaNSPrefix )
     {
       return true;
     }
     else {
       return false;
     }
  }
  else  // type has no prefix
  {
     if ( jsTypes[ varType ] != undefined &amp;&amp; result.schemaNSisDefault ) // type matches XML schema type and xmlns= defined for XML schema NS
     {
       return true;
     }
  }

  return false;
}

function jsTypeFor( type, result )
{
  type = stripNSPrefix( type, result );

  var jsType = jsTypes[ type ];

  if ( jsType === undefined )
  {
    // Need to look this type up and possibly substitute a restriction base
    
    var funcObj = pendingObjects[ type ];
    
    if ( funcObj != undefined )
    {
      if ( funcObj.isRestrictedType )
      {        
        jsType = jsTypes[ funcObj.restrictionBase ];
        
        if ( jsType != undefined )
        {
          return jsType;
        }
      }
    }
 
    return "String";
  }

  return jsType;
}

// Strip any XML Schema prefix or targetNamespace prefix from type attribute value

function stripNSPrefix( varType, result )
{
 var i = varType.indexOf( ":" );
 
 if ( i &lt; 0 ) {
   return varType;
 }

  return varType.substr(i+1);
}

function emitStandardMethods( result )
{
  // getChildFunc

  result.js += "\nfunction getChildFunc( childElemName ) \n{" ;
  result.js += "\n return this.$$childElementFunctions[ childElemName ];\n}\n" ;
    
  // getName

  result.js += "\nfunction getName( ) \n{" ;
  result.js += "\n return this.$$name;\n}\n" ;

  // getXmlName

  result.js += "\nfunction getXmlName( ) \n{" ;
  result.js += "\n return this.$$xmlNames[ this.$$name ];\n}\n" ;

  // getValue

  result.js += "\nfunction getValue( ) \n{" ;
  result.js += "\n return this.$$value;\n}\n" ;

  // setValue

  result.js += "\nfunction setValue( value ) \n{" ;
  result.js += "\n this.$$value = value;\n}\n" ;

  // setContent
  
  result.js += "\nfunction setContent( obj, obj2 ) \n{" ;
  result.js += "\n  var name = obj.getXmlName();" ;
  result.js += "\n  if ( name.indexOf(\":\") &gt; 0 ) \n  {" ;
  result.js += "\n    name = name.after(\":\");\n  }" ;
  
  result.js += "\n  this.$$elementChildren.length = 0;";
  result.js += "\n  this.$$elementChildren.push( name );" ; 
  result.js += "\n  this[ name ] = obj;\n" ;
  result.js += "\n  this.$$refs[ name ] = true;\n" ;
  
  result.js += "\n  if ( obj2 != undefined )\n  {" ;
  result.js += "\n    name = obj2.getXmlName();" ;
  result.js += "\n    if ( name.indexOf(\":\") &gt; 0 ) \n    {" ;
  result.js += "\n      name = name.after(\":\");\n    }\n" ;
  result.js += "\n    this.$$elementChildren.push( name );" ;
  result.js += "\n    this.$$refs[ name ] = true;\n" ;
  result.js += "\n    this[ name ] = obj2;\n  }\n}\n" ;

 // addContent

  result.js += "\nfunction addContent( obj ) \n{" ;
  result.js += "\n  var name = obj.getXmlName();" ;
  result.js += "\n  if ( name.indexOf(\":\") &gt; 0 ) \n  {" ;
  result.js += "\n    name = name.after(\":\");\n  }\n" ;
  result.js += "\n  this.$$elementChildren.push( name );" ;
  result.js += "\n  this.$$refs[ name ] = true;\n" ;
  result.js += "\n  this[ name ] = obj;\n}\n" ;

  
  // getContent
  result.js += "\nfunction getContent( ) \n{" ;
  result.js += "\n  return this[this.$$elementChildren[0]];\n}\n" ;

 // isFault
  result.js += "\nfunction isFault( ) \n{" ;
  result.js += "\n  return this.$$name == \"soap_Fault\";\n}\n" ;
}

function emitSOAPLibInit( result )
{
  result.js += "\n// Ensure that material in lib.SOAP is available\n";

  result.js += "\nlib.SOAP.init();\n";
  result.js += "/// End ----------------";
}

function emitNameTransform( oldName, newName, result )
{
  result.js += "\n  this.$$xmlNames[\"" + newName + "\"] = \"" + oldName + "\";" ;
  result.js += "\n  this.$$objNames[\"" + oldName + "\"] = \"" + newName + "\";" ;
}

// returns true if xmlNode is &lt;definitions&gt; wsdl node

function isDefinitionsNode(xmlNode)
{
   if ( xmlNode.getNodeName() != "definitions" )
   {
     return false;
   }
   
   if ( xmlNode.isDocumentElement() )
   {
      return true;  // normal case
   }
   
   // if we imported WSDL and inserted it into the document we are traversing
   // then it will have an absolutePath attribute that we generated
   
   return ( xmlNode.getAttributeNode( "absolutePath" ) != null );
}

// returns true if xmlNode is &lt;types&gt; wsdl node

function isTypesNode(xmlNode)
{
  var parent = xmlNode.getParentNode();
  return ( xmlNode.getNodeName() == "types" &amp;&amp; parent != null &amp;&amp; parent.getNodeName() == "definitions" );
}

// returns true if xmlNode is &lt;schema&gt; XML schema node

function isXMLSchemaNode( xmlNode, schemaNSPrefix )
{ 
  var nodeName = xmlNode.getNodeName();
  
  if ( nodeName == "schema" &amp;&amp; schemaNSPrefix != null &amp;&amp; xmlNode.getPrefix() == schemaNSPrefix  )
  {
    return true;
  }
  
  // Sometimes we see wsdl with a plain &lt;schema&gt; element 
  
  var parent = xmlNode.getParentNode();
  var grandparent;
  
  if ( parent )
  {
    grandparent = parent.getParentNode();
  }
  
  if ( xmlNode.getNodeName() == "schema" 
   &amp;&amp; parent != null &amp;&amp; parent.getNodeName() == "types"
   &amp;&amp; grandparent != null &amp;&amp; grandparent.getNodeName() == "definitions" )
  {
    return true;
  }
  
  return false;
}

// returns true if xmlNode is &lt;import&gt; or &lt;include&gt; XML schema node

function isXMLSchemaImportNode( xmlNode, schemaNSPrefix )
{
  var nodeName = xmlNode.getNodeName();
  
  if ( (nodeName == "import" || nodeName == "include") &amp;&amp; schemaNSPrefix != null &amp;&amp; xmlNode.getPrefix() == schemaNSPrefix  )
  {
    return true;
  }
  
  // Sometimes we see WSDL with an unprefixed &lt;import&gt; element
  
  var parent = xmlNode.getParentNode();
  
  if ( ( nodeName == "import" || nodeName == "include" )
   &amp;&amp; parent != null &amp;&amp; parent.getNodeName() == "schema" )
  {
    return true;
  }
  
  return false;  
}

// returns true if xmlNode is &lt;wsdl:import&gt; node

function isWSDLImportNode( xmlNode, wsdlNSPrefix )
{
  var nodeName = xmlNode.getNodeName();
  
  if ( (nodeName == "import" ) &amp;&amp; schemaNSPrefix != null &amp;&amp; xmlNode.getPrefix() == wsdlNSPrefix  )
  {
    return true;
  }
  
  // We could see WSDL with an unprefixed &lt;import&gt; element if the default namespace is wsdl
  // We can just check to see if the parent is "definitions", since any wsdl:import node has to be a child of wsdl:definitions.
  
  var parent = xmlNode.getParentNode();
  
  if ( nodeName == "import" &amp;&amp; parent != null &amp;&amp; parent.getNodeName() == "definitions" )
  {
    return true;
  }
  
  return false;  
}

// returns true if xmlNode is &lt;message&gt; wsdl node

function isMessageNode(xmlNode)
{
  var parent = xmlNode.getParentNode();
  return ( xmlNode.getNodeName() == "message" &amp;&amp; parent != null &amp;&amp; isDefinitionsNode( parent ) );
}

// returns true if xmlNode is &lt;portType&gt; wsdl node  

function isPortTypeNode(xmlNode)
{
  var parent = xmlNode.getParentNode();
  return ( xmlNode.getNodeName() == "portType" &amp;&amp; parent != null &amp;&amp; isDefinitionsNode( parent ) );
}

// returns true if xmlNode is &lt;binding&gt; wsdl node  

function isBindingNode(xmlNode)
{  
  var parent = xmlNode.getParentNode();
  return ( xmlNode.getNodeName() == "binding" &amp;&amp; parent != null &amp;&amp; isDefinitionsNode( parent ) );
}

// returns true if xmlNode is &lt;soap:binding&gt; within wsdl binding

function isSOAPBindingNode(xmlNode,result)
{
  return ( result.inBindingElement &amp;&amp; xmlNode.getNodeName() == "binding" &amp;&amp; xmlNode.getPrefix() == result.soapNSPrefix ); // soap:binding element within wsdl:binding
}

// returns true if xmlNode is &lt;service&gt; wsdl node

function isServiceNode(xmlNode)
{
  var parent = xmlNode.getParentNode();
  
  return ( xmlNode.getNodeName() == "service" &amp;&amp; parent != null &amp;&amp; isDefinitionsNode( parent ) );
}

// get targetNamespace URI from xmlNode

function getTargetNamespaceURI( xmlNode )
{
  var targetNSattr = xmlNode.getAttributeNode("targetNamespace");

  if ( targetNSattr != null )
  {
    return targetNSattr.getNodeValue();
  }
  return null;
}

// get elementFormDefault attribute value from xmlNode

function getElementFormDefault( xmlNode )
{
  var elemFormDefault = xmlNode.getAttributeNode("elementFormDefault");

  if ( elemFormDefault != null )
  {
    return elemFormDefault.getNodeValue();
  }
  return "unqualified";  // blech
}

function addXmlSchemaTypeAttrs( funcObj, xmlNode, xsdTypeVal )
{
  if ( ! xsdTypeVal.startsWith( "xsd" ) &amp;&amp; ! xsdTypeVal.startsWith( funcObj.nsPrefix + ":" ) )
  {   
    xsdTypeVal = funcObj.nsPrefix + ":" + stripNSPrefix(xsdTypeVal,null);
  }
  
  xmlNode.addAttribute( "name", "xsi:type" ); // our SOAP Envelope declares xsi namespace prefix
  xmlNode.addAttribute( "fixed", xsdTypeVal );
  xmlNode.addAttribute( "type", "xsd:string" );

  funcObj.attributes.push( xmlNode );
}

// make a function object from an XML Schema type value, for example xsd_int

function makeXMLSchemaTypeFunction( mangledTypeName, typeName, result )
{ 
  var funcObj = new functionObject( result, mangledTypeName, typeName, 0 );

  funcObj.hasSimpleContent = true;
  funcObj.isXMLSchemaType = true;

  var xsdTypeVal = "xsd:" + typeName.after(":");
  
  // Create an XML node here just to use as a container to push on the attributes stack
  // for the pending function object. Alternatively we could change the member and attribute
  // stacks to use our own objects rather than xmlNodes from the WSDL document....

  var xmlNode = result.xmlDoc.createNode( 1, mangledTypeName, "");

  addXmlSchemaTypeAttrs( funcObj, xmlNode, xsdTypeVal );
                        
  pendingObjects[ mangledTypeName ] = funcObj;
  pendingObjects.length ++;
  
  return funcObj;
}

function addTargetNSAttributeToMessage( funcObj, result )
{  
  var xmlNode;
  
  if ( funcObj == null || funcObj == undefined ) {
    return;
  }
 
  var attrName = "xmlns_" + funcObj.nsPrefix;
  
  // If we already have this attribute, we need to update it
  
  var i, length = funcObj.attributes ? funcObj.attributes.length : 0;
  for( i = 0; i &lt; length; i++ )
  {
     xmlNode = funcObj.attributes[ i ];

     if ( xmlNode.getNodeName() == attrName )
     {
       xmlNode.setAttributeValue( "name", "xmlns:" + funcObj.nsPrefix );
       xmlNode.setAttributeValue( "fixed", funcObj.namespace );
       return;
     }
  }
  

  // We create an XML node here just to use as a container to push on the attributes stack
  // for the pending function object. Alternatively we could change the member and attribute
  // stacks to use our own objects rather than xmlNodes from the WSDL document....
    
  xmlNode = result.xmlDoc.createNode( 1, attrName, "" );
       
  xmlNode.addAttribute( "name", "xmlns:" + funcObj.nsPrefix );  
  xmlNode.addAttribute( "fixed", funcObj.namespace );
  xmlNode.addAttribute( "type", "xsd:string" );

  funcObj.attributes.push( xmlNode );
}

// Given an absolute path to a document and a relative path contained in that document
// return absolute path for relative path

function getAbsolutePath( filePath, relativePath, bConformSlashes )
{
  var ijk = filePath.length - 1;
                
  while( ijk &gt; 0 )
  {              
    var ch = filePath.charAt(ijk);
 
    if ( ch == "/"  ) { break; }  // c:/foo.wsdl
    if ( ch == "\\" ) { break; }  // c:\foo.wsdl
    if ( ch == ":"  ) { break; }  // c:foo.wsdl
  
    ijk -- ;
  }
      
  if ( ijk &lt; 0 ) {
    ijk = 0;
  }
      
  var path = filePath.substring( 0, ijk );
      
  if ( ! path.endsWith( "/" ) &amp;&amp; ! path.endsWith( "\\" ) )
  {
    path += "/";
  }
      
  path += relativePath;
      
  if ( bConformSlashes )
  {    
    // Make sure all slashes are correct for the OS we are running on
  
    if ( os_info[0] == "winnt" )
    {
       path = path.replace( /\//g,"\\" );  // Windows: make all slashes back slashes
    }
    else
    {
       path = path.replace( /\\/g,"/" );   // Unix: make all slashes forward slashes
    }
  }
         
  //print( "getAbsolutePath returned ", path, " for ", filePath, " and ", relativePath );
     
  return path;
}

function getImportedSchemaOrWSDL( xmlNode, bIsSchema, bIncludedSchema, result )
{
 // 1. If schema, get the location attribute from xmlNode, if WSDL, get the schemaLocation attribute. Must be an HTTP or file URL.
 // 2. do an HTTP GET or file read to fetch the new schema or WSDL document
 // 3. Parse the XML schema or WSDL into a new XML object and verify that document element is "schema" or "definitions"
 // 4. Get the "schema" or "definitions" node and import it into the document we are traversing
 // 5. If schema, append the new node to the "types" node of the document we are traversing. 
 //    If WSDL, append the new node following the current node of the document we are traversing, i.e. just after the import node
 
 var location;

 if ( bIsSchema )
 {
   location = xmlNode.getAttributeValue( "schemaLocation" );
 }
 else {
   location = xmlNode.getAttributeValue( "location" );
 }
 
 if ( location == null || location.length == 0 )
 {
   issueMsg( result,  "Unable to import schema/WSDL - missing schemaLocation/location attribute" );

   return false;
 }
 
 var strSchemaOrWSDLXML = null;
 var strSchemaOrWSDLPath = null;
 
 var bSrcIsFile = false;
 
 if ( location.startsWith( "http" ) )
 {
   issueMsg( result,  "Getting imported schema or WSDL from " + location );
   try
   {
     var headers = []; // required, but can be empty
     
     if ( result.userid != undefined )
     {
       var authHeader = new Header();
           
       authHeader.name = "Authorization";
       authHeader.value = "Basic " + lib.Base64Encoder.encode( result.userid + ":" + result.password );//base64Encode( result.userid + ":" + result.password ); 
      
       headers.push( authHeader );  
     }
           
     strSchemaOrWSDLXML = doHTTPRequest( "GET", location, headers, null, 10, 10, 10 );
   }
   catch( e )
   {
     issueMsg( result,  "HTTP request for imported schema or WSDL failed with exception " + e );
     return false;
   }
 }
 else
 if ( location.startsWith( "file:" ) )
  {
     strSchemaOrWSDLPath = location.after("file://");
     bSrcIsFile = true;
  }
 else // try to handle relative path expressions like "../foo/bar/blah.xsd"
 {    //  in schemaLocation attributes for import statements for additional schema.
   
   strSchemaOrWSDLPath = "";
   
   if ( result.bWSDLsrcIsFile )
   {
      bSrcIsFile = true;
      
      // We have encountered a relative path expression in a document.
      // Need to convert it to an absolute path.
      // First get the absolute file Path for the schema or WSDL document this relative path
      // was encountered in
      
      var schemaOrDefinitionsElem = xmlNode.getParentNode();
      
      if ( bIsSchema &amp;&amp; schemaOrDefinitionsElem.getNodeName() != "schema" )
      {
        throw( "Parent of import/include is not schema node" ); 
      }
      else
      if ( ! bIsSchema &amp;&amp; schemaOrDefinitionsElem.getNodeName() != "definitions" )
      {
        throw( "Parent of WSDL import is not definitions node" );
      }
      
      var filePath = schemaOrDefinitionsElem.getAttributeValue( "absolutePath" );
      
      if ( filePath.length == 0 ) // parent document must be the initial WSDL doc
      {
        filePath = xmlNode.getDocumentElement().getAttributeValue( "absolutePath" );
      }     
           
      strSchemaOrWSDLPath = getAbsolutePath( filePath, location, true );
   }
        
   // If the source of the schema or WSDL is file, make sure we can open the file
   // and read it manually rather than having the XML object do it.
   // The reason is we cannot distinguish between file open failures and parsing errors
   // if we have the XML object open the file, which is bad. We ended up reporting parsing
   // failures when really the user just mis-typed the file name
  
   if ( bSrcIsFile )
   {    
     strSchemaOrWSDLXML = readFile( strSchemaOrWSDLPath, "t" );
    
     if ( typeof strSchemaOrWSDLXML != "string" )  // readFile returns integer return code on error
     {
       issueMsg( result, "Unable to open schema or WSDL import/include file "+ strSchemaOrWSDLPath );
      
       return false;
     }
   }
   else
   {
     var tempLoc = getAbsolutePath( result.wsdlURL, location, false );
       
     try
     {
       var headers = [];
       
       if ( result.userid != undefined )
       {
         var authHeader = new Header();
           
         authHeader.name = "Authorization";
         authHeader.value = "Basic " + lib.Base64Encoder.encode( result.userid + ":" + result.password );//base64Encode( result.userid + ":" + result.password ); 
      
         headers.push( authHeader );  
       }
      
       strSchemaOrWSDLXML = doHTTPRequest( "GET", tempLoc, headers, null, 10, 10, 10 );
     }
     catch( e )
     {      
       issueMsg( result, "HTTP GET request for imported schema or WSDL failed with exception " + e );
       return false;
     }
   }
  }
  
  var xmlNewDoc = new XML();
  
  if ( ! xmlNewDoc.setContent( strSchemaOrWSDLXML, false ) )
  {
    issueMsg( result,  "Error parsing imported/included schema or WSDL" );
    return false;
  }
 
 var docElem = xmlNewDoc.getDocumentElement();
 
 if ( ! bIsSchema &amp;&amp; docElem.getNodeName() != "definitions" )
 {
   issueMsg( result,  "Imported WSDL document does not have a root element of definitions" );
   return false;
 }
 else
 if ( bIsSchema &amp;&amp; docElem.getNodeName() != "schema" )
 {
   issueMsg( result,  "Imported or included schema document does not have a root element of schema" );
   return false;
 } 
 
 // If we are including or importing schema, check to see if we have processed this schema already

 if ( bIsSchema )
 {
   // Before we process this schema, make sure we have not already done so.
   // Complex WSDL files with lots of nested imports and includes can contain multiple references
   // to the same .xsd file, and we only need to see each .xsd file once
 
   var namespace = getTargetNamespaceURI( docElem );
  
   if ( !bIncludedSchema &amp;&amp; schemas_processed[ namespace ] != undefined )
   {   
     return true;
   }

   // Don't set namespace processed if this is an included schema node
 
   if ( bIncludedSchema )
   {
     docElem.addAttribute( "included", "true" );
   }
   else
   {
     schemas_processed[ namespace ] = true;
   }

   // We successfully read this schema file, so import it into the document
   // that we are traversing (append it at the end of the types node)
   // and capture its absolute path in an attribute called "absolutePath"
   // which we create on the &lt;schema&gt; element
 
   var newNode = result.xmlDoc.importNode( docElem );
 
   newNode.addAttribute( "absolutePath", strSchemaOrWSDLPath );
 
   var typesNode = result.xmlSchemaNode.getParentNode();
 
   typesNode.appendNode( newNode ); // results in another &lt;schema&gt; node following the current one
 }
 else  // WSDL
 {
   // We successfully read this WSDL file, so import it into the document
   // that we are traversing (append it following the current import node,
   // i.e. just before the next sibling of the current node)
 
   // Capture its absolute path in an attribute called "absolutePath"
   // and add this to the &lt;definitions&gt; element
 
   var newChild = result.xmlDoc.importNode( docElem );
 
   newChild.addAttribute( "absolutePath", strSchemaOrWSDLPath );
 
   var parentNode = xmlNode.getParentNode();
 
   var brotherNode = xmlNode.getNextSiblingElement();

   // N.B. XML function insertBefore is not available in many versions of SC or SM
   // so WSDL import feature may require an RTE upgrade to work..
 
   parentNode.insertBefore( newChild, brotherNode ); // should result in new &lt;definitions&gt; node following the current &lt;import&gt; node
  }
 
 return true;
}

function visitNode( xmlNode, result )
{
  var elemQualifiedName = xmlNode.getQualifiedName();
  var elemName          = xmlNode.getNodeName();
  var elemPrefix        = xmlNode.getPrefix();
    
  // Keep track of XML depth

  if ( result.nodeLevel == undefined )
  {
    result.nodeLevel = 0;
  }
  else
  {
    result.nodeLevel ++;
  }
 
  // See what kind of XML node this is

  if ( isDefinitionsNode( xmlNode ) )
  {   
     //result.inDefinitionsNode = true;
     
     result.targetNSURI = getTargetNamespaceURI( xmlNode );   
     result.WSDLTargetNSURI = result.targetNSURI;    
   }
  else
  if ( isWSDLImportNode( xmlNode, result.wsdlNSPrefix ) )
  {
     var namespace = xmlNode.getAttributeValue( "namespace" );
     
     if ( ! getImportedSchemaOrWSDL( xmlNode, false, false, result ) )
     {
       issueMsg( result, "Error importing WSDL for namespace " + namespace );
     }
  }
  else
  if ( isTypesNode( xmlNode ) )
  {    
     result.inTypesElement = true;
     result.xmlSchemaNode = xmlNode.getFirstChildElement();
  }
  else
  if ( isXMLSchemaNode( xmlNode, result.schemaNSPrefix ) )
  {       
    var targetNSURI = getTargetNamespaceURI( xmlNode );
             
    if ( targetNSURI != null ) {
      result.targetNSURI = targetNSURI;
    }
      
    result.elementFormDefault = getElementFormDefault( xmlNode );
      
    var included = xmlNode.getAttributeValue( "included" );
    
    if ( included == "true" )
    {
      included = " additional included schema ";
    }
    else {
      included = " schema ";
    }
      
    issueMsg( result, "Processing" + included + "with namespace " + targetNSURI );  
    
    result.schemaNSisDefault = false;  // set to true during attribute processing if xmlns= seen
  }
  else
  if ( isXMLSchemaImportNode( xmlNode, result.schemaNSPrefix ) )
  { 
     var bIncluded = ( xmlNode.getNodeName() == "include" );
     var namespace = xmlNode.getAttributeValue( "namespace" ); // includes have no namespace attr
     
     if ( !bIncluded &amp;&amp; schemas_processed[ namespace ] != undefined )
     {       
       issueMsg( result, "Skipping already processed namespace " + namespace );
     }
     else
     {       
       if ( ! getImportedSchemaOrWSDL( xmlNode, true, bIncluded, result ) )
       {
         issueMsg( result, "Error importing schema for namespace " + namespace );
       }
     } 
  }
  else
  if ( isMessageNode( xmlNode ) )
  {
     result.inMessageElement = true;
     
     result.targetNSURI = result.WSDLTargetNSURI; // restore correct namespace

     result.messageName = xmlNode.getAttributeValue("name");
     
     var wsdlMsg = new WSDLMessage( result.messageName );

     WSDLMessages[ result.messageName ] = wsdlMsg;
     WSDLMessages.length ++;

     // If we have no object corresponding to the message name, start one now
 
     var pendingObj;
     
     if ( (pendingObj = pendingObjects[ result.messageName ]) == undefined )
     {         
         result.funcObj = new functionObject( result, result.messageName, result.messageName, result.nodeLevel );
         
         result.funcObj.hasComplexContent = true;
                        
         pendingObjects[ result.messageName ] = result.funcObj;
         pendingObjects.length ++;

         // All message objects need an attribute containing target namespace info
         addTargetNSAttributeToMessage( result.funcObj, result );
     }
     else // there is already some object with the same name - see if it is in the same namespace or not
     {
       if ( pendingObj.namespace != result.WSDLTargetNSURI )
       {
          issueMsg( result, "There is a " + pendingObj.funcName + " object in namespace " 
                      + globalNamespaceURIs[pendingObj.nsPrefix] + " with the same name as WSDL message " + result.messageName );
       }
     }
  }
  else
  if ( isBindingNode( xmlNode ) )
  {
     result.inBindingElement = true;
     result.transportHTTP = null;
     result.style = null;
     result.SOAPAction = null;
     result.operationName = null;
  }
  if ( isSOAPBindingNode( xmlNode, result ) )
  {
     result.inSOAPBinding = true;

     var transport = xmlNode.getAttributeValue("transport");
     var style     = xmlNode.getAttributeValue("style");

     if ( transport == "http://schemas.xmlsoap.org/soap/http" )
     {
       result.transportHTTP = true;
       result.style = style;
     }
  }  
  else
  if ( result.inSOAPBinding &amp;&amp; result.transportHTTP == true &amp;&amp; elemName == "operation" )
  {
     // This can be either the wsdl:operation OR the soap:operation element
     // Depending on which one, we will either have a name attribute or a soapAction attribute

     var opNameAttr     = xmlNode.getAttributeNode("name");
     var soapActionAttr = xmlNode.getAttributeNode("soapAction");

     if ( opNameAttr != null )
     {
        result.operationName = opNameAttr.getNodeValue();
     }
      
     if ( soapActionAttr != null )
     {
        result.SOAPAction = soapActionAttr.getNodeValue();
     }
     else {
        result.SOAPAction = "";
     }

     // When we have seen both the wsdl:operation and the soap:operation elements
     // we should have both the SOAPAction and the operation it applies to, as well as the style (rpc or doc)

     if ( result.operationName != null &amp;&amp; result.SOAPAction != null )
     {
        var soapOp = SOAPOperations[ result.operationName ];
        
        soapOp.SOAPAction = result.SOAPAction;
        soapOp.style      = result.style;
     }
  }
  else
  if ( result.inSOAPBinding &amp;&amp; result.transportHTTP == true &amp;&amp; elemName == "header" )
  {
     // Save info about WSDL parts which can appear in SOAP Headers
           
     var wsdlMsgName = xmlNode.getAttributeValue( "message" );
     var wsdlMsgPart = xmlNode.getAttributeValue( "part" );
         
     var wsdlMsg = WSDLMessages[ stripNSPrefix(wsdlMsgName,result) ];

     if ( wsdlMsg != null )
     {
       var part = wsdlMsg.parts[ wsdlMsgPart ];
     
       if ( part != null )
       {    
         var funcObj = pendingObjects[ part ];
     
         if ( funcObj != null )
         {
           funcObj.isSOAPHeaderPart = true;
         }
        }
      }
  }
  else
  if ( result.inSOAPBinding &amp;&amp; result.transportHTTP == true &amp;&amp; elemName == "body" )
  {
    // Some web services redefine the namespace URI on this element

    var namespaceAttr = xmlNode.getAttributeNode("namespace");

    if ( namespaceAttr != null )
    {      
      // Find the parent node (should be input or output)
      
      var parentNode = xmlNode.getParentNode();
      var parentNodeName = parentNode.getNodeName();
      
      if ( parentNodeName == "input" || parentNodeName == "output" )
      {
        // Get the value of the name attribute
        var nameAttr = parentNode.getAttributeNode( "name" );
        
        if ( nameAttr )
        {
          var inputMsgName = nameAttr.getNodeValue();
          
          // Find the pending object with this name
          var pendingObj = pendingObjects[ inputMsgName ];
          
          if ( pendingObj != undefined )
          {
            // Delete the old namespace from the global array
            var ns;
            for ( ns in globalNamespacePrefixes )
            {
              if ( globalNamespacePrefixes[ns] === pendingObj.nsPrefix )
              {              
                delete globalNamespacePrefixes[ns];
                delete ns;
                break;  
              }
            }
                                  
            // Set pending object's namespace property to the new value
            pendingObj.namespace = namespaceAttr.getNodeValue();
                        
            // Add new namespace to global array
            globalNamespacePrefixes[ pendingObj.namespace ] = pendingObj.nsPrefix;
            globalNamespaceURIs    [ pendingObj.nsPrefix  ] = pendingObj.namespace;    
            
            // Update the attributes associated with the pending object
            addTargetNSAttributeToMessage( pendingObj, result );   
          }
        }
      }
    }
    
    // While we are here, pick up "use" and "encodingStyle" attributes to see if encoded or literal
    
    result.encoded       = ( xmlNode.getAttributeValue("use") == "encoded" );
    result.encodingStyle = xmlNode.getAttributeValue("encodingStyle");
  }
  else
  if ( isPortTypeNode( xmlNode ) )
  {
     result.inPortTypeElement = true;
  }
  else
  if ( result.inPortTypeElement &amp;&amp; elemName == "operation" )
  {
     result.inOperationElement = true;

     var opName = xmlNode.getAttributeValue("name");

     result.operationName = opName;
     
     if ( SOAPOperations[ opName ] == undefined )
     {       
       var soapOp = new SOAPOperation( opName );

       SOAPOperations[ opName ] = soapOp;
       SOAPOperations.length ++;
     }
  }
  else
  if ( result.inOperationElement &amp;&amp; ( elemName == "input" || elemName == "output" ) )
  {
     var msgType = xmlNode.getAttributeValue("message");
     var msgName = xmlNode.getAttributeValue( "name" );  // may not have this 

     var soapOp = SOAPOperations[ result.operationName ];

     msgType = stripNSPrefix( msgType, result );

     // Look up the message name in the WSDLMessage array
     // Get the correct element type name for the SOAP Operation entry if one exists

     var msgObj      = WSDLMessages[ msgType ];
     var msgElemName = null;

     if ( msgObj != null &amp;&amp; msgObj.elemName != null )
     {
       msgElemName = msgObj.elemName;
     }
     
     if ( msgElemName == null )
     {       
       msgElemName = ( msgName != null &amp;&amp; msgName.length &gt; 0 ? msgName : msgType );
              
       // Make sure we have a pending object with the right name.
      
       if ( pendingObjects[ msgElemName ] == undefined )
       {
          var pendingTypeObj = pendingObjects[ msgType ];
          
          if ( pendingTypeObj != null )
          {           
            var newInstanceObj = new functionObject( result, msgElemName, msgElemName, 0 );
            
            newInstanceObj.hasComplexContent = true;
            
            copyMembers( newInstanceObj, pendingTypeObj );
            copyAttributes( newInstanceObj, pendingTypeObj );
                                      
            pendingObjects[ msgElemName ] = newInstanceObj;
            pendingObjects.length ++;
            
          }
       }       
     }

     if ( elemName == "input" &amp;&amp; soapOp.requestMessageName == null )
     {
       if ( soapOp.style == "rpc" )
       {
         soapOp.requestMessageName = soapOp.name;
         
         // Make sure we have a pending function object whose name matches the operation
         // For rpc style services at this point we will often have a symbolic function whose name is taken from the WSDL message element
         // but for rpc style it needs to match the operation
         
         if ( pendingObjects[ msgElemName ] != null &amp;&amp; pendingObjects[ soapOp.name ] == null )
         {
            // Rename the pending function object from the WSDL message name to the SOAP operation name
            
            pendingObjects[ msgElemName ].funcName = soapOp.name;
         }
       }
       else
       {
         soapOp.requestMessageName = msgElemName;
       }
             
       // Make sure all input message objects have an attribute containing target namespace info
    
       addTargetNSAttributeToMessage( pendingObjects[ msgElemName ], result );
     }
     else if ( elemName == "output" &amp;&amp; soapOp.responseMessageName == null )
     {
       soapOp.responseMessageName = msgElemName;
     }  
  }
  else
  if ( result.inMessageElement &amp;&amp; elemName == "part" )
  {    
     result.partName = xmlNode.getAttributeValue("name");
     
    // See if the part has an "element" attribute (usually will for doc-literal, usually not for rpc)

     elemAttr = xmlNode.getAttributeNode("element");
     typeAttr = xmlNode.getAttributeNode("type");

     if ( elemAttr != null )
     {
       var msgElemName = stripNSPrefix(elemAttr.getNodeValue(),result);

       var mangledName = transformName(elemAttr.getNodeValue() ); 

       if ( pendingObjects[ msgElemName ] == undefined 
         &amp;&amp; pendingObjects[ mangledName ] == undefined )
       {
          issueMsg( result,  "No object generated for message element " + msgElemName );
       }
       else
       {
         // Find the WSDLMessage object for this part and record the element name in it

         var wsdlMsgNode = xmlNode.getParentNode();
         var wsdlMsgName = wsdlMsgNode.getAttributeValue( "name" );

         var wsdlMsg = WSDLMessages[ wsdlMsgName ];

         wsdlMsg.elemName = msgElemName;
         wsdlMsg.parts[ result.partName ] = msgElemName; 
         wsdlMsg.parts.length++;
       }
     }
     else
     {
      // If the type is an XMLSchema built-in type, we need to make a type for it if we havent already
      // because we need a container for the value and for the "xsi:type" attribute
      // then we need to change the type of the xmlNode to reference that type
      
      var typeValue = typeAttr.getNodeValue();

      if ( isXMLSchemaType( typeValue, result ) )
      {
         var typeName = transformName( typeValue );  // e.g. xsd:int becomes xsd_int
         
         if ( pendingObjects[ typeName ] == undefined )
         {
            makeXMLSchemaTypeFunction( typeName, typeValue, result ); 
         }
         
        // xmlNode.setAttributeValue( "type", typeName );  // change type from e.g. xsd:int to xsd_int container type 
      }
            
      if ( result.funcObj != null )
      {      
        result.funcObj.members.push( xmlNode ); 
      }
     }
  }
  else
  // See if this is the soap:address element

  if ( elemPrefix == result.soapNSPrefix &amp;&amp; elemName == "address" )
  {
    result.inSoapAddressElement = true;
  }
  else
  if ( elemName == "extension" )
  {
     result.funcObj.isExtendedType = true;

     // Get the extension base attribute value

     result.funcObj.extensionBase = xmlNode.getAttributeValue("base");
  }
  else
  if ( elemName == "restriction" )
  {
     result.funcObj.isRestrictedType = true;
    
     // Get the restriction base attribute value

     result.funcObj.restrictionBase = xmlNode.getAttributeValue("base");
  }
  else
  if ( elemName == "enumeration" )
  {
     var enumValue = xmlNode.getAttributeValue( "value" );
     
     xmlNode.addAttribute( "type", result.funcObj.restrictionBase );
     
     result.funcObj.enumerations[ enumValue ] = xmlNode;
     result.funcObj.enumerations.length++;
  }
  else
  if ( elemName == "attribute" &amp;&amp; result.funcObj != undefined )
  {
     // Some xsd files like http://schemas.xmlsoap.org/ws/2004/08/addressing have standalone attributes
     // hence the check for undefined above. We ignore those.
      
     // For rpc-encoded services, attribute nodes are used to define arrays
     // Look for ref="soapenc:arrayType" wsdl:arrayType=

     if ( result.funcObj.isRestrictedType &amp;&amp; 
          result.soapencNSPrefix != undefined &amp;&amp;
          result.funcObj.restrictionBase == result.soapencNSPrefix + ":Array" 
          &amp;&amp; nodeHasAttribute( xmlNode, "ref", result.soapencNSPrefix + ":arrayType" ) )         
     {
        var wsdlArrayTypeAttr = xmlNode.getAttributeNode("wsdl:arrayType");

        if ( wsdlArrayTypeAttr != null )
        {
          var  typeName = stripBracketsFromType( wsdlArrayTypeAttr.getNodeValue() );
          
          if ( isXMLSchemaType(typeName,result) )
          {
            typeName = transformName(typeName);
          }

          // Check to make sure we don't already have a matching array property
          // for the current function object, because some services provide
          // BOTH a schema element like the one we would create here, AND
          // a schema attribute like the one we are currently processing.
          // For example, capeclear GlobalWeather. It's harmless if we 
          // dont make this check, but the generated Javascript is ugly
          // if it has duplicate array property definitions for an object
         
          if ( ! funcObjHasMember( result.funcObj, "item", typeName, "unbounded" ) )
          {
            xmlNode.addAttribute( "maxOccurs", "unbounded" );
            xmlNode.addAttribute( "name", "item" );
            xmlNode.addAttribute( "type", typeName );

            result.funcObj.members.push( xmlNode );
          }
        }
     }
     else {
       result.funcObj.attributes.push( xmlNode );   // ordinary attribute
     }
  }
  else
  if ( elemName == "simpleContent" )
  {
    result.funcObj.hasSimpleContent = true;
  }
  else
  if ( elemName == "sequence" )
  {
    result.funcObj.hasComplexContent = true;
    result.inSequence = true;
  }
  if ( elemName == "choice" )
  {
    result.funcObj.hasComplexContent = true;
    result.inChoice = true;
  }
  else
  if ( elemName == "all" )
  {
    result.funcObj.hasComplexContent = true;
  }
  else
  if ( elemName == "complexContent" )
  {
    result.funcObj.hasComplexContent = true;
  }
  else
  // See if this is an element or a complexType or a simpleType

  if ( elemName == "element" || elemName == "complexType" || elemName == "simpleType" )
  {
     if ( elemName == "element" )
     {
       result.inElement = true;
     }
     else
     if ( elemName == "complexType" )
     {
       result.inComplexType = true;
              
       if ( result.funcObj != undefined &amp;&amp; result.funcObj != null )
       {
         result.funcObj.hasComplexContent = true;
       }
     }
     else
     if ( elemName == "simpleType" )
     {
       result.inSimpleType = true;
       
       if ( result.funcObj != undefined )
       {        
         result.funcObj.hasSimpleContent = true;
         result.funcObj.hasComplexContent = false;
       }
     }

     var nameAttr = xmlNode.getAttributeNode("name");
     var refAttr  = xmlNode.getAttributeNode("ref");
     
     // See if ref 
     
     if ( refAttr != null )
     {
       if ( result.funcObj != undefined )
       {
         result.funcObj.members.push( xmlNode );
       }
     }
     else
     // See if anonymous type

     if ( nameAttr == null )
     {
       result.inAnonymousType = true;
     }
     else  // have a named element, complexType, or simpleType
     {
       // Try to get name, type, default attributes

       var varName          = nameAttr.getNodeValue();
       
       var varTypeAttr      = xmlNode.getAttributeNode("type");
       
       var varDefaultAttr   = xmlNode.getAttributeNode("default");
       
 
       if ( varTypeAttr != null )
       {      
         // If the type is an XMLSchema built-in type, we need to make a type for it if we havent already
         // because we need a container for the value and for the "xsi:type" attribute
         // then we need to change the type of the xmlNode to reference that type
         
         var typeValue = varTypeAttr.getNodeValue();
         var typeName  = typeValue;
         
          
         var isXSD = false;
         
         if ( isXMLSchemaType( typeValue, result ) )
         {
            isXSD = true;
            
            var hasPrefix = ( typeValue.indexOf( ":" ) &gt; 0 );
            
            if ( hasPrefix )
            {
              typeName = transformName( typeValue );
            }
            else {
              typeName = "xs_" + typeValue;
            }
            
            if ( pendingObjects[ typeName ] == undefined ) 
            {
              makeXMLSchemaTypeFunction( typeName, typeValue, result ); 
            }
                                
            //xmlNode.setAttributeValue( "type", typeName );  // change type from e.g. xsd:int to xsd_int container type   
         }
         
         if ( result.funcObj != undefined )
         {    
           typeName = transformName( stripNSPrefix(typeValue,result) );
                     
           if ( pendingObjects[ typeName ] != undefined &amp;&amp; pendingObjects[ typeName ].hasSimpleContent == false )
           {
             // named element or complexType of a known type, with non-simple content
             // make new type which is an instance of the indicated type, but whose xml name is the given name
             
             var newTypeName = result.funcObj.funcName + "_" + typeName;
             
             var newFuncObj = new functionObject( result, newTypeName, varName, 0 );
             
             newFuncObj.hasComplexContent = pendingObjects[ typeName ].hasComplexContent;
             
             copyMembers( newFuncObj,    pendingObjects[ typeName ] );
             copyAttributes( newFuncObj, pendingObjects[ typeName ] );
             
             newFuncObj.namespace = pendingObjects[ typeName ].namespace;
             newFuncObj.nsPrefix = pendingObjects[ typeName ].nsPrefix;
             newFuncObj.schemaNSPrefix = pendingObjects[ typeName ].schemaNSPrefix;
             newFuncObj.schemaNSisDefault = pendingObjects[ typeName ].schemaNSisDefault;
             newFuncObj.isExtendedType = pendingObjects[ typeName ].isExtendedType;
             newFuncObj.extensionBase = pendingObjects[ typeName ].extensionBase;
             
             pendingObjects[ newTypeName ] = newFuncObj;
             pendingObjects.length ++;
 
             xmlNode.setAttributeValue( "type", newTypeName ); // change to new type
           }
           
           result.funcObj.members.push( xmlNode );
         }
         else // result.funcObj is undefined
         {    
           // We have a NULL function object currently, and have encountered a named element WITH a type specification
           // This happens when a named element with type info appears immediately under &lt;schema&gt;
          
           if ( isXSD &amp;&amp; varName != typeName &amp;&amp; pendingObjects[ varName ] == undefined)
           {
              result.funcObj = makeXMLSchemaTypeFunction( varName, typeValue, result ); 
              result.funcObj.xmlName = varName;
           }
           else
           if ( ! isXSD )
           {
             typeName = transformName( stripNSPrefix(typeValue, result) );
           }
         
           // Make sure this is not a redundant element definition for a complexType we already saw...
           
           if ( varName == typeName &amp;&amp; pendingObjects[ typeName ] != undefined  )
           {                          
             //issueMsg( result,  "Element definition for " + varName + " is superfluous - ignoring" );            
           }
           else if ( pendingObjects[ varName ] == undefined )
           {              
             // create an object for varName
             result.funcObj = new functionObject( result, varName, varName, 0 );
             
             if ( result.inSimpleType )
             {             
               result.funcObj.hasSimpleContent = true;
             }
  
             var xmlNode = result.xmlDoc.createNode( 1, varName, "");

             addXmlSchemaTypeAttrs( result.funcObj, xmlNode, typeValue );
                        
             pendingObjects[ varName ] = result.funcObj;
             pendingObjects.length ++;
             
             if ( pendingObjects[ typeName ] != undefined &amp;&amp; pendingObjects[ typeName ].hasSimpleContent == false )
             {
               result.funcObj.hasComplexContent = true;
             
               copyMembers( result.funcObj,    pendingObjects[ typeName ] );
               copyAttributes( result.funcObj, pendingObjects[ typeName ] );
             }     
           }
         }  // result.funcObj is undefined
       }
       else // no type information, we are creating a type
       {
         var typeName;

         if ( result.funcObj != null )
         {
           // Need to give this member node a type attribute

           typeName = result.funcObj.funcName + "_" + varName;
         
           xmlNode.addAttribute( "type", typeName );
           
           result.funcObj.members.push( xmlNode );
         }
         else {
           typeName = nameAttr.getNodeValue();
         }    
                   
         result.funcObj = new functionObject( result, typeName, varName, result.nodeLevel );  
         
         if ( result.inComplexType )
         {            
            result.funcObj.hasComplexContent = true;  // set this flag right away, complexType elements can be empty 
         }        
                        
         pendingObjects[ typeName ] = result.funcObj;
         pendingObjects.length ++;
         
         // Capture any default value
           
         if ( varDefaultAttr != null )
         {
           xmlNode.addAttribute( "default", varDefaultAttr.getNodeValue() );
         }
       }
     }

  } // if element or complex type
  else
  if ( isServiceNode( xmlNode ) )
  {     
     var nameAttr = xmlNode.getAttributeNode("name");

     result.serviceName = transformName( nameAttr.getNodeValue() );
  }

  // process attributes
  
  var attr = xmlNode.getFirstAttribute();
  
  while( attr != null )
  {
    var attrName          = attr.getNodeName();
    var attrQualifiedName = attr.getQualifiedName();
    var attrPrefix        = attr.getPrefix();
    var attrValue         = attr.getNodeValue();

    if ( result.inSoapAddressElement &amp;&amp; attrName == "location" )
    {
       result.locationURI = attrValue;
    }

    if ( attrPrefix != null &amp;&amp; attrPrefix == "xmlns" )
    {
       // Save all namespaces in a global array, except for "soap", "xsi", "xsd"
       // which are basic ones which we hardcode values for
      
       if ( attrName != "soap" &amp;&amp; attrName != "xsi" &amp;&amp; attrName != "xsd" ) 
       {  
         // Add this namespace URI to the localNamespaceURIs array using the user-assigned prefix as a key.
         // The scope of the localNamespacesURI array is the current schema or wsdl file only, so if a prefix like "tns"
         // gets redefined from file to file, and thus overwrites an entry in this array, that's fine. 
         // Also, it is legal to have multiple different prefixes point to the same namespace URI,
         // so we make no effort to avoid duplicate URIs in the localNamespacesURI array
         
         localNamespaceURIs[ attrName ] = attrValue;
               
         // Now update the global namespaceURIs array. For this one, make sure we don't have this namespace already
         // We want one entry per namespace in this array, and we also assign our own prefix
 
         var alreadyHaveNS = false;

         var ns;         
         for ( ns in globalNamespaceURIs )
         {                    
           if ( globalNamespaceURIs[ns] === attrValue )
           {
             alreadyHaveNS = true;
           }
         }
 
         if ( ! alreadyHaveNS )
         {
           var nsPref = 
           globalNamespacePrefixes[ attrValue ] = "ns" + globalNamespaceCounter++;
           globalNamespaceURIs    [ nsPref  ] = attrValue;
         }
       }  
       
       // Capture a few user-assigned file scope ns prefixes

       if ( attrValue == "http://schemas.xmlsoap.org/wsdl/" )
       {
         result.wsdlNSPrefix = attrName;
       }     

       if ( attrValue == "http://schemas.xmlsoap.org/wsdl/soap/" )
       {
         result.soapNSPrefix = attrName;
       }

       if ( attrValue == "http://www.w3.org/2000/10/XMLSchema" 
         || attrValue == "http://www.w3.org/2001/XMLSchema")
       {
         result.schemaNSPrefix = schemaNSPrefix = attrName;   // capture in global var too
         
         if ( isDefinitionsNode( xmlNode ) )  // if ( result.inDefinitionsNode )
         {
           result.WSDLXMLSchemaNSPrefix = schemaNSPrefix;
         }
       }
       
       if ( attrValue == "http://schemas.xmlsoap.org/soap/encoding/" )
       {
         result.soapencNSPrefix = attrName;
       }    
    }
    else
    {
      if ( attrName == "xmlns" &amp;&amp; attrValue == "http://www.w3.org/2001/XMLSchema" )
      {        
        result.schemaNSisDefault = true;
        
        if ( isDefinitionsNode( xmlNode ) )
        {
          result.WSDLXMLSchemaNSisDefault = result.schemaNSisDefault;
        }
      }
    }
    
    attr = xmlNode.getNextAttribute();
  }

  // process children

  var child = xmlNode.getFirstChildElement();
 
  while( child != null )
  {
     funcObjStack[ result.nodeLevel ] = result.funcObj;

     visitNode( child, result );

     result.funcObj = funcObjStack[ result.nodeLevel ];
     
     child = child.getNextSiblingElement();
  }

  // Turn off flags as we pop back up to various types of nodes

  //result.inDefinitionsNode = false;
 
  if ( isTypesNode( xmlNode ) )
  {
     result.inTypesElement = false;
  }
  else
  if ( isXMLSchemaNode( xmlNode, result.schemaNSPrefix ) )
  {
    issueMsg( result, "Done with schema: " + result.targetNSURI );
    
    result.schemaNSPrefix    = result.WSDLXMLSchemaNSPrefix;
    result.schemaNSisDefault = result.WSDLXMLSchemaNSisDefault;
  }
  else
  if ( isMessageNode( xmlNode ) )
  {
     result.inMessageElement = false;

     result.messageName = null;
     result.partName = null;
  }
  else
  if ( isPortTypeNode( xmlNode ) )
  {
     result.inPortTypeElement = false;
  }
  else
  if ( isBindingNode( xmlNode ) )
  {
     result.inBindingElement = false;
     result.inSOAPBinding = false;
  }
  else
  if ( isSOAPBindingNode( xmlNode,result) ) // soap:binding element within wsdl:binding
  {
    // result.transportHTTP = false;  // No, keep this on; we want to see it a little later
  }
  else
  if ( result.inPortTypeElement &amp;&amp; elemName == "operation" )
  {
     result.inOperationElement = false;
     result.operationName = null;
  }
  else
  // See if this is the soap:address element

  if ( elemPrefix == result.soapNSPrefix &amp;&amp; elemName == "address" )
  {
    result.inSoapAddressElement = false;
  }
  else 
  if ( elemName == "sequence" )
  {
    result.inSequence = false;
  }
  else
  if ( elemName == "choice" )
  {
    result.inChoice = false;
  }
  else 
  if ( elemName == "element" )
  {
    result.inElement = false;
  }
  else
  if ( elemName == "complexType" )
  {
     result.inComplexType = false;
  }
  else
  if ( elemName == "simpleType" )
  {
     result.inSimpleType = false;
  }
  
  result.nodeLevel --;
}

// Emit SOAP Fault object

function emitSOAPFaultObject( result )
{
  var funcObj = new functionObject( result, "soap:Fault", "Fault", 0 );
  
  var stringType        =  "xsd:string"; // result.schemaNSPrefix + ":string";
  var mangledStringType =  "xsd_string"; // result.schemaNSPrefix + "_string";
  
  funcObj.hasComplexContent = true;
                        
  startFunction( funcObj, result );  
 
  emitMemberVariable( funcObj, "faultcode",   mangledStringType, null, false, undefined, result );
  emitMemberVariable( funcObj, "faultstring", mangledStringType, null, false, undefined, result );
  emitMemberVariable( funcObj, "faultactor",  mangledStringType, null, false, undefined, result );
  emitMemberVariable( funcObj, "detail",      "XML",             null, false, undefined, result );
 
  closeFunction( result );
  
  // Make sure we actually have a function for xml schema string type..
  
  if ( pendingObjects[ mangledStringType ] == undefined )
  {
     makeXMLSchemaTypeFunction( mangledStringType, stringType, result );
  }
}

// Emit SOAP Header object

function emitSOAPHeaderObject( result )
{
  var funcObj = new functionObject( result, "soap:Header", "Header", 0 );
  
  funcObj.hasComplexContent = true;
                        
  startFunction( funcObj, result );  
  closeFunction( result );
}

// Emit SOAP Envelope and SOAP Body objects

function emitSOAPBodyObject( result )
{
  var funcObj = new functionObject( result, "soap:Body", "Body", 0 );

  funcObj.hasComplexContent = true;
                        
  startFunction( funcObj, result );

  if ( result.encoded )
  {
    emitAttribute2( "soap:encodingStyle", result.encodingStyle, "xsd:string", result );
  } 
  
  closeFunction( result );
}

function emitSOAPEnvelopeObject( result )
{
  var funcObj = new functionObject( result, "soap:Envelope", "Envelope", 0 );

  funcObj.hasComplexContent = true;
                        
  startFunction( funcObj, result );

  // Add standard namespaces
  
  globalNamespacePrefixes[ "http://schemas.xmlsoap.org/soap/envelope/" ] = "soap";
  globalNamespacePrefixes[ "http://www.w3.org/2001/XMLSchema-instance" ] = "xsi";
  globalNamespacePrefixes[ "http://www.w3.org/2001/XMLSchema"          ] = "xsd";
  
  globalNamespaceURIs    [ "soap" ] = "http://schemas.xmlsoap.org/soap/envelope/";
  globalNamespaceURIs    [ "xsi"  ] = "http://www.w3.org/2001/XMLSchema-instance";
  globalNamespaceURIs    [ "xsd"  ] = "http://www.w3.org/2001/XMLSchema";  
   
  // emit all the namespace declarations into the soap:Envelope object
  var ns;    
  for ( ns in globalNamespacePrefixes )
  {
    if( typeof globalNamespacePrefixes[ns] === 'string' ) {    
       emitAttribute2( "xmlns:" + globalNamespacePrefixes[ns], ns, "string", result );
    }
  }
		                    
  emitMemberVariable( funcObj, "soap:Body", transformName("soap:Body"), null, false, undefined, result );

  closeFunction( result );
}
/// End ----------------


function isXmlNodeType( obj ) {
    return !!( obj &amp;&amp; obj.getQualifiedName &amp;&amp; typeof obj.getQualifiedName === 'function'
                 &amp;&amp; obj.getNodeType &amp;&amp; typeof obj.getNodeType === 'function' );
}



</script>
    <package type="string">SOAP</package>
    <sysmodtime type="dateTime">05/04/19 19:36:12</sysmodtime>
    <sysmoduser type="string">zhangqi</sysmoduser>
    <sysmodcount type="decimal">66</sysmodcount>
    <prgnsystem NullValue="1" type="boolean"/>
    <sysrestricted type="boolean">true</sysrestricted>
  </record>
</recordset>
