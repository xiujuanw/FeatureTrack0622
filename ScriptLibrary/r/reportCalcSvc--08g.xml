<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="ScriptLibrary">
  <record id="name=&quot;reportCalcSvc&quot;" recordid="reportCalcSvc">
    <name type="string">reportCalcSvc</name>
    <script type="string">var libCmn = lib.reportCmn;
var libRs = lib.ReportService;

var _val = funcs.val;
var _type = funcs.type;
var _tod = funcs.tod;
var _ = lib.Underscore.require();
var log = getLog("CalcChartSvc"); 

var setOpertor = lib.reportExport.setOpertor;
var loginAs = lib.reportExport.loginAs;

var ERR_TYPE_ERROR   = "3";
var ERR_TYPE_INFO    = "1";
var ERR_CALC_NO_DATA = 316;    // Cannot find pre-calculated data for current chart

function toJSON(obj) {
  return JSON.stringify( obj );
}

function jsonParse(obj) {
  return JSON.parse(obj);
}

function initLog(logLevel)
{
  log.setLevel(logLevel);
}

//initLog("debug");

function isReportExists( inbox_id )
{
  var f = new SCFile('inbox', SCFILE_READONLY);
  f.setFields(["inbox.id"]);

  var rc = f.doSelect('inbox.id=' + inbox_id );

  return rc == RC_SUCCESS;
}

function getPendingCalcChartCnt()
{
  var f = new SCFile('calcchartdata', SCFILE_READONLY);
  f.setFields(["inbox.id"]);

  var now = new XMLDate(new Date());
  now = now.getSCDateTimeString();

  var q = ' (working = false or null(working) ) and (next.time &lt;= \'' + now + '\') ';
  var cnt = f.doCount(q);

  return cnt;
}

function calcCharts( log_level )
{
  if ( !libCmn.isReportingEnabled() ) {
    return;
  }

  if ( !log_level ) {
    log_level = "info";
  }
  log.setLevel(log_level);

  log.info("------- Calculating the charts ------");

  // 0. Mark all the WORKING tasks as CREATED, if some task cannot be completed in 1 iteration, then there should be something wrong, we need to processed from the beginning
  tasksReset();

  var scheduleOp = funcs.operator();
  var oldBG = vars['$G.bg'];

  // 1. Fetch 1 task marked as CREATED
  var f = new SCFile('calcchartdata');
  f.setOrderBy(["owner"], [SCFILE_ASC]);

  var now = new XMLDate(new Date());
  now = now.getSCDateTimeString();

  var q = ' (working = false or null(working) ) and (next.time &lt;= \'' + now + '\') ';

  var preOwner = "";
  if ( scheduleOp )
  {
    log.info("Current Operator: " + scheduleOp );
    preOwner = scheduleOp;
  }
  if (log.isDebugEnabled()) {
    log.debug("calcCharts query: " + q);
  }

  var dTmp;
  
  var cnt = 0;
  var rc = f.doSelect( q );
  while ( rc == RC_SUCCESS )
  {
    var inbox_id = f.inbox_id;
    var bExist = isReportExists( inbox_id );

    if ( bExist )
    {
      var bLocked = false;
      var lockname = inbox_id.toString() + "_precalc";
      try{
        // 2. Set the current.phase to PREPARING
        // 2.1 if failed, back to step 1
        var strCalculated = 'tod()&lt;"' + _val(f.next_time, 2) + '"';
        var bCalculated =  funcs.parse_evaluate(strCalculated, 2);

        if ( !bCalculated &amp;&amp;  Lock(lockname) == RC_SUCCESS )
        {
          bLocked = true;
          f.working = true;
          f.working_time = funcs.tod();
          rc = f.doUpdate();
        }
        else
        {
          rc = RC_MODIFIED;
        }

        if ( rc == RC_SUCCESS )
        {
          // 2.2 Switch to the timezone and login as owner of current operator
          var taskOwner = f.owner;
          if (taskOwner &amp;&amp; (preOwner !== taskOwner) )
          {
            log.info("Switching to operator: " + taskOwner + ", previous: " + preOwner);
            if (cnt &gt; 0) {
              setOpertor(scheduleOp);
            }

            // !!! Caution, MUST call setOperator resetsession, because in side of resetsession, it would reset the mandaten data using new operator name
            setOpertor( taskOwner );
            dTmp = new Datum();
            funcs.rtecall("resetsession", dTmp);

            loginAs(taskOwner);
            log.info("Operator context switch complete");

            preOwner = taskOwner;
          }

          // 3. Prepare data for the task
          rc = genCalcChart( f );
          if ( rc == RC_SUCCESS )
          {
            log.info( "Report generated: " + inbox_id + ", rc: " + rc );
            cnt++;
          }
          else{
            if ( rc == RC_MODIFIED ) {
              log.info( "Skip report: " + inbox_id + ", already generated by other worker" );
            }
            else {
              log.info( "Failed to generate report: " + inbox_id + ", rc: " + rc );
            }
          }

        } // doupdate

        if ( bLocked ) {
          Unlock(lockname);
        }
      }
      catch (e)
      {
        if ( bLocked ) {
          Unlock(lockname);
        }

        setOpertor( scheduleOp );
        dTmp = new Datum();
        funcs.rtecall("resetsession", dTmp);
        loginAs(scheduleOp);

        log.error("Calculate data failed for chart: " + f.inbox_id + ", error: " + e.message);
      }

    }
    else
    {
      // the inbox already get deleted in inbox file
      log.info( "Report skipped because it's not found in inbox file: " + inbox_id );
      f.doRemove();
    }

    rc = f.getNext();

    vars['$G.bg'] = oldBG;
  } // while

  if ( preOwner !== scheduleOp )
  {
    setOpertor( scheduleOp );
    dTmp = new Datum();
    funcs.rtecall("resetsession", dTmp);
    loginAs(scheduleOp);
  }

  log.info( "Calculated " + cnt + " tasks." );

  forceGC();
}

/**
 * Mark all the WORKING tasks as CREATED
 */
function tasksReset()
{
  var cnt = 0;
  var MAX_RETRY = 3;

  try {
    var f = new SCFile('calcchartdata');
    var rc = f.doSelect('working = true and ( (working.time &lt; tod() - \'00:30:00\') or ( null(working.time) ) ) ');

    while ( rc == RC_SUCCESS )
    {
      if ( f.retry_count &gt; MAX_RETRY )
      {
        f.succeed = false;
        f.working = false;
        f.data = "";
        f.gen_time = funcs.tod();
        f.working_time = funcs.tod();
        f.next_time = funcs.parse_evaluate('tod()+val("' + f.interval + '", 3)', 2);
      }
      else
      {
        f.retry_count++;
        f.working = false;
        f.next_time = funcs.tod();
      }

      f.doUpdate();

      rc = f.getNext();
      cnt++;
    }
    f.doClose();
  }
  catch (e)
  {
    log.error("Reset tasks failed, error: " + e.message);
  }

  if ( cnt &gt; 0 ) {
    log.info("Reset " + cnt + " task(s)");
  }
  else if (log.isDebugEnabled()){
    log.debug("Reset " + cnt + " task(s)");
  }
}

/**
 * Sync calc line charts in calcChartData file base the inbox file
 * 1. Delete the item in calcChartData if it's disabled in inbox file
 * 2. Add the item to calcChartData if not exists and not disabled
 *
 * 3. This function need to run with system.administrator role
 */
function syncCalcCharts()
{
  var ownLock = false;
  var lockname = "lock.syncCalcCharts";
  try
  {
    if ( Lock(lockname) == RC_SUCCESS )
    {
      ownLock = true;

      addCalcCharts();
      removeDisabledCalcItem();
      syncCalcChanges();
    }
  }
  catch( e )
  {
    log.info("Exception detected when syncCalcCharts: " + toJSON(e));
  }
  finally
  {
    if ( ownLock ) {
      Unlock(lockname);
    }
  }
}

function addCalcCharts()
{
  var q = 'SELECT inbox.id, inbox.manager, calcline.interval, sysmodcount FROM inbox WHERE (inbox.class="chart") and ';
  q += ' ( (chart.model="calc") or (chart.model="duration") ) and ( null(report.disabled) or report.disabled=false ) ';
  q += ' and not inbox.id isin ( SELECT distinct inbox.id from calcchartdata ) ';

  var fData = new SCFile('calcchartdata');

  var f = new SCFile('inbox', SCFILE_READONLY);
  var rc = f.doSelect(q);

  while ( rc == RC_SUCCESS )
  {
    createCalcChartItem( f.inbox_id, f['inbox.manager'], f['calcline.interval'], fData, f.sysmodcount );
    rc = f.getNext();
  }
}

function addCalcChart( inbox_id )
{
  var fData = new SCFile('calcchartdata');
  var f = new SCFile('inbox');
  var rc = f.doSelect('inbox.id = ' + inbox_id);

  if ( rc == RC_SUCCESS )
  {
    rc = createCalcChartItem( f.inbox_id, f['inbox.manager'], f['calcline.interval'], fData );
  }

  return rc;
}

function createCalcChartItem( inbox_id, owner, interval, f, modversion )
{
  var rc = RC_SUCCESS;

  // Lazy way to prevent the duplicate key error
  if ( !findCalcChartItem( inbox_id, f ) &amp;&amp; interval!=null &amp;&amp; interval!="" )
  {
    f.owner = owner;
    f.interval = interval;
    f.inbox_id = inbox_id;
    f.next_time = _tod();
    f.modversion = modversion;

    rc = f.doInsert();
  }

  return rc;
}

function findCalcChartItem( inbox_id, f )
{
  var rc = f.doSelect( 'inbox.id=' + inbox_id );
  return rc == RC_SUCCESS;
}

function deleteCalcChartItem( inbox_id )
{
  var f = new SCFile('calcchartdata');
  var rc = f.doSelect( 'inbox.id=' + inbox_id );
  if ( rc == RC_SUCCESS ) {
    f.doRemove();
  }
}

function removeDisabledCalcItem()
{
  var q = 'SELECT inbox.id FROM inbox WHERE (inbox.class="chart") and ( (chart.model="calc") or (chart.model="duration") ) and ( report.disabled=true ) ';
  q += ' and inbox.id isin ( SELECT distinct inbox.id from calcchartdata )';

  var f = new SCFile('inbox', SCFILE_READONLY);
  var rc = f.doSelect(q);

  while ( rc == RC_SUCCESS )
  {
    deleteCalcChartItem( f.inbox_id );
    rc = f.getNext();
  }
}

/**
 * Sync the changes in owner and interval to calcchartdata file
 */
function syncCalcChanges()
{
  var q = 'SELECT ta01.inbox.id, ta01.inbox.manager, ta01.calcline.interval, ta01.sysmodcount, ta01.chart.model as chartModel FROM inbox ta01, calcchartdata ta02 ' +
    ' WHERE (ta01.inbox.class="chart") and (ta01.inbox.id = ta02.inbox.id ) ' +
    ' and (ta01.sysmodcount &lt;&gt; ta02.modversion or null(ta02.modversion) )';

  var f = new SCFile('inbox', SCFILE_READONLY);
  var rc = f.doSelect(q);

  while ( rc == RC_SUCCESS )
  {
    if (log.isDebugEnabled()) {
      log.debug("syncCalcChanges, inbox.id: " + f['inbox.id'] + ", owner: " + f['inbox.manager']);
    }
    if ( f['chartModel'] != "calc" &amp;&amp; f['chartModel'] != 'duration' ) {
      deleteCalcChartItem( f.inbox_id );
    } else {
      if (f['calcline.interval']!=null &amp;&amp; f['calcline.interval']!="") {
        updateCalcItem( f.inbox_id, f['inbox.manager'], f['calcline.interval'], f.sysmodcount );
      } else {
        deleteCalcChartItem( f.inbox_id );
      }
    }
    rc = f.getNext();
  }
}

function updateCalcItem( inbox_id, owner, interval, modversion )
{
  var f = new SCFile('calcchartdata');
  var rc = f.doSelect( 'inbox.id=' + inbox_id );
  if ( rc == RC_SUCCESS )
  {
    f.owner = owner;
    f.interval = interval;
    f.next_time = _tod();
    f.modversion = modversion;

    rc = f.doUpdate();
  }
}

/**
 * Fetch result for specific report, which already calculated
 *
 * @param inbox_id
 * @param bRefresh
 * @param logger
 */
function fetchResult( inbox_id, bRefresh, logger )
{
  var q = 'inbox.id = ' + inbox_id;
  var f = new SCFile( 'calcchartdata', SCFILE_READONLY );
  var rc = f.doSelect(q);

  var bThrow = false;
  var result = f.data;
  if ( ( rc !== RC_SUCCESS ) || !result )
  {
    bThrow = true;
    result = libCmn.createReportServiceError( ERR_CALC_NO_DATA, ERR_TYPE_INFO, [ inbox_id ] );
  }

  if ( f.succeed == false )
  {
    // handle failed data
    bThrow = true;
    result = jsonParse( result );
  }

  // quick quit with an error object if there was something wrong
  if ( bThrow ) {
    throw result;
  }

  result = jsonParse( result );

  // Enable the drill-down for number-chart if the Current Operator is the owner
  if ( result &amp;&amp; result.meta &amp;&amp; (result.meta.chartModel === 'duration') )
  {
    var currOp = vars['$lo.operator'];
    if ( currOp ) {
      currOp = currOp.name;
    }

    if ( f.owner == currOp )
    {
      result.meta.source = "aggregate";
    }
    delete result.meta.chartModel;
  }
  
  var localizedInboxName = lib.localizeTable.getLocalizedInboxName(inbox_id);
  if (localizedInboxName != null) {
      result.meta.name = localizedInboxName;
  }

  return result;
}

function refreshCalc( inbox_id )
{
  var q = 'inbox.id = ' + inbox_id;
  var f = new SCFile( 'calcchartdata' );
  var rc = f.doSelect(q);

  if ( rc == RC_SUCCESS ) {
    refreshCalcChart( f );
  }
}

/**
 * Call by report designer to trigger the calculation of chart
 * The inbox might not exist in the calcchartdata file.
 *
 * @param inbox_id
 */
function runNow( inbox_id )
{
  var rc = addCalcChart(inbox_id);
  refreshCalc( inbox_id );
}

function refreshCalcChart( f )
{
  var nextDate = f['next.time'];
  var _now = _tod();
  if ( nextDate &gt; _now )
  {
    f['next.time'] = _now;
    var rc = f.doUpdate();
  }
}

function genCalcChart( f )
{
  var ret = genReport( f.inbox_id );

  if ( ret.errorCode &amp;&amp; ret.errorCode == 'R0052' )
  {
    var rc = f.doRemove();
    log.info( "Inbox: " + f.inbox_id + " not found, skip current task: " + rc );
    return ret.errorCode;
  }

  f.data = toJSON(ret);
  f.gen_time  = _tod();

  // !!!TODO!!! customize it?
  var interval = f.interval;
  if ( !interval ) {
    interval = "1:00:00";
  }

  f.next_time = funcs.parse_evaluate('tod()+val("' + interval + '", 3)', 2);
  f.interval  = interval;
  f.succeed = ( !ret.errorCode )? true : false;

  f.working = false;

  return f.doUpdate();
}

function deleteCalcChartDate( inbox_id )
{
  var f = new SCFile( 'calcchartdata' );
  var rc = f.doSelect('inbox.id=' + inbox_id);
  if ( rc == RC_SUCCESS ) {
    f.doRemove();
  }
}

function genReport( inbox_id )
{
  var ret={};

  try{
    ret = libRs.genGadgetData( inbox_id, false, true, true );
  }
  catch (e)
  {
    if ( !e.errorCode ) {
      e = createJsRuntimeError(e.message);
    }
    ret = e;
  }

  return ret;
}

function createJsRuntimeError(msg){
  return lib.RemoteJavascriptService.createError('0009', 'JsRuntimeError', msg);
}

///////////////////////////////////////////////

function getMaxCalcThread( )
{
  var maxThread = lib.settings.getSettingValue( "Report", "Export.thread.precalc" );
  return maxThread ? parseInt(maxThread, 10) : 1;
}

function getCurThreadCount()
{
  var nCalc = 0;
  var pid = system.sysinfo.ProcessID;
  var calcPrefix = "report.calccharts";

  var u;
  var allUsers = system.users;
  for ( u in allUsers )
  {
    var curUser = allUsers[u];
    var thisPid = curUser.processID;
    if ( thisPid &amp;&amp; thisPid.getNodeValue() === pid )
    {
      var threadName = curUser.name.getNodeValue();
      if ( threadName.substring(0, calcPrefix.length) === calcPrefix ) {
        nCalc++;
      }
    }
  }

  return nCalc;
}

/**
 * How many threads we still need to create, the limit is Export.thread.prepare and Export.thread.export
 */
function getRemainThreadCount( )
{
  var nCalc = getCurThreadCount();
  var nMax = getMaxCalcThread();

  var dt = new SCDatum();
  dt.setType(1);
  var nRemain = nMax - nCalc;
  dt = ( nRemain &gt;= 0 )? nRemain : 0;

  if ( nRemain &gt; 0 ) {
    log.info("Still need to create " + nRemain + " export threads ");
  }

  return dt;
}
</script>
    <package type="string">Reporting</package>
    <sysmodtime type="dateTime">06/15/21 00:48:48</sysmodtime>
    <sysmoduser type="string">falcon</sysmoduser>
    <sysmodcount type="decimal">0</sysmodcount>
    <prgnsystem NullValue="1" type="boolean"/>
    <sysrestricted NullValue="1" type="boolean"/>
  </record>
</recordset>
