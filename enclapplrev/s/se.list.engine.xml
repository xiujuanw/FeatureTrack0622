<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="enclapplrev">
  <record id="application.name=&quot;se.list.engine&quot;" recordid="se.list.engine">
    <application.name type="string">se.list.engine</application.name>
    <rev.array sctype="array">
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">05/14/17 19:24:18</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">update start panel and setup.thread.engine, support $G.de.view.thread</rev.desc>
        </rev.desc>
        <change.no type="decimal">139110</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">chunhua</rev.name>
        <rev.date type="dateTime">07/30/15 07:56:27</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">use frefresh to replace the wrong refresh interface</rev.desc>
        </rev.desc>
        <change.no type="decimal">125753</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">03/31/13 08:03:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">support use jscall to set the format name in state.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">03/30/10 17:46:43</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified the following panels:</rev.desc>
          <rev.desc sctype="string">* set.mult.yes - replaced expression:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (not null($L.dd.sort) and not same($L.dd.sort, {}) and not same($L.dd.sort, $L.sort)) then ($L.void=setsort($L.file, $L.dd.sort, $L.sort.type))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">with:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (not null($L.view) and not null(groupByFieldName in $L.view) and not same(groupByFieldName in $L.view, {})) then ($L.dd.sort=sortFieldName in $L.view;$L.gg.sort=groupByFieldName in $L.view;$L.sort.type={};$L.gg.sort.type={};for $L.i = 1 to lng(denull(sortFieldName in $L.view)) do (if ($L.i in sortType in $L.view)#"d" then ($L.i in $L.sort.type=1) else ($L.i in $L.sort.type=0));for $L.i = 1 to lng(denull(groupByFieldName in $L.view)) do (if ($L.i in groupSortType in $L.view)#"d" then ($L.i in $L.gg.sort.type=1) else ($L.i in $L.gg.sort.type=0));$L.void=setsort($L.file, $L.dd.sort, $L.sort.type, $L.gg.sort, $L.gg.sort.type);$L.void=rtecall("rfirst", $L.rc, $L.file)) else (if (not null($L.dd.sort) and not same($L.dd.sort, {}) and not same($L.dd.sort, $L.sort)) then ($L.void=setsort($L.file, $L.dd.sort, $L.sort.type)))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">This will ensure that grouping is preserved after a refresh.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">* setup.display - replaced expression:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (type($L.format)=2) then ($L.format=get.base.form.name(evaluate($L.format)))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">with:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (type($L.format)=2) then ($L.format=get.base.form.name(evaluate($L.format))) else ($L.format=get.base.form.name(name in $L.format))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">This will ensure that the QBE format retains its columns after a refresh.</rev.desc>
        </rev.desc>
        <change.no type="decimal">49156</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">07/02/07 08:15:27</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Pass the view to the display application.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/03/07 01:08:29</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Recompiled to fix broken parameters.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">05/23/07 00:16:27</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Pass view information to view engine and save inbox routine.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/30/07 20:32:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Recognize when views are passed in.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">11/25/06 21:52:20</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added support for an "refresh" $L.exit value that will refresh the list.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">11/15/06 20:01:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Recompile only.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ausman</rev.name>
        <rev.date type="dateTime">05/15/06 01:17:18</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Count was not working because we cleaned up $L.sql in the cc.search process record.  We know cleanup this variable later on the cleaup panel for se.list.engine, right before it returns to se.search.engine.  The cleanup is there so that queries dont get concatenated everytime you do searches again and again.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">acorvino</rev.name>
        <rev.date type="dateTime">04/27/06 05:10:07</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Honor stored QBE formats passed in</rev.desc>
        </rev.desc>
        <change.no type="decimal">33702</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">10/31/05 14:42:23</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">fixed parameter</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">10/31/05 14:37:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added special object type as a parameter</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/20/05 22:11:40</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified the way the common name (for display) is handled.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">08/17/04 20:51:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: db.mass.function</rev.desc>
          <rev.desc sctype="string">passed $L.object to the db.mass.functions application</rev.desc>
        </rev.desc>
        <change.no type="decimal">32597</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">09/18/02 01:52:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified to keep the sort order on refresh.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">10/27/01 21:29:12</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Same as below.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">10/27/01 17:15:26</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed a problem where the default qbe field in the formatcontrol record was being ignored.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">10/18/01 23:45:31</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed a problem where the list engine would thread to the view engine, but instead of returning it still displayed one record.  Also fixed a problem where it would try to display a thread without first getting the format control record.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">09/13/01 01:34:50</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed thready for record list.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">09/12/01 01:32:06</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed the threading for list -&gt; Edit option.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/06/01 02:16:29</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Perform a get.base.form.name on format so that correct format is displayed.</rev.desc>
        </rev.desc>
        <change.no type="decimal">4466</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">05/28/01 02:38:49</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added $L.messages to the parameters passed to processes.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">05/16/01 00:02:33</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will now properly handle both hard coded format names, as well as those that need to be evaluated.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">02/04/01 18:48:30</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed so it no longer fills in the default name for the qbe format in text mode.  This allows the fdisp panel to auto-generate the format if necessary.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">kasey</rev.name>
        <rev.date type="dateTime">02/04/01 16:17:26</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">In SC4, due to QBE now using the search engine, changed panel setup.display in se.list.engine application to nullsub the $L.format just in case the variable contains a format from fc's Views.</rev.desc>
        </rev.desc>
        <change.no type="decimal">3421</change.no>
      </rev.array>
    </rev.array>
    <descript sctype="array">
      <descript sctype="string">update start panel and setup.thread.engine, support $G.de.view.thread</descript>
      <descript sctype="string">use frefresh to replace the wrong refresh interface</descript>
      <descript sctype="string">support use jscall to set the format name in state.</descript>
      <descript sctype="string">Modified the following panels:</descript>
      <descript sctype="string">* set.mult.yes - replaced expression:</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (not null($L.dd.sort) and not same($L.dd.sort, {}) and not same($L.dd.sort, $L.sort)) then ($L.void=setsort($L.file, $L.dd.sort, $L.sort.type))</descript>
      <descript sctype="string"/>
      <descript sctype="string">with:</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (not null($L.view) and not null(groupByFieldName in $L.view) and not same(groupByFieldName in $L.view, {})) then ($L.dd.sort=sortFieldName in $L.view;$L.gg.sort=groupByFieldName in $L.view;$L.sort.type={};$L.gg.sort.type={};for $L.i = 1 to lng(denull(sortFieldName in $L.view)) do (if ($L.i in sortType in $L.view)#"d" then ($L.i in $L.sort.type=1) else ($L.i in $L.sort.type=0));for $L.i = 1 to lng(denull(groupByFieldName in $L.view)) do (if ($L.i in groupSortType in $L.view)#"d" then ($L.i in $L.gg.sort.type=1) else ($L.i in $L.gg.sort.type=0));$L.void=setsort($L.file, $L.dd.sort, $L.sort.type, $L.gg.sort, $L.gg.sort.type);$L.void=rtecall("rfirst", $L.rc, $L.file)) else (if (not null($L.dd.sort) and not same($L.dd.sort, {}) and not same($L.dd.sort, $L.sort)) then ($L.void=setsort($L.file, $L.dd.sort, $L.sort.type)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">This will ensure that grouping is preserved after a refresh.</descript>
      <descript sctype="string"/>
      <descript sctype="string">* setup.display - replaced expression:</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (type($L.format)=2) then ($L.format=get.base.form.name(evaluate($L.format)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">with:</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (type($L.format)=2) then ($L.format=get.base.form.name(evaluate($L.format))) else ($L.format=get.base.form.name(name in $L.format))</descript>
      <descript sctype="string"/>
      <descript sctype="string">This will ensure that the QBE format retains its columns after a refresh.</descript>
      <descript sctype="string">Pass the view to the display application.</descript>
      <descript sctype="string">Recompiled to fix broken parameters.</descript>
      <descript sctype="string">Pass view information to view engine and save inbox routine.</descript>
      <descript sctype="string">Recognize when views are passed in.</descript>
      <descript sctype="string">Added support for an "refresh" $L.exit value that will refresh the list.</descript>
      <descript sctype="string">Recompile only.</descript>
      <descript sctype="string">Count was not working because we cleaned up $L.sql in the cc.search process record.  We know cleanup this variable later on the cleaup panel for se.list.engine, right before it returns to se.search.engine.  The cleanup is there so that queries dont get concatenated everytime you do searches again and again.</descript>
      <descript sctype="string">Honor stored QBE formats passed in</descript>
      <descript sctype="string">fixed parameter</descript>
      <descript sctype="string">Added special object type as a parameter</descript>
      <descript sctype="string">Modified the way the common name (for display) is handled.</descript>
      <descript sctype="string">panel: db.mass.function</descript>
      <descript sctype="string">passed $L.object to the db.mass.functions application</descript>
      <descript sctype="string">Modified to keep the sort order on refresh.</descript>
      <descript sctype="string">Same as below.</descript>
      <descript sctype="string">Fixed a problem where the default qbe field in the formatcontrol record was being ignored.</descript>
      <descript sctype="string">Fixed a problem where the list engine would thread to the view engine, but instead of returning it still displayed one record.  Also fixed a problem where it would try to display a thread without first getting the format control record.</descript>
      <descript sctype="string">Fixed thready for record list.</descript>
      <descript sctype="string">Fixed the threading for list -&gt; Edit option.</descript>
      <descript sctype="string">Perform a get.base.form.name on format so that correct format is displayed.</descript>
      <descript sctype="string">Added $L.messages to the parameters passed to processes.</descript>
      <descript sctype="string">Will now properly handle both hard coded format names, as well as those that need to be evaluated.</descript>
      <descript sctype="string">Fixed so it no longer fills in the default name for the qbe format in text mode.  This allows the fdisp panel to auto-generate the format if necessary.</descript>
      <descript sctype="string">In SC4, due to QBE now using the search engine, changed panel setup.display in se.list.engine application to nullsub the $L.format just in case the variable contains a format from fc's Views.</descript>
    </descript>
    <release type="string">A9901</release>
    <sysmodcount type="decimal">1</sysmodcount>
    <sysmoduser type="string">zhangqi</sysmoduser>
    <sysmodtime type="dateTime">05/14/17 19:24:42</sysmodtime>
  </record>
</recordset>
