<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="enclapplrev">
  <record id="application.name=&quot;sla.set.current.state&quot;" recordid="sla.set.current.state">
    <application.name type="string">sla.set.current.state</application.name>
    <rev.array sctype="array">
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">07/02/17 18:58:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">sla slamodulecontrol should support End Time Field set to downtime.endAdd default value for start/end times</rev.desc>
        </rev.desc>
        <change.no type="decimal">132870</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">dengxin</rev.name>
        <rev.date type="dateTime">05/08/14 01:52:19</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel set.add</rev.desc>
          <rev.desc sctype="string">Change codes back from 98846 fix to reduce the impact of opening time calculation.</rev.desc>
        </rev.desc>
        <change.no type="decimal">108730</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">dengxin</rev.name>
        <rev.date type="dateTime">08/25/13 15:31:17</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">RAD: sla.set.current.state Panel: set.add</rev.desc>
          <rev.desc sctype="string">It will always use 1 in status.progression in $L.control, so when unchckeing "use phases", it will add the first phase in response state progression of slamodulecontrol.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Change</rev.desc>
          <rev.desc sctype="string">1 in 1 in state.change in $L.active=1 in status.progression in $L.control</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">1 in 1 in state.change in $L.active=nullsub(1 in 1 in state.change in $L.active, $L.status.field in $L.file)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.new.state=nullsub($L.new.state, $L.status.field in $L.file)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">1 in 1 in state.change in $L.active=nullsub($L.new.state, 1 in status.progression in $L.control)</rev.desc>
        </rev.desc>
        <change.no type="decimal">98846</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">05/07/07 14:04:10</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added processing to support slamodulecontrol records that specify the SLA field as an array type (multiple SLAs).</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">08/29/06 05:47:25</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx I3172</rev.desc>
          <rev.desc sctype="string">On panel get.active.query, changed the select statement to acommodate for the fact that the svcCartItem table uses a numeric key (not a string):</rev.desc>
          <rev.desc sctype="string">if ($L.filename="svcCartItem") then ($L.active.query="foreign.filename=\""+$L.filename+"\" and foreign.key="+str($L.id)) else ($L.active.query="foreign.filename=\""+$L.filename+"\" and foreign.key=\""+$L.id+"\"")</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">02/09/06 03:30:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">On set.add panel, modified processing to ensure that 1 in 1 in state.change in $L.active gets populated (was previously NULL if phases were being used as defined by the slamodulecontrol record).</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">02/08/06 23:11:05</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">On set.add panel, modified last expression line to read:</rev.desc>
          <rev.desc sctype="string">1 in 1 in state.change in $L.active=nullsub($L.status.field in $L.file, 1 in status.progression in $L.control)</rev.desc>
          <rev.desc sctype="string">This allows the initial state on a new slaactive rec to be set based on the status field value of the record vs. the 1st response progression state, which could be NULL if phases are being used.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
    </rev.array>
    <descript sctype="array">
      <descript sctype="string">sla slamodulecontrol should support End Time Field set to downtime.endAdd default value for start/end times</descript>
      <descript sctype="string">Panel set.add</descript>
      <descript sctype="string">Change codes back from 98846 fix to reduce the impact of openint time calculation.</descript>
      <descript sctype="string">RAD: sla.set.current.state Panel: set.add</descript>
      <descript sctype="string">It will always use 1 in status.progression in $L.control, so when unchckeing "use phases", it will add the first phase in response state progression of slamodulecontrol.</descript>
      <descript sctype="string"/>
      <descript sctype="string">Change</descript>
      <descript sctype="string">1 in 1 in state.change in $L.active=1 in status.progression in $L.control</descript>
      <descript sctype="string"/>
      <descript sctype="string">1 in 1 in state.change in $L.active=nullsub(1 in 1 in state.change in $L.active, $L.status.field in $L.file)</descript>
      <descript sctype="string"/>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.new.state=nullsub($L.new.state, $L.status.field in $L.file)</descript>
      <descript sctype="string"/>
      <descript sctype="string">1 in 1 in state.change in $L.active=nullsub($L.new.state, 1 in status.progression in $L.control)</descript>
      <descript sctype="string">Added processing to support slamodulecontrol records that specify the SLA field as an array type (multiple SLAs).</descript>
      <descript sctype="string">devtx I3172</descript>
      <descript sctype="string">On panel get.active.query, changed the select statement to acommodate for the fact that the svcCartItem table uses a numeric key (not a string):</descript>
      <descript sctype="string">if ($L.filename="svcCartItem") then ($L.active.query="foreign.filename=\""+$L.filename+"\" and foreign.key="+str($L.id)) else ($L.active.query="foreign.filename=\""+$L.filename+"\" and foreign.key=\""+$L.id+"\"")</descript>
      <descript sctype="string">On set.add panel, modified processing to ensure that 1 in 1 in state.change in $L.active gets populated (was previously NULL if phases were being used as defined by the slamodulecontrol record).</descript>
      <descript sctype="string">On set.add panel, modified last expression line to read:</descript>
      <descript sctype="string">1 in 1 in state.change in $L.active=nullsub($L.status.field in $L.file, 1 in status.progression in $L.control)</descript>
      <descript sctype="string">This allows the initial state on a new slaactive rec to be set based on the status field value of the record vs. the 1st response progression state, which could be NULL if phases are being used.</descript>
    </descript>
    <release type="string">SC6.2</release>
    <sysmodcount type="decimal">7</sysmodcount>
    <sysmoduser type="string">falcon</sysmoduser>
    <sysmodtime type="dateTime">07/02/17 18:59:00</sysmodtime>
  </record>
</recordset>
