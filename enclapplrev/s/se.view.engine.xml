<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="enclapplrev">
  <record id="application.name=&quot;se.view.engine&quot;" recordid="se.view.engine">
    <application.name type="string">se.view.engine</application.name>
    <rev.array sctype="array">
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">03/15/21 20:07:58</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">update panel after.process, improve comments</rev.desc>
        </rev.desc>
        <change.no type="decimal">1181631</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhiqiang.jiang</rev.name>
        <rev.date type="dateTime">10/11/19 12:22:02</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: check.base.exit.</rev.desc>
          <rev.desc sctype="string">panel:check.base.exit.1</rev.desc>
          <rev.desc sctype="string">Add a branch for background schedule to avoid dead loops.</rev.desc>
        </rev.desc>
        <change.no type="decimal">156129</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">09/24/19 13:41:43</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">update panel setup.tableAccess, change code from</rev.desc>
          <rev.desc sctype="string">if $L.soap then ($L.file.temp=$L.file.save)</rev.desc>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string">if ($L.soap and $L.mode="update") then ($L.file.temp=$L.file.save)</rev.desc>
        </rev.desc>
        <change.no type="decimal">155004</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">04/28/19 05:14:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel: check.get.phase</rev.desc>
          <rev.desc sctype="string">Fix the phase when the phase is WorkflowPhase.</rev.desc>
        </rev.desc>
        <change.no type="decimal">153353</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">huangzhi</rev.name>
        <rev.date type="dateTime">04/11/19 02:11:36</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">For joined ci types</rev.desc>
          <rev.desc sctype="string">Panel: setup.vars</rev.desc>
          <rev.desc sctype="string">CI which type is joined workflow phase is not correct.</rev.desc>
          <rev.desc sctype="string">Panel: duplicate.record</rev.desc>
          <rev.desc sctype="string">Set $L.file back to $L.list when do add action.</rev.desc>
          <rev.desc sctype="string">Panel: exit.normal</rev.desc>
          <rev.desc sctype="string">when setback is true return $L.list.temp.</rev.desc>
        </rev.desc>
        <change.no type="decimal">153157</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">03/26/19 06:28:43</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel: change.wfPhase</rev.desc>
          <rev.desc sctype="string">So in RAD se.view.engine, panel change.wfPhase, it should check the phase.file.name, if it is still using WorkflowPhase, just assign $L.wfPhase to $L.phase instead of query again.</rev.desc>
        </rev.desc>
        <change.no type="decimal">153353</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">01/12/19 02:06:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add panel reset.tableAccess.after.save, reset table access in lock mode</rev.desc>
        </rev.desc>
        <change.no type="decimal">151811</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhouanqing</rev.name>
        <rev.date type="dateTime">11/13/18 20:07:22</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">The change task category list on dynamic search page are hard code strings.</rev.desc>
          <rev.desc sctype="string">Make the title localized</rev.desc>
        </rev.desc>
        <change.no type="decimal">136625</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">03/26/18 03:34:10</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">delete panel reset.tableAccess, update panel setup.tableAccess to improve webservice tableAccess</rev.desc>
        </rev.desc>
        <change.no type="decimal">146870</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">yang,yechao</rev.name>
        <rev.date type="dateTime">03/17/18 19:31:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Transition not tracked in timeDuration4request</rev.desc>
        </rev.desc>
        <change.no type="decimal">144314</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhouanqing</rev.name>
        <rev.date type="dateTime">10/21/17 14:29:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Add a button to refresh the record and its phase of workflow</rev.desc>
        </rev.desc>
        <change.no type="decimal">136976</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhouanqing</rev.name>
        <rev.date type="dateTime">10/15/17 09:03:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Copy Record Option in Change Management Saves the new Change Automatically</rev.desc>
        </rev.desc>
        <change.no type="decimal">142919</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">05/12/17 01:22:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">update start panel, support $G.de.view.thread</rev.desc>
        </rev.desc>
        <change.no type="decimal">139110</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">12/24/16 01:27:23</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add panel reset.tableAccess</rev.desc>
        </rev.desc>
        <change.no type="decimal">137676</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhouf</rev.name>
        <rev.date type="dateTime">11/05/16 13:05:23</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel:post.display</rev.desc>
          <rev.desc sctype="string">Line 10:</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull(watch.variables in $L.object)) do (if ($L.i in watch.variables in $L.object)#"$" then if (not  (null(evaluate(parse($L.i in watch.variables in $L.object, 2))))) then ($L.same=false))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Copied to panel:after.process</rev.desc>
          <rev.desc sctype="string">Line 10:</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull(watch.variables in $L.object)) do (if ($L.i in watch.variables in $L.object)#"$" then if (not  (null(evaluate(parse($L.i in watch.variables in $L.object, 2))))) then ($L.same=false))</rev.desc>
        </rev.desc>
        <change.no type="decimal">55406</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">04/30/16 04:16:30</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Against file.save to check folder rights.</rev.desc>
        </rev.desc>
        <change.no type="decimal">131553</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhanzhen</rev.name>
        <rev.date type="dateTime">03/11/16 18:44:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Security role doesn't work correctly for some scenario when the Update right is "When Assigned to workgroup"</rev.desc>
        </rev.desc>
        <change.no type="decimal">132073</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">chunhua</rev.name>
        <rev.date type="dateTime">08/01/15 13:33:30</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">User could not switch CI ticket after refresh the list</rev.desc>
          <rev.desc sctype="string">change the frefresh parameter from $L.file to $L.list</rev.desc>
        </rev.desc>
        <change.no type="decimal">126932</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">07/26/15 14:54:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">update panel no.bg.auth, change msg to:</rev.desc>
          <rev.desc sctype="string">$L.no.auth.msg=scmsg(15, "doceng", {operator(), filename($L.file), $L.action})</rev.desc>
        </rev.desc>
        <change.no type="decimal">126534</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">07/06/15 10:59:57</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">apps regression issue in non-pd:</rev.desc>
          <rev.desc sctype="string">rootcause analysis:</rev.desc>
          <rev.desc sctype="string">1. when close incident, the changed $L.file didn`t update to db, and sitll in memory (via process "im.set.close")</rev.desc>
          <rev.desc sctype="string">2. $L.exit="closestate"</rev.desc>
          <rev.desc sctype="string">3. se.view.engine@set.close.mode -&gt; check.get.save.copy.bg -&gt; get.save.copy.bg (retieve $L.file.save from db)</rev.desc>
          <rev.desc sctype="string">4. then frontend clicks save</rev.desc>
          <rev.desc sctype="string">5. merge happens, but $L.file.save was refreshed, merge action fails.</rev.desc>
        </rev.desc>
        <change.no type="decimal">125174</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">chunhua.li</rev.name>
        <rev.date type="dateTime">07/06/15 23:31:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E125371 Indexing into a unknown type datum which is not a compound data type (Ruleset.run,run.javascript)</rev.desc>
          <rev.desc sctype="string">remove the wrong calling setsort after call frefresh</rev.desc>
        </rev.desc>
        <change.no type="decimal">125371</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">huanghao</rev.name>
        <rev.date type="dateTime">07/02/15 04:23:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">se.view,engine should process $L.exit value ~= changed or merge to avoid exit.normal at panel check.bg</rev.desc>
        </rev.desc>
        <change.no type="decimal">125083</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hanrui</rev.name>
        <rev.date type="dateTime">06/27/15 04:22:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E124646, The invalide value of a ci field is not cleared when you cancel the current thread</rev.desc>
          <rev.desc sctype="string">Modified the panel check.unlock.object by adding expression of $L.void=display.value.copy($L.file, $L.file.save) to make display value clean</rev.desc>
        </rev.desc>
        <change.no type="decimal">124646</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">06/19/15 11:24:51</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E124501, approval in current phase is not triggered when auto transition move to next phase when optimize save enabled.</rev.desc>
        </rev.desc>
        <change.no type="decimal">124501</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhanzhen</rev.name>
        <rev.date type="dateTime">06/06/15 22:35:57</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E123449, CI update value is not displayed after change device type.</rev.desc>
        </rev.desc>
        <change.no type="decimal">123449</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">05/30/15 09:23:07</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E123403, The page return to the list from qbe when fail to save&amp;exit for NONPD</rev.desc>
        </rev.desc>
        <change.no type="decimal">123403</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">05/28/15 11:25:45</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E123798, $L.phase value is incorrect on display when add incident but failed validation on default transition.</rev.desc>
        </rev.desc>
        <change.no type="decimal">123798</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">05/22/15 22:27:10</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E123162, search ticket from foreground, oldrecord phase and field value is null on init state.</rev.desc>
        </rev.desc>
        <change.no type="decimal">123162</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">05/21/15 21:06:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E123587, $L.wfPhase and $L.wfPhase.save are incorrect if enable optimize save for auto-transition.</rev.desc>
        </rev.desc>
        <change.no type="decimal">123587</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">05/20/15 21:13:49</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E123584, object varaiable cannot be shared between each rule states</rev.desc>
        </rev.desc>
        <change.no type="decimal">123584</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">05/15/15 21:53:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E122997, [Performance Improvement] enhance the rule type "validate against table", to ignore the validation if the value is not changed</rev.desc>
          <rev.desc sctype="string">-- make sure the $L.file.save is not the same as $L.file while adding the record from backend.</rev.desc>
        </rev.desc>
        <change.no type="decimal">122997</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">05/15/15 15:31:56</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E123011, In the PD wrapper migrated workflow, directly put the workflow subform into the non-PD forms does not work.</rev.desc>
          <rev.desc sctype="string">Make sure the display rules are executed after us.find.</rev.desc>
        </rev.desc>
        <change.no type="decimal">123011</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">05/08/15 15:27:43</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">[Performance Improvement] merge 2 save into 1 save for auto-transition</rev.desc>
        </rev.desc>
        <change.no type="decimal">123015</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hanrui</rev.name>
        <rev.date type="dateTime">04/18/15 04:29:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">When doing "refresh" action, calling frefresh RTE functions instead of select function</rev.desc>
        </rev.desc>
        <change.no type="decimal">121853</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hanrui</rev.name>
        <rev.date type="dateTime">04/02/15 00:48:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">CI logical.name value is not in creating CI response. Adde one line in panel of exit.normal</rev.desc>
          <rev.desc sctype="string">if ($L.action="add" and $L.soap="true") then ($INTO.LIST=$L.file)</rev.desc>
        </rev.desc>
        <change.no type="decimal">122031</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">03/17/15 21:59:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">support PD wrapper to make sure the ruleset on generated workflow working.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">02/16/15 13:11:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Unrecoverable error occurs when click back on solution matching window which is using the generated workflow</rev.desc>
        </rev.desc>
        <change.no type="decimal">120719</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">01/15/15 06:03:51</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">support legacy workflow options to enahnce for wrapper PD</rev.desc>
        </rev.desc>
        <change.no type="decimal">104048</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">12/13/14 21:46:58</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">fix the issue that the format level fc is not invoked if format is the same as file name and the record has workflow</rev.desc>
        </rev.desc>
        <change.no type="decimal">118950</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhenqing</rev.name>
        <rev.date type="dateTime">11/17/14 14:53:45</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">SM 9.33+PDCP3: $L.phase variable is not available in "On display" stage</rev.desc>
        </rev.desc>
        <change.no type="decimal">117766</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">11/02/14 09:25:30</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">use setvariables and getvariables to avoid too many parse/evaluate call which cause performance issue.</rev.desc>
        </rev.desc>
        <change.no type="decimal">118024</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">10/14/14 08:32:55</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">update panel: run.display.rules.1,run.event.rules,run.init.rules</rev.desc>
          <rev.desc sctype="string">change jump out exit to "decide.unlock"</rev.desc>
        </rev.desc>
        <change.no type="decimal">117461</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">10/08/14 03:47:02</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Interaction - Interaction shouldn't be locked after jump to itil record from interaction</rev.desc>
        </rev.desc>
        <change.no type="decimal">112866</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">10/08/14 01:10:59</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Page hangs after invoking the save button of a PD request form.</rev.desc>
        </rev.desc>
        <change.no type="decimal">117098</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">10/01/14 00:45:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Workflow Engine - Cannot auto move multiple phases at one time from webservice.</rev.desc>
        </rev.desc>
        <change.no type="decimal">116722</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">08/12/14 21:21:56</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Issue for "save record prior to transition"</rev.desc>
        </rev.desc>
        <change.no type="decimal">114290</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">08/10/14 12:07:32</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Change Problem Category on Categorization phase, 'Problem record updated' are print twice.</rev.desc>
        </rev.desc>
        <change.no type="decimal">113076</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">08/09/14 10:28:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">The scheduled report schedule can't be edited after click submited for Re-Planning</rev.desc>
          <rev.desc sctype="string">-- fix the issue that the init process is not run after changing the phase manually if "Lock on display" in object is set to true.</rev.desc>
        </rev.desc>
        <change.no type="decimal">114030</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">07/20/14 11:29:05</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">support CurrentWFPhase and SaveWFPhase in condition editor.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">07/19/14 22:45:11</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">support table level rulesets/actions</rev.desc>
        </rev.desc>
        <change.no type="decimal">100940</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">07/15/14 20:47:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add a new property "mtRunSaveBefore" in manualTransion</rev.desc>
        </rev.desc>
        <change.no type="decimal">95960</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">07/15/14 04:37:33</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">fix an issue that the backend transition should not save the record first at from phase.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">07/14/14 19:27:10</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">fix a regress that the display rules are not executed if the $L.bg.action is null.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">07/06/14 15:10:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">support conditional display form</rev.desc>
        </rev.desc>
        <change.no type="decimal">92733</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">06/20/14 10:45:55</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">save the record first before manually moving phase</rev.desc>
        </rev.desc>
        <change.no type="decimal">95960</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">06/07/14 05:38:49</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add workflow level on-enter and on-exit</rev.desc>
        </rev.desc>
        <change.no type="decimal">105428</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">06/03/14 05:29:08</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Rulesets run more times than expected</rev.desc>
        </rev.desc>
        <change.no type="decimal">108127</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">05/05/14 15:47:02</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Format for record is incorrect when stop on auto transition then do save.</rev.desc>
        </rev.desc>
        <change.no type="decimal">108674</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">04/05/14 17:19:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Can't create incident via web service if category not specified.</rev.desc>
          <rev.desc sctype="string">Change the logic to make sure the WSDL expression is evaluated before getting category.</rev.desc>
        </rev.desc>
        <change.no type="decimal">99936</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">03/22/14 08:55:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">treat as true if the backend transition condition is not set.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">03/15/14 08:24:06</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add btAction for backend transition configuration.</rev.desc>
        </rev.desc>
        <change.no type="decimal">95730</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">02/28/14 19:58:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">90568 and 90567, to support the cross table fileds and user option in conditiion editor.</rev.desc>
        </rev.desc>
        <change.no type="decimal">90568</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">01/16/14 04:09:59</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">set new parameter value to "exit.normal" in 3 Ruleset.runMultiple panels.</rev.desc>
        </rev.desc>
        <change.no type="decimal">102033</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">dengxin</rev.name>
        <rev.date type="dateTime">11/23/13 12:51:02</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">change panel decide.process.exit, add one more wfMode "save" in check condition, so that for bad validation, it will rollback the phase change.</rev.desc>
          <rev.desc sctype="string">if ($L.exit="bad.val" and $L.wfMode={"open", "save", "close"}) then ...</rev.desc>
        </rev.desc>
        <change.no type="decimal">99742</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/17/13 15:41:49</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">It is incorrect to clone the first or last interaction uses mode 'browse' instead of 'addclone' when click Previous or Next on the new record</rev.desc>
        </rev.desc>
        <change.no type="decimal">96804</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">05/08/13 23:40:04</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel:change.wfPhase</rev.desc>
          <rev.desc sctype="string">change to onexit and transition use the prev phase instead of next phase.</rev.desc>
        </rev.desc>
        <change.no type="decimal">95327</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">05/08/13 21:12:19</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel:change.wfPhase</rev.desc>
          <rev.desc sctype="string">issue is caused by array1 + denull(array2) will be null, use denull(nullsub(arrays),{})</rev.desc>
        </rev.desc>
        <change.no type="decimal">95341</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">04/20/13 13:18:19</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel:get.format</rev.desc>
          <rev.desc sctype="string">if master.fc is not set in object, don't use file based fc.</rev.desc>
          <rev.desc sctype="string">panel:check.get.phase,  set.workflow.flag</rev.desc>
          <rev.desc sctype="string">if $L.bg unable to find workflow, print error message.</rev.desc>
        </rev.desc>
        <change.no type="decimal">94253</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">03/28/13 07:33:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel:after.prompt.action,setup.tableAccess,check.get.parent,jump.back</rev.desc>
          <rev.desc sctype="string">If use don't have view right, avoid they open the record.</rev.desc>
        </rev.desc>
        <change.no type="decimal">92914</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">03/26/13 01:58:07</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: start</rev.desc>
          <rev.desc sctype="string">set no.auth message based on filename scmsg</rev.desc>
        </rev.desc>
        <change.no type="decimal">93145</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">03/20/13 23:30:49</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: start</rev.desc>
          <rev.desc sctype="string">set no.auth message based on filename</rev.desc>
        </rev.desc>
        <change.no type="decimal">93145</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">03/19/13 21:15:57</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Rad error is shown while save the incident after perform cancel.</rev.desc>
          <rev.desc sctype="string">if the $L.mode#"add", use action="add" instead.</rev.desc>
        </rev.desc>
        <change.no type="decimal">92461</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xingwen</rev.name>
        <rev.date type="dateTime">03/18/13 15:28:59</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E92700 Updated: "PDCP: In the last Phase of a Workflow PDCP seems to ignore the Transition."</rev.desc>
        </rev.desc>
        <change.no type="decimal">92700</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">03/15/13 15:30:08</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add backend event support empty to phase, so that only the transition rule will be executed.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">03/14/13 14:28:17</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel change.wfPhase,decide.after.event,display.decide,run.event.rules,set.bg.action,setup.runEvent</rev.desc>
          <rev.desc sctype="string">Add support for backend event.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">03/12/13 03:40:47</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">post.auto.transitions/run.display.rules/setup.init.rules</rev.desc>
          <rev.desc sctype="string">Change panle to</rev.desc>
          <rev.desc sctype="string">Change to auto transition initial and display rule.</rev.desc>
          <rev.desc sctype="string">Global add -&gt; Phase enter -&gt;Update Record -&gt; Global after successful add -&gt;  Global Initial  -&gt;  Phase Initial  -&gt;Global Display -&gt;Next Phase Display -&gt;  Phase  exit  -&gt; Transition-&gt;  Next Phase Enter -&gt;Update Record -&gt;Global Display -&gt;Next  Phase Display</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">03/07/13 12:54:12</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">change to logic to support exist -&gt; transition( manul, auto, defalut) -&gt; enter ruleset when phase changed.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">02/25/13 19:49:03</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add $bypass.bg.authcheck for backend by pass the security validation.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xiongjie</rev.name>
        <rev.date type="dateTime">01/13/13 22:18:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add groupby filter</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xingwenke</rev.name>
        <rev.date type="dateTime">07/17/12 05:19:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E75544: in decide.get.record, call 'setup.reselect.joinfile' instead of 'get.joinfile', so that $L.list can be updated.</rev.desc>
        </rev.desc>
        <change.no type="decimal">75544</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">11/14/11 08:00:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCRQ1E65843: Task4: Move the RAD applications modified by the PD team from Perforce to SVN 	QC Ref.	QCCR1E68080- Changes for Last Task ProcessingQC Ref.	QCCR1E68359 - System becomes locked after the "Record has been Modified" message.QC Ref.	QCCR1E69197 - If a rule on a transition fails, hitting Save will re-run the transtion rules.QC Ref.	QCCR69479 - Alternate forms not working.QC Ref.	QCCR69516 - Open New Task option is not available on all workflow phases [PS Labs Issues #7515/7518]QC Ref.	QCCR1E70087 - Fixed issue:  when user attempts a phase change that fails (due to rules or fc), the phase must revert back to the original phase.Panel:	sync.category.phaseChange:	Changed the exit from duplicate.record to get.workflow.phase		Panel:	check.non.guiChange:	Changed the following condition from:	$L.action="reselect" and not $L.lock.on.display	To:	$L.action="reselect" and not $L.lock.on.display and $L.locked		Panel:	post.displayChange:	Added the following expression:	$L.wfRules={}		Panel:	display.decideChange:	Added a new exit to the "setup.altForm" panel		Panel:	setup.altFormChange:	New process panel		Panel:	setup.init.rulesChange:	Changed the following expressions from:	$L.init.value.names={"$L.format", "$L.title", "$L.parent", "$L.wfPhase", "$L.action"}+$L.value.names	$L.init.values={$L.format, $L.title, $L.parent, $L.wfPhase, $L.action}+$L.values	To:	if null(init.process in $L.state) then ($L.init.value.names={"$L.format", "$L.title", "$L.parent", "$L.wfPhase", "$L.action"}+$L.value.names;$L.init.values={$L.format, $L.title, $L.parent, $L.wfPhase, $L.action}+$L.values)		Panel:	check.base.exitChange:	Changed expession from:	if ($L.exit="bad.val" and $L.wfMode="open") then if (not same(current.phase in $L.file, current.phase in $L.file.save)) then (current.phase in $L.file=current.phase in $L.file.save;contents($L.wfPhase)=contents($L.wfPhase.save)) else ($L.wfPhase=3 in $L.cat.vars)	To:	if ($L.exit="bad.val" and $L.wfMode={"open", "close"}) then if (not same(current.phase in $L.file, current.phase in $L.file.save)) then (current.phase in $L.file=current.phase in $L.file.save;contents($L.wfPhase)=contents($L.wfPhase.save)) else ($L.wfPhase=3 in $L.cat.vars)		Panel:	decide.process.exitChange:	Changed expession from:	if ($L.exit="bad.val" and $L.wfMode="open") then if (not same(current.phase in $L.file, current.phase in $L.file.save)) then (current.phase in $L.file=current.phase in $L.file.save;contents($L.wfPhase)=contents($L.wfPhase.save))	To:	if ($L.exit="bad.val" and $L.wfMode={"open", "close"}) then if (not same(current.phase in $L.file, current.phase in $L.file.save)) then (current.phase in $L.file=current.phase in $L.file.save;contents($L.wfPhase)=contents($L.wfPhase.save))</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhouf</rev.name>
        <rev.date type="dateTime">10/13/11 01:29:25</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Records are not unlocked by se.view.engine when a doAction("save") fails due to a Format Control Validation.</rev.desc>
          <rev.desc sctype="string">In se.view.engine, change the exit for Condition "$L.exit="bad.val" and $L.bg" of panel check.base.exit.1</rev.desc>
          <rev.desc sctype="string">from exit.normal to check.locked.bg</rev.desc>
        </rev.desc>
        <change.no type="decimal">68203</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">Zhang, Ming-Di</rev.name>
        <rev.date type="dateTime">09/27/11 03:22:48</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">duplicating an interaction doesn't take the user to open interaction format</rev.desc>
          <rev.desc sctype="string">$L.action variable is missing, add it in Panel call.init.process and setup.init.rules</rev.desc>
        </rev.desc>
        <change.no type="decimal">69494</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">08/12/11 10:34:05</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added $L.orig.format to variables passed to se.call.process.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xingwenke</rev.name>
        <rev.date type="dateTime">08/06/11 13:58:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">when resubmit closed interaction, the original interaction will be kept unchanged.</rev.desc>
          <rev.desc sctype="string">in panel post.display add " and $L.mode~#"addclone""</rev.desc>
          <rev.desc sctype="string">if (index("locked", $L.messages)~=0) then ($L.locked=true;$L.void=rtecall("tag", $L.errcode, $L.lock.name, $L.file.save));if ($L.locked and $L.mode~#"close" and $L.mode~#"addclone") then ($L.mode="update")</rev.desc>
        </rev.desc>
        <change.no type="decimal">67353</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">08/02/11 06:40:58</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Same as below for save process.</rev.desc>
        </rev.desc>
        <change.no type="decimal">62323</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">08/02/11 05:36:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">When running a phase change during open that has an associated process, the phase needs to be reset if there is a bad validation.</rev.desc>
        </rev.desc>
        <change.no type="decimal">62323</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">08/02/11 04:57:48</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">If the first action (add action) is a Workflow phase change, the logic needs to check for an "add" process rather than always doing a base method add.</rev.desc>
        </rev.desc>
        <change.no type="decimal">62323</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ffaegh</rev.name>
        <rev.date type="dateTime">07/31/11 04:12:50</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCRID: 66761</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">In panel "exit.normal", added a  line to allow for when $exit is "error":</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if ($exit="error") then ($L.exit="error")</rev.desc>
        </rev.desc>
        <change.no type="decimal">66761</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ZhuQinXiang</rev.name>
        <rev.date type="dateTime">07/18/11 04:54:05</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E66303-When Folder Entitlement is enabled in the Incident Management Profile, the rights defined in "Update" are affecting the rights defined in "New"</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">RAD: se.view.engine</rev.desc>
          <rev.desc sctype="string">panel: check.folders</rev.desc>
          <rev.desc sctype="string">add $L.mode into label param: Mode</rev.desc>
        </rev.desc>
        <change.no type="decimal">66303</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hzhang</rev.name>
        <rev.date type="dateTime">06/29/11 18:08:30</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modify set.auto.transition panel so that we will call the right process</rev.desc>
        </rev.desc>
        <change.no type="decimal">62328</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">05/02/11 13:53:32</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified the call on get.format to use str() rather than parse().  Evaluating the condition without it would try to run the expression instead of find the logical evaluation.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ramuro</rev.name>
        <rev.date type="dateTime">04/30/11 15:19:19</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Removing parse of the updateCond from the get.format of WorkflowPhase.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/10/11 03:11:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Adding back the parse of the condition from the Workflow Phase (was removed).</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">04/05/11 02:04:22</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Hua:passing object record when calling rules</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">04/04/11 01:16:45</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Recompiled application to solve an issue created by the Changelist 249551 checked in for CR62662.</rev.desc>
          <rev.desc sctype="string">Resubmitted the 4 previous history changes.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">04/04/11 01:15:51</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">PETE BUDIC's change:</rev.desc>
          <rev.desc sctype="string">QC63087 - Protect against auto/default transitions that create a circular loop (so we don't hang the server).</rev.desc>
          <rev.desc sctype="string">If a workflow has circular logic with auto/default transitions, stop the auto transitions as soon as the record ends up back in its original phase.</rev.desc>
        </rev.desc>
        <change.no type="decimal">3087</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">04/04/11 01:12:41</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">XIA XING (Wayne)'s change:</rev.desc>
          <rev.desc sctype="string">panel: post.cancel</rev.desc>
          <rev.desc sctype="string">unlock.object   $L.action~={"find", "pagelist", "listpages"} and $L.locked and use.locking in $L.object</rev.desc>
          <rev.desc sctype="string">setup.reselect  $L.action="refresh"</rev.desc>
          <rev.desc sctype="string">clear         $L.action="clear"</rev.desc>
          <rev.desc sctype="string">check.master.display  $L.action={"find", "pagelist", "listpages"} and $L.locked and use.locking in $L.object</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel: goto.menu.exit</rev.desc>
          <rev.desc sctype="string">added statements:</rev.desc>
          <rev.desc sctype="string">for $L.x = 1 to lng($L.temp.watch) do ($L.temp=1 in $L.x in $L.temp.watch+"=2 in $L.x in $L.temp.watch";$L.void=evaluate(parse($L.temp)))</rev.desc>
          <rev.desc sctype="string">for $L.x = 1 to lng($L.temp.locals) do ($L.temp=1 in $L.x in $L.temp.locals+"=2 in $L.x in $L.temp.locals";$L.void=evaluate(parse($L.temp)))</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">04/04/11 01:11:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">HUA ZHANG's change:</rev.desc>
          <rev.desc sctype="string">fix the issue where deleted default transition is still running</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">04/04/11 01:09:17</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">RAMURO@ROOPA's change:</rev.desc>
          <rev.desc sctype="string">Recompilation - Added the parse function when checking auto transition conditions on post.auto.transition.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">03/17/11 13:05:26</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added ability to run transitions and actions in background.</rev.desc>
        </rev.desc>
        <change.no type="decimal">58576</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">03/04/11 12:02:29</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed running post actions when an Action is complete.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">03/03/11 03:25:22</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Use the update condition from the workflow phase record if one exists (defaulted to true).</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">02/15/11 04:54:45</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Accept $L.exit.when.done if changed in rules.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">02/12/11 23:51:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Allow Workflow Phase records to specify variables as formats (such as format in $L.category)</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/12/11 02:22:03</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Default format to table name if null.  Also made check for sysrestricted more efficient by checking if field exists first.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/12/11 01:40:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added $L.allow.edit.system to the list of variables passed to display.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">miquan</rev.name>
        <rev.date type="dateTime">10/17/10 17:32:05</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modify the  condition in decide.process.exit.1 panel  for Setup.reselect</rev.desc>
          <rev.desc sctype="string">from  [$L.exit="added"] to  [ $L.exit="added" or $L.exit="reselect"]</rev.desc>
        </rev.desc>
        <change.no type="decimal">54774</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">miquan</rev.name>
        <rev.date type="dateTime">10/17/10 17:21:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modify the check.non.gui  add  'and use.locking in $L.object' for Lock.on.display</rev.desc>
        </rev.desc>
        <change.no type="decimal">55962</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">10/05/10 00:08:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Hua: support workflow based approvals</rev.desc>
        </rev.desc>
        <change.no type="decimal">51433</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">08/05/10 12:30:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Hua: replace test js with a real rte call on panel get.format</rev.desc>
        </rev.desc>
        <change.no type="decimal">46306</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">06/24/10 11:13:05</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Hua: add a hook in get.format to check for auth bit when hpsystem field is set</rev.desc>
        </rev.desc>
        <change.no type="decimal">46306</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">06/24/10 06:43:43</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add the following condition in check.post.auto.transitions</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">and $L.has.workflow</rev.desc>
        </rev.desc>
        <change.no type="decimal">45848</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/18/10 18:13:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Hua: on panel check.get.workflowPhase, added a condition for get.workflow.phase exit</rev.desc>
        </rev.desc>
        <change.no type="decimal">46306</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">09/17/29 14:35:56</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Story: 26536 - Enhanced Application Framework (EAF)</rev.desc>
          <rev.desc sctype="string">45871 - merge EAF code to Henry branch</rev.desc>
          <rev.desc sctype="string">Task: 46242 - DEV:  load in eafDocEngine unload</rev.desc>
          <rev.desc sctype="string">Panel:   after.process.check</rev.desc>
          <rev.desc sctype="string">Changed exit from:</rev.desc>
          <rev.desc sctype="string">decide.process.exit</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">check.post.auto.transitions</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   after.prompt.action.1</rev.desc>
          <rev.desc sctype="string">New exit added:</rev.desc>
          <rev.desc sctype="string">check.get.phase</rev.desc>
          <rev.desc sctype="string">Condition:</rev.desc>
          <rev.desc sctype="string">exists("current.phase", $L.file) and not null($L.wfPhase) and type($L.wfPhase)=6 and not same(current.phase in $L.file, name in $L.wfPhase)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   call.base.method</rev.desc>
          <rev.desc sctype="string">Changed the following expression:</rev.desc>
          <rev.desc sctype="string">From:</rev.desc>
          <rev.desc sctype="string">$L.base.vars={$L.object.name, $L.save.mode, $L.orig.format, $L.category, $L.phase, $L.parent}</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.base.var.names={"$L.object.name", "$L.save.mode", "$L.orig.format", "$L.parent", "$L.exit.when.done", "$L.messages", "$L.dd.reclist", "$L.wfType", "$L.wfRules", "$L.wfMode", "$L.category", "$L.phase", "$L.wfPhase"}</rev.desc>
          <rev.desc sctype="string">$L.base.var.names=$L.base.var.names+denull($L.object.names)</rev.desc>
          <rev.desc sctype="string">$L.base.var.names=$L.base.var.names+$L.tableAccess.names</rev.desc>
          <rev.desc sctype="string">$L.base.values={}</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng($L.base.var.names) do ($L.i in $L.base.values=evaluate(parse($L.i in $L.base.var.names, 2)))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.cat.vars={$L.category, $L.phase, $L.wfPhase}</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   call.base.method.1</rev.desc>
          <rev.desc sctype="string">Changed the following values:</rev.desc>
          <rev.desc sctype="string">From:</rev.desc>
          <rev.desc sctype="string">$L.base.vars</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.base.var.names</rev.desc>
          <rev.desc sctype="string">From:</rev.desc>
          <rev.desc sctype="string">{$L.category, $L.phase}</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.cat.vars</rev.desc>
          <rev.desc sctype="string">From:</rev.desc>
          <rev.desc sctype="string">&lt;blank on Variable Values&gt;</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.base.values</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   call.fc.display</rev.desc>
          <rev.desc sctype="string">Changed exit from:</rev.desc>
          <rev.desc sctype="string">display</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">run.display.rules</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   call.init.process</rev.desc>
          <rev.desc sctype="string">Changed expressions from:</rev.desc>
          <rev.desc sctype="string">$L.init.value.names={"$L.format", "$L.title", "$L.parent", "$L.action"}+$L.value.names</rev.desc>
          <rev.desc sctype="string">$L.init.values={$L.format, $L.title, $L.parent, $L.action}+$L.values</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.init.value.names={"$L.format", "$L.title", "$L.parent", "$L.wfPhase"}+$L.value.names</rev.desc>
          <rev.desc sctype="string">$L.init.values={$L.format, $L.title, $L.parent, $L.wfPhase}+$L.values</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   check.base.exit</rev.desc>
          <rev.desc sctype="string">Added the following expressions:</rev.desc>
          <rev.desc sctype="string">if ($L.exit="bad.val" and $L.wfMode="open") then if (not same(current.phase in $L.file, current.phase in $L.file.save)) then (current.phase in $L.file=current.phase in $L.file.save)</rev.desc>
          <rev.desc sctype="string">$L.wfMode=NULL;$L.wfType=NULL</rev.desc>
          <rev.desc sctype="string">$L.wfPhase=3 in $L.cat.vars</rev.desc>
          <rev.desc sctype="string">if ($L.exit="wfPhaseChange") then ($L.exit="resetrec")</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   check.base.exit.1</rev.desc>
          <rev.desc sctype="string">New exit added:</rev.desc>
          <rev.desc sctype="string">post.auto.transitions</rev.desc>
          <rev.desc sctype="string">Condition:</rev.desc>
          <rev.desc sctype="string">$L.has.workflow</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   check.bg</rev.desc>
          <rev.desc sctype="string">New exit added:</rev.desc>
          <rev.desc sctype="string">set.auto.phaseChange</rev.desc>
          <rev.desc sctype="string">Condition:</rev.desc>
          <rev.desc sctype="string">nullsub($L.wfAuto, false)=true</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   check.get.phase</rev.desc>
          <rev.desc sctype="string">Changed exit from:</rev.desc>
          <rev.desc sctype="string">decide.get.record</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">check.get.workflowPhase</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   check.init.process</rev.desc>
          <rev.desc sctype="string">Changed exit from:</rev.desc>
          <rev.desc sctype="string">get.format</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">setup.init.rules</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   check.no.phase</rev.desc>
          <rev.desc sctype="string">Changed exit from:</rev.desc>
          <rev.desc sctype="string">decide.get.record</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">check.get.workflowPhase</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   create.file.save</rev.desc>
          <rev.desc sctype="string">Changed expression from:</rev.desc>
          <rev.desc sctype="string">$L.copy=evaluate($L.copy) and $L.mode~="addsave"</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.copy=evaluate($L.copy) and $L.mode~="addsave" and nullsub($L.wfAuto, false)=false</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   display</rev.desc>
          <rev.desc sctype="string">Added the following expresssion:</rev.desc>
          <rev.desc sctype="string">$L.exit="normal"</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   display.decide</rev.desc>
          <rev.desc sctype="string">Added the following new exits:</rev.desc>
          <rev.desc sctype="string">Exit:</rev.desc>
          <rev.desc sctype="string">change.wfPhase</rev.desc>
          <rev.desc sctype="string">Condition:</rev.desc>
          <rev.desc sctype="string">$L.action="wfPhaseChange"</rev.desc>
          <rev.desc sctype="string">Exit:</rev.desc>
          <rev.desc sctype="string">setup.runAction</rev.desc>
          <rev.desc sctype="string">Condition:</rev.desc>
          <rev.desc sctype="string">$L.action="runAction"</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   display.go</rev.desc>
          <rev.desc sctype="string">Changed the array of local variables from:</rev.desc>
          <rev.desc sctype="string">{$L.dd.reclist, $L.qbe.name, $L.list, $L.locked, $L.allow.input, $L.format, $L.fc, $L.object, $L.env, $L.site, $L.modify, $L.mode, $L.mult, $L.lock.name, $L.title, $L.category, $L.phase, $L.has.link, $L.se.pagelist, true, $L.related.filename, $L.related.id, $L.parent, $L.mod.columns, $L.view}+$L.values</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">{$L.dd.reclist, $L.qbe.name, $L.list, $L.locked, $L.allow.input, $L.format, $L.fc, $L.object, $L.env, $L.site, $L.modify, $L.mode, $L.mult, $L.lock.name, $L.title, $L.category, $L.phase, $L.has.link, $L.se.pagelist, true, $L.related.filename, $L.related.id, $L.parent, $L.mod.columns, $L.view, $L.wfPhase, $L.wfMode}+$L.values</rev.desc>
          <rev.desc sctype="string">From:</rev.desc>
          <rev.desc sctype="string">{"$L.dd.reclist", "$L.dd.qbe.format", "$L.dd.traverse.list", "$L.locked", "$L.allow.input", "$L.format", "$L.fc", "$L.object", "$L.env", "$L.site", "$L.modify", "$L.mode", "$L.mult", "$L.lock.name", "$L.title", "$L.category", "$L.phase", "$L.has.link", "$L.se.pagelist", "$L.engine", "$L.related.filename", "$L.related.id", "$L.parent", "$L.mod.columns", "$L.dd.view"}+$L.value.names</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">{"$L.dd.reclist", "$L.dd.qbe.format", "$L.dd.traverse.list", "$L.locked", "$L.allow.input", "$L.format", "$L.fc", "$L.object", "$L.env", "$L.site", "$L.modify", "$L.mode", "$L.mult", "$L.lock.name", "$L.title", "$L.category", "$L.phase", "$L.has.link", "$L.se.pagelist", "$L.engine", "$L.related.filename", "$L.related.id", "$L.parent", "$L.mod.columns", "$L.dd.view", "$L.wfPhase", "$L.wfMode"}+$L.value.names</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   get.format</rev.desc>
          <rev.desc sctype="string">Added the following expression:</rev.desc>
          <rev.desc sctype="string">if (not null($L.wfPhase) and not null(displayForm in $L.wfPhase)) then ($L.format=displayForm in $L.wfPhase)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   get.phase</rev.desc>
          <rev.desc sctype="string">Changed exit from:</rev.desc>
          <rev.desc sctype="string">decide.get.record</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">check.get.workflowPhase</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   no.phase.1</rev.desc>
          <rev.desc sctype="string">Changed exit from:</rev.desc>
          <rev.desc sctype="string">decide.get.record</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">check.get.workflowPhase</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   prepare.process</rev.desc>
          <rev.desc sctype="string">Changed expression from:</rev.desc>
          <rev.desc sctype="string">$L.value.names=$L.object.names+{"$L.fc", "$L.exit", "$L.file.save", "$L.action", "$L.mode", "$L.exit.when.done", "$L.related.filename", "$L.related.id", "$L.parent", "$L.messages", "$L.fc.master", "$L.dd.reclist", "$L.format", "$L.category", "$L.phase"}+$L.tableAccess.names</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.value.names=$L.object.names+{"$L.fc", "$L.exit", "$L.file.save", "$L.action", "$L.mode", "$L.exit.when.done", "$L.related.filename", "$L.related.id", "$L.parent", "$L.messages", "$L.fc.master", "$L.dd.reclist", "$L.format", "$L.wfType", "$L.wfRules", "$L.wfMode", "$L.wfPhase"}+$L.tableAccess.names</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Added the following expression:</rev.desc>
          <rev.desc sctype="string">$L.cat.vars={$L.object, $L.category, $L.phase, $L.wfPhase}</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   return.init.values</rev.desc>
          <rev.desc sctype="string">Changed exit from:</rev.desc>
          <rev.desc sctype="string">get.format</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">setup.init.rules</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   set.values</rev.desc>
          <rev.desc sctype="string">Changed expression from:</rev.desc>
          <rev.desc sctype="string">$L.tableAccess.names={"$L.tableAccess.view", "$L.tableAccess.new", "$L.tableAccess.close", "$L.tableAccess.delete", "$L.tableAccess.update", "$L.tableAccess.folders"}</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.tableAccess.names={"$L.tableAccess.view", "$L.tableAccess.new", "$L.tableAccess.close", "$L.tableAccess.delete", "$L.tableAccess.update", "$L.tableAccess.folders", "$L.tableAccess.expert", "$L.tableAccess.admin"}</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   setup.tableAccess</rev.desc>
          <rev.desc sctype="string">New expression added:</rev.desc>
          <rev.desc sctype="string">if (filename($L.env)="tableAccess") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, $L.env, $L.object, $L.folder.exists))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel:   setup.vars</rev.desc>
          <rev.desc sctype="string">New expressions added:</rev.desc>
          <rev.desc sctype="string">$L.has.workflow=false</rev.desc>
          <rev.desc sctype="string">$L.wfAuto=false</rev.desc>
          <rev.desc sctype="string">$L.wfAutoPhase=false</rev.desc>
          <rev.desc sctype="string">$L.wfAutoRules={}</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Added the following panels:</rev.desc>
          <rev.desc sctype="string">after.display.rules</rev.desc>
          <rev.desc sctype="string">change.wfPhase</rev.desc>
          <rev.desc sctype="string">check.auto.transition</rev.desc>
          <rev.desc sctype="string">check.current</rev.desc>
          <rev.desc sctype="string">check.current.1</rev.desc>
          <rev.desc sctype="string">check.get.workflowPhase</rev.desc>
          <rev.desc sctype="string">check.init.rules</rev.desc>
          <rev.desc sctype="string">check.post.auto.transitions</rev.desc>
          <rev.desc sctype="string">decide.runAction</rev.desc>
          <rev.desc sctype="string">finish.init.rules</rev.desc>
          <rev.desc sctype="string">get.workflow.phase</rev.desc>
          <rev.desc sctype="string">not.same</rev.desc>
          <rev.desc sctype="string">post.auto.transitions</rev.desc>
          <rev.desc sctype="string">run.display.rules</rev.desc>
          <rev.desc sctype="string">run.display.rules.1</rev.desc>
          <rev.desc sctype="string">run.init.rules</rev.desc>
          <rev.desc sctype="string">runAction</rev.desc>
          <rev.desc sctype="string">set.auto.phaseChange</rev.desc>
          <rev.desc sctype="string">set.workflow.flag</rev.desc>
          <rev.desc sctype="string">setup.init.rules</rev.desc>
          <rev.desc sctype="string">setup.runAction</rev.desc>
        </rev.desc>
        <change.no type="decimal">26536</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">09/17/05 06:26:54</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QC54122 - The RAD applications se.search.engine and se.view.engine do not consider that the PM module can have different access configuration for problems, problem tasks, known errors and known error tasks.</rev.desc>
          <rev.desc sctype="string">Panel:	setup.tableAccess</rev.desc>
          <rev.desc sctype="string">From:</rev.desc>
          <rev.desc sctype="string">if (exists("tableAccess", $L.env) and not null(tableAccess in $L.env)) then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccess in $L.env, $L.object, $L.folder.exists))</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">if (exists("tableAccess", $L.env) and not null(tableAccess in $L.env) and filename($L.file)~="rootcause" and filename($L.file)~="rootcausetask" and filename($L.file)~="knownerror" and filename($L.file)~="knownerrortask") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccess in $L.env, $L.object, $L.folder.exists))</rev.desc>
          <rev.desc sctype="string">if (exists("tableAccessProb", $L.env) and not null(tableAccessProb in $L.env) and filename($L.file)="rootcause") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccessProb in $L.env, $L.object, exists("folder", $L.file)))</rev.desc>
          <rev.desc sctype="string">if (exists("tableAccessTask", $L.env) and not null(tableAccessTask in $L.env) and filename($L.file)="rootcausetask") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccessTask in $L.env, $L.object, exists("folder", $L.file)))</rev.desc>
          <rev.desc sctype="string">if (exists("tableAccessKE", $L.env) and not null(tableAccessKE in $L.env) and filename($L.file)="knownerror") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccessKE in $L.env, $L.object, exists("folder", $L.file)))</rev.desc>
          <rev.desc sctype="string">if (exists("tableAccessKETask", $L.env) and not null(tableAccessKETask in $L.env) and filename($L.file)="knownerrortask") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccessKETask in $L.env, $L.object, exists("folder", $L.file)))</rev.desc>
        </rev.desc>
        <change.no type="decimal">54122</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">09/15/31 02:49:07</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified the 'refresh.set.many' panel so that the following expression:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (not null($L.dd.sort) and not same($L.dd.sort, {}) and not same($L.dd.sort, $L.sort)) then ($L.void=setsort($L.file, $L.dd.sort, $L.sort.type))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">is replaced with:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (not null($L.view) and not null(groupByFieldName in $L.view) and not same(groupByFieldName in $L.view, {})) then ($L.dd.sort=sortFieldName in $L.view;$L.gg.sort=groupByFieldName in $L.view;$L.sort.type={};$L.gg.sort.type={};for $L.i = 1 to lng(denull(sortFieldName in $L.view)) do (if ($L.i in sortType in $L.view)#"d" then ($L.i in $L.sort.type=1) else ($L.i in $L.sort.type=0));for $L.i = 1 to lng(denull(groupByFieldName in $L.view)) do (if ($L.i in groupSortType in $L.view)#"d" then ($L.i in $L.gg.sort.type=1) else ($L.i in $L.gg.sort.type=0));$L.void=setsort($L.file, $L.dd.sort, $L.sort.type, $L.gg.sort, $L.gg.sort.type);$L.void=rtecall("rfirst", $L.rc, $L.file)) else (if (not null($L.dd.sort) and not same($L.dd.sort, {}) and not same($L.dd.sort, $L.sort)) then ($L.void=setsort($L.file, $L.dd.sort, $L.sort.type)))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">This prevents the wrong records from being reshuffled under each group after a list refresh.</rev.desc>
        </rev.desc>
        <change.no type="decimal">49156</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">09/13/31 10:40:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QC8467 - Attempting to use "expand array" on a Affected Ci's in Change Management - Could possibly be renamed to "Data Corruption Wizard".</rev.desc>
          <rev.desc sctype="string">Removed the panel "edit.array" of type "edit.array"</rev.desc>
          <rev.desc sctype="string">Removed the exists to the panel "edit.array" from the following panels:</rev.desc>
          <rev.desc sctype="string">- display.decide</rev.desc>
        </rev.desc>
        <change.no type="decimal">8467</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">08/25/30 00:40:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">set $L.special.type in start panel</rev.desc>
        </rev.desc>
        <change.no type="decimal">49162</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ffaegh</rev.name>
        <rev.date type="dateTime">08/19/01 08:51:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel 'record.changed.msg':</rev.desc>
          <rev.desc sctype="string">Changed:</rev.desc>
          <rev.desc sctype="string">$L.msg=scmsg(52, "us", {$L.bg.action})</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.msg=scmsg(52, "us")</rev.desc>
        </rev.desc>
        <change.no type="decimal">8713</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ffaegh</rev.name>
        <rev.date type="dateTime">08/18/27 07:19:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QC8713:</rev.desc>
          <rev.desc sctype="string">Changed reselect Exit to 'bg.record.changed'</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">- Added process panel 'bg.record.changed':</rev.desc>
          <rev.desc sctype="string">$L.exit="changed"</rev.desc>
          <rev.desc sctype="string">exiting normal to panel 'record.changed.msg' error to 'exit.error.msg'</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">- Added process panel 'record.changed.msg':</rev.desc>
          <rev.desc sctype="string">$L.msg=scmsg(52, "us", {$L.bg.action})</rev.desc>
          <rev.desc sctype="string">exiting normal to panel 'record.changed.msg.1' error to 'exit.error.msg'</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">- Added message panel 'record.changed.msg.1':</rev.desc>
          <rev.desc sctype="string">$L.msg</rev.desc>
          <rev.desc sctype="string">exiting normal to 'badval.unlock.object' in order to unlock the lock on the object and error to 'exit.error.msg'</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">- Deleted unused panels</rev.desc>
        </rev.desc>
        <change.no type="decimal">8713</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hzhang</rev.name>
        <rev.date type="dateTime">08/16/09 02:36:03</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QC6029:on panel prepare.process, add $L.category and $L.phase in the $L.value.names so that when $L.category and $L.phase changed when calling a process, those changes will be brought back.</rev.desc>
        </rev.desc>
        <change.no type="decimal">6029</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">08/13/08 18:41:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Hua:added a panel in se.view.engine so that when a record is reselected, I will check to see if $L.phase and $L.category is out of sync. If they are, then reselect $L.category and $L.phase.</rev.desc>
        </rev.desc>
        <change.no type="decimal">42218</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">07/21/16 18:54:19</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">DE3257</rev.desc>
          <rev.desc sctype="string">panel:  call.init.process</rev.desc>
          <rev.desc sctype="string">added $L.action to the init values</rev.desc>
          <rev.desc sctype="string">panel:  prepare.process</rev.desc>
          <rev.desc sctype="string">added $L.format to the $L.value and $L.object.names variables</rev.desc>
        </rev.desc>
        <change.no type="decimal">3257</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">07/19/27 14:23:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">DE3186  updated the start panel so that the expression starting with:</rev.desc>
          <rev.desc sctype="string">if (not null($L.bg.action))....</rev.desc>
          <rev.desc sctype="string">now reads</rev.desc>
          <rev.desc sctype="string">if (not same($L.bg.action, NULL))...</rev.desc>
          <rev.desc sctype="string">$L.bg.action was equal to "" which was causing the not null funciton to fail.</rev.desc>
        </rev.desc>
        <change.no type="decimal">3186</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ffaegh</rev.name>
        <rev.date type="dateTime">07/20/22 08:10:28</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">SCR 40833 - Added a lock name parameter to be passed when a record is being modified by updates from the event records.</rev.desc>
        </rev.desc>
        <change.no type="decimal">40833</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">acorvino</rev.name>
        <rev.date type="dateTime">07/19/21 06:44:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">DE2897</rev.desc>
          <rev.desc sctype="string">Don't do a refresh on a delete.</rev.desc>
        </rev.desc>
        <change.no type="decimal">2897</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">07/19/03 01:22:48</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">check if the update field is type 10 (in addition to type 2 or 4)</rev.desc>
          <rev.desc sctype="string">Panel post.display</rev.desc>
          <rev.desc sctype="string">Changed expression:</rev.desc>
          <rev.desc sctype="string">if exists("update", $L.env) then if (type(update in $L.env)=4) then ($L.can.update=evaluate(update in $L.env)) else (if type(update in $L.env=2) then ($L.can.update=$L.tableAccess.update));$L.can.update=nullsub($L.can.update, true)</rev.desc>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string">if exists("update", $L.env) then if (type(update in $L.env)={4, 10}) then ($L.can.update=evaluate(update in $L.env)) else (if type(update in $L.env=2) then ($L.can.update=$L.tableAccess.update));$L.can.update=nullsub($L.can.update, true)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Short version:  =4 to ={4,10}</rev.desc>
        </rev.desc>
        <change.no type="decimal">41648</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">07/17/05 18:51:48</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Don't try to select a save copy of the record if the record id in NULL.  Instead just init a blank copy of the file variable.</rev.desc>
          <rev.desc sctype="string">Panel check.get.save.copy.bg</rev.desc>
          <rev.desc sctype="string">Added new exit and condition at top of list</rev.desc>
          <rev.desc sctype="string">init.save.copy    $L.bg and null($L.record.id)</rev.desc>
          <rev.desc sctype="string">Panel init.save.copy</rev.desc>
          <rev.desc sctype="string">New rinit pane ($L.file.save, filename($L.file))</rev.desc>
          <rev.desc sctype="string">Normal exit: decide.extaccess</rev.desc>
        </rev.desc>
        <change.no type="decimal">41237</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ffaegh</rev.name>
        <rev.date type="dateTime">07/13/06 18:39:06</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">SCR 40833 - Task 35400: Modified se.view.engine, "lock.bg" panel to exit to "check.current" instead of "bg.record.changed" where the code will check to see if the record is current and if it is not, then we refresh the record and check again. If the record is the same, then the code exits to "set.bg.lock" and goes on with setting the lock on the record. New panels "check.current", "check.current.1", and "not.same" were added. Deleted unused panel "bg.record.changed" and "record.changed.msg".</rev.desc>
        </rev.desc>
        <change.no type="decimal">40833</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">06/23/10 10:47:23</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">SCR40469 - panel set.new.state: replaced the expression '$L.skip.copy=false' with 'if (status in $L.file)~#"reopen" then ($L.skip.copy=false) else ($L.skip.copy=true)</rev.desc>
        </rev.desc>
        <change.no type="decimal">40469</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/20/07 19:26:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Default the qbe format name to filename.qbe in case it is not specified in the list State.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/20/02 09:30:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Set $L.dd.reclist to 0 if $L.mult is explicitly false.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">06/18/29 13:08:45</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel get.format</rev.desc>
          <rev.desc sctype="string">Removed if (profile.appl in $L.object="revision.view.environment") then ($L.screen.id="revision.view.record";use.locking in $L.object=false)</rev.desc>
          <rev.desc sctype="string">DE1648</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">06/19/05 05:06:10</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Recompile due to change to previous panel</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/17/29 23:11:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Pass the view on to the display application.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/16/31 16:10:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Recompiled to fix broken parameters.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/16/20 15:04:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Send view information to the inbox add routine.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/16/14 11:51:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Had to add additional folder selection checking (for permissions).</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">06/16/07 11:27:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Use thread variable for extaccess record instead of selecting it.  This variable will be set in se.external.action.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">jantonecchia</rev.name>
        <rev.date type="dateTime">06/16/06 09:55:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">will set state correctly in duplicate.record</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">06/14/24 17:52:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel get.save.copy.bg</rev.desc>
          <rev.desc sctype="string">Changed no records exit to init.extaccess</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/15/22 09:34:04</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added allowed folder list.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/14/21 12:06:02</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added hook for applying templates</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/13/07 14:03:32</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added hook for creating templates.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/13/26 10:32:03</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Keep the view when passed in from scm.advanced</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">acorvino</rev.name>
        <rev.date type="dateTime">06/12/14 15:14:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Removed call to obsolete function current.window()</rev.desc>
        </rev.desc>
        <change.no type="decimal">885</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">05/24/23 10:19:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Moved initializations into JavaScript to reduce size of code record.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">05/22/29 05:57:36</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Changed normal exit on after.prompt.action.1 panel from check.master.display TO check.get.save.copy.bg allowing State initialization process/fc processing and save of $L.file.save to occur after a reselect.</rev.desc>
        </rev.desc>
        <change.no type="decimal">38906</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ffaegh</rev.name>
        <rev.date type="dateTime">05/21/04 11:43:20</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx J0045: Modified process panel no.category to check if the record is entered via ess and if so, then doo not display the messge. Changed:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.no.cat.msg=scmsg(4, "object", {category in $L.list, category.file.name in $L.object})</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (not nullsub(ess.entry in $L.file, false)) then ($L.no.cat.msg=scmsg(4, "object", {category in $L.list, category.file.name in $L.object}))</rev.desc>
        </rev.desc>
        <change.no type="decimal">45</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">05/17/28 13:19:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel setup.vars</rev.desc>
          <rev.desc sctype="string">Change how the title is built for add mode to:</rev.desc>
          <rev.desc sctype="string">if ($L.mode="add") then ($L.title=scmsg(188, "object", {nullsub($L.object.name, "Database Record")}))</rev.desc>
        </rev.desc>
        <change.no type="decimal">38674</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">05/18/06 06:41:05</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx I1447</rev.desc>
          <rev.desc sctype="string">updated the get.link panel to pass in $L.special.type to the 'se.get.link.application'</rev.desc>
        </rev.desc>
        <change.no type="decimal">1447</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">05/17/09 11:03:54</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">continuation of issue listed below</rev.desc>
          <rev.desc sctype="string">updated the start panel...updated the line that set $L.special.type=$INTO.SPECIAL</rev.desc>
          <rev.desc sctype="string">if nothing was passed in then the type (based on the parameter definition) was set to an array which caused issues with the nullsub on the setup.vars panel.</rev.desc>
          <rev.desc sctype="string">Changed the expression to:</rev.desc>
          <rev.desc sctype="string">if (type($INTO.SPECIAL)=8) then ($L.special.type=NULL) else ($L.special.type=$INTO.SPECIAL)</rev.desc>
        </rev.desc>
        <change.no type="decimal">936</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">05/17/08 09:41:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx I0936:</rev.desc>
          <rev.desc sctype="string">updated the setup.vars panel.  When the object was a 'special' type the code was still trying to set up the message using the filename which in the case of special object types doesn't actually exist. (example...joinfiles).</rev.desc>
          <rev.desc sctype="string">changed the following expression:</rev.desc>
          <rev.desc sctype="string">$L.object.name=scmsg(nullsub(filename($L.file), "tablename")</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">$L.object.name=scmsg(nullsub($L.special.type, filename($L.file)), "tablename")</rev.desc>
          <rev.desc sctype="string">This way the correct object record/filename will be used when searching for the scmessage record.</rev.desc>
        </rev.desc>
        <change.no type="decimal">936</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">05/16/04 11:23:19</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">When "State" was set it was overriding open and close States.  Fixed parenthesis placement.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/24/08 10:50:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added ability to use the XML Fill ability.  At this time it is hardcoded to the "options" and "option.validations" fields.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">04/22/27 04:50:02</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">fixed special object parameter</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/22/27 04:34:12</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added special object type to parameter panel.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/22/09 11:46:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Application was no properly doing a refresh when taking the refresh exit from lock.on.display.</rev.desc>
        </rev.desc>
        <change.no type="decimal">37484</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">04/20/28 12:04:37</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel:  prepare.process</rev.desc>
          <rev.desc sctype="string">Added $L.dd.reclist to the $L.value.names list so that the process record can check whether reclist is turned on or not.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">04/19/13 11:46:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">no changes</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">04/19/08 05:46:33</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added 'else ($L.rc=true)' to the expression below.</rev.desc>
          <rev.desc sctype="string">This way $L.rc always has a value and is always reset each time through.</rev.desc>
        </rev.desc>
        <change.no type="decimal">24794</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">04/19/08 05:14:48</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">CP SCR24794</rev.desc>
          <rev.desc sctype="string">issue where datapolicy is called when not needed...no changes were made and action~='ok,save,add'</rev.desc>
          <rev.desc sctype="string">panel:  post.display</rev.desc>
          <rev.desc sctype="string">updated the following expression:</rev.desc>
          <rev.desc sctype="string">if ($L.action={"ok", "save", "add"} or not null($L.process.save)) then ($L.rc=false;$L.rc=rtecall("policycheck", $L.errcode, $L.file))</rev.desc>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string">if ($L.action={"ok", "save", "add"} or not null($L.process.save) and not $L.same) then ($L.rc=false;$L.rc=rtecall("policycheck", $L.errcode, $L.file))</rev.desc>
          <rev.desc sctype="string">This way datapolicy will always be called when the action is = ok,save,add and will not be called if the action is equal to anything else and $L.same=true</rev.desc>
        </rev.desc>
        <change.no type="decimal">24794</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">04/19/07 10:04:06</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">CP scr32957</rev.desc>
          <rev.desc sctype="string">panel: display.decide</rev.desc>
          <rev.desc sctype="string">removed the exit for db.mass.function.joinfile with a condition of:</rev.desc>
          <rev.desc sctype="string">$L.action={"massupdate", "massdelete"} and not null(evaluate(parse(joindef in $L.object, 2)))</rev.desc>
          <rev.desc sctype="string">also removed the panel 'db.mass.function.joinfile'</rev.desc>
          <rev.desc sctype="string">The mass.update application takes care of the joinfile issue so it was not necessary to do so in the se.view.engine as well.</rev.desc>
        </rev.desc>
        <change.no type="decimal">32597</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/17/07 05:47:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Changed the count panel to go against $L.list rather than $L.file.  Otherwise the count would always return 1 for a joinfile.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">04/16/24 05:59:49</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket I1982:</rev.desc>
          <rev.desc sctype="string">panel:  duplicate.record</rev.desc>
          <rev.desc sctype="string">removed the following expression:</rev.desc>
          <rev.desc sctype="string">if (not nullsub(default.object in $L.object, false)) then if exists("State", $L.file) then if null(State in $L.file) then ($L.mode="add";State in $L.file=open.state in $L.object;$L.state.name=State in $L.file)</rev.desc>
          <rev.desc sctype="string">This was causing issues with the upgrade rootcause records since the field is nulled out in the upgrade process so the mode always gets set to 'add' and never 'update'</rev.desc>
        </rev.desc>
        <change.no type="decimal">1982</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/16/17 06:09:44</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified how the object name (for display) was handled.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">04/16/14 03:38:11</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel decide.get.record</rev.desc>
          <rev.desc sctype="string">changed first condition to not null(joindef in $L.object)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel get.joinfile</rev.desc>
          <rev.desc sctype="string">changed second expression on first line to:</rev.desc>
          <rev.desc sctype="string">if (index("$", joindef in $L.object)&gt;0) then ($L.joinfile.name=evaluate(parse(joindef in $L.object, 2))) else ($L.joinfile.name=joindef in $L.object)</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">02/18/04 08:40:48</rev.date>
        <rev.desc sctype="array"/>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">02/17/04 14:42:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added a suppress message flag - if true, messages normally sent by se.base.method will not get sent.</rev.desc>
        </rev.desc>
        <change.no type="decimal">28148</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">02/16/25 11:30:06</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified application to exit if engine.access in $L.object is false - the file is not accessible through the engine.</rev.desc>
        </rev.desc>
        <change.no type="decimal">28144</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">02/16/19 08:42:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">on the 'get.format' panel:</rev.desc>
          <rev.desc sctype="string">Changed the expression:</rev.desc>
          <rev.desc sctype="string">$L.allow.input=nullsub(evaluate(parse(input.condition in $L.state, 2)), true)</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">$L.allow.input=nullsub(evaluate(input.condition in $L.state, 2), true)</rev.desc>
        </rev.desc>
        <change.no type="decimal">27850</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">02/16/19 03:17:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Now checks if a file is either a paging or revision file and sets it to the correct special object type to be passed into se.get.object:</rev.desc>
          <rev.desc sctype="string">- added set.special.type to be called between start and get.object</rev.desc>
          <rev.desc sctype="string">- on get.object, set Special Object Type to $L.special.type</rev.desc>
        </rev.desc>
        <change.no type="decimal">27728</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/16/08 09:07:10</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed background processing to unlock records and fixed the background flag when calling a process.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">02/15/02 08:47:08</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">On start, set mode to "add" if the background action is "add"</rev.desc>
          <rev.desc sctype="string">- changed expression from if (not null($L.bg.action)) then ($L.bg=true) to if (not null($L.bg.action)) then ($L.bg=true;if ($L.bg.action="add") then ($L.mode="add"))</rev.desc>
          <rev.desc sctype="string">- moved the following mode-related expressions to the end of the panel:  $L.initial.mode=$L.mode;if $L.mode#"add" then ($L.dd.reclist=false)</rev.desc>
        </rev.desc>
        <change.no type="decimal">27172</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/14/27 03:07:48</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fix for check to see if record changed.  NULL entries cause by new fields being added no longer cause the engine to think the record has changed.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/14/26 06:27:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">When calling a process that results in an application error, engine will drop back to displaying the record instead of dropping to the menu.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/14/25 08:05:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added watch variables from Object record.  Watch Variables are checked to see if they are not null on post.display.  If any are not null, then the record is considered to be changed.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/14/23 04:26:08</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added a new exit for "unlock" so that processes that have actions that are not "save" can unlock a record after the process is complete (im.close is the example in this case).</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">02/13/19 07:38:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added exit to unlock.object with the following condition:</rev.desc>
          <rev.desc sctype="string">$L.action="reselect" and not $L.lock.on.display</rev.desc>
          <rev.desc sctype="string">This way when a user uses the undo button the lock is released.</rev.desc>
        </rev.desc>
        <change.no type="decimal">1217</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">02/12/24 09:23:40</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Recompiled due to changes to se.base.method - a suppress flag parameter was added.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">02/12/24 02:07:45</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">changed the following line (on panels 'check.master.display' and 'check.master.init')</rev.desc>
          <rev.desc sctype="string">name in $L.fc.master~=name in $L.fc</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">not same(name in $L.fc.master, name in $L.fc)</rev.desc>
          <rev.desc sctype="string">This ensures that if there isn't a master format control the detail format control record will still be executed.</rev.desc>
        </rev.desc>
        <change.no type="decimal">25809</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">02/12/16 08:13:50</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">modified the get.record panel.  Changed the expression to:</rev.desc>
          <rev.desc sctype="string">if ($L.action~="add") then ($L.void=rtecall("refresh", $L.errcode, $L.file))</rev.desc>
          <rev.desc sctype="string">This way the refresh doesn't happen when doing an add.</rev.desc>
        </rev.desc>
        <change.no type="decimal">24252</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">02/10/29 06:31:55</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added the exit "setup.reselect.joinfile" to the decide.process.exit.1 panel.  The setup.reselect.joinfile panel moves the values from the fields that make up the unique key from $L.file to $L.list.  This way the $L.temp.tag on the next panel is set correctly and the query against the joinfile on the get.joinfile.record panel will work correctly and the record is displayed correctly after the add is complete.</rev.desc>
        </rev.desc>
        <change.no type="decimal">25058</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/09/29 14:04:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified the exit after adding a record that is a joinfile to reset the unique key in the $L.list variable so that the record is selected properly.</rev.desc>
        </rev.desc>
        <change.no type="decimal">25058</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">02/10/28 12:35:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Removed the 2 places where $L.print.format is setup.  This makes the value null unless it is specifically set in a process.  This allows the us.print routines to choose the format for special case files - like incidents.</rev.desc>
        </rev.desc>
        <change.no type="decimal">25254</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/10/15 09:06:22</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Now passes in the background flag correctly to se.get.object.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/10/01 06:09:57</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">When you pass in a background action, it passes the final $L.exit parameter out through the same parameter.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/08/27 12:21:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added additional changes for background processing.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">02/08/22 13:24:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">The set.new.state panel now goes to check.non.gui instead of to get.state.  This routes it back through the check for Lock on Display after changing states.</rev.desc>
        </rev.desc>
        <change.no type="decimal">25082</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/10/20 09:01:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed exit when no action is hit to go to check.master.display rather than display (so display fc is run).</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/08/15 12:41:41</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Reset $L.exit.when.done to false if process exits with "cancel"</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/10/12 07:06:03</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified line on after.prompt.action to read:</rev.desc>
          <rev.desc sctype="string">if ($L.mode#"add" or $L.mode#"close") then ($L.mode=$L.initial.mode)</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/08/07 15:16:04</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">changed exits for pagelist, find, fill from exit.menu to goto.menu.exit -- which sets $L.action to "menu" and then goes to post.cancel.  This makes sure the record is unlocked before exiting.</rev.desc>
        </rev.desc>
        <change.no type="decimal">24844</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/09/24 09:25:04</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will not reset $L.file.save when going through the "newstate" exit.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/07/18 12:31:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Created new panel (create.file.save) that creates the $L.file.save parameter after initial processes and format control, but before display.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/21/29 12:47:21</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">No passes $L.messages into the process.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/21/28 08:04:33</rev.date>
        <rev.desc sctype="array"/>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/21/28 07:58:44</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified exit for "newcat" on decide.process.exit.1 to set $L.newcat to true, which will then select the new category but skip the actual reselect of the record and resetting of $L.file.save</rev.desc>
        </rev.desc>
        <change.no type="decimal">24050</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/20/28 14:22:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Put in a hardcoded fix on post.display to force $L.same to false if we are in Incident Management and the $apm.activity or $pmc.actions variable are not null.</rev.desc>
        </rev.desc>
        <change.no type="decimal">23318</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/20/28 13:59:46</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">compile only</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">01/21/19 09:31:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added an exit to decide.process.exit.1 to unlock the record after a save if Lock on Display isn't turned on.  Changed the normal exit on after.prompt.action.1 from display to check.master.display.</rev.desc>
        </rev.desc>
        <change.no type="decimal">23907</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">01/20/13 14:22:41</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified check.non.gui to only call lock.on.display if the record isn't locked.</rev.desc>
        </rev.desc>
        <change.no type="decimal">23504</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">01/21/07 08:44:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">modified the se.view.engine application.</rev.desc>
          <rev.desc sctype="string">The get.format panel was being called before the initial process was being called.  In the initial process the format variables (format in $L.file and $L.format) were being set.  Since this was happening after the get.format panel these variables were empty.</rev.desc>
          <rev.desc sctype="string">Broke the get.format panel into 2 panels.</rev.desc>
          <rev.desc sctype="string">The first panel is called from the get.state panel.  This panel sets the $L.value.names and $L.values variables.</rev.desc>
          <rev.desc sctype="string">The get.format panel now sets up the format name but no longer initializes the $L.value.names and $L.values variables.</rev.desc>
        </rev.desc>
        <change.no type="decimal">23761</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/20/20 08:14:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Now passes category and phase to se.base.method.</rev.desc>
        </rev.desc>
        <change.no type="decimal">23565</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/20/20 03:51:05</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Changed to pass master format control record to se.base.method</rev.desc>
        </rev.desc>
        <change.no type="decimal">23565</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">01/20/12 03:14:36</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added the following to the post.display panel:</rev.desc>
          <rev.desc sctype="string">$L.locked.temp=nullsub($L.locked.temp, $L.locked)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">changed the end of the condition expressions for both prompt.save exits on the decide.prompt.save panel:</rev.desc>
          <rev.desc sctype="string">was:</rev.desc>
          <rev.desc sctype="string">and not $L.same and $G.prompt.for.save</rev.desc>
          <rev.desc sctype="string">changed to:</rev.desc>
          <rev.desc sctype="string">and (not $L.same or $L.locked.temp) and $G.prompt.for.save</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">added the following to the set.save.action panel:</rev.desc>
          <rev.desc sctype="string">$L.locked.temp=false</rev.desc>
          <rev.desc sctype="string">(this prevents the prompt.save looping)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">added the following to the set.not.locked panel:</rev.desc>
          <rev.desc sctype="string">$L.locked.temp=NULL</rev.desc>
          <rev.desc sctype="string">(This is so this variable gets set correctly on the post.display panel)</rev.desc>
        </rev.desc>
        <change.no type="decimal">16418</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/18/29 18:35:10</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified exit for "setupadd" on decide.process.exit.1 to setup.vars to reflect changes in where category and phase are selected.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">01/19/27 07:21:41</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">removed last modification</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">01/19/27 07:08:54</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added if ($L.mode="add") then ($L.mode="update") to the decide.process.exit panel</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/19/22 02:27:12</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">pass category and phase to the base methods.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">01/19/19 08:52:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified check.non.gui to bypass locking if $L.mode~#"add".  The previous condition was $L.mode~="add", which didn't account for when $L.mode="addsave".</rev.desc>
        </rev.desc>
        <change.no type="decimal">23193</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/19/14 08:01:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified to keep sort order on refresh.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/19/13 07:31:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added se.get.link to allow for master (file) links.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">01/18/24 03:01:07</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added exit "refreshjoinfile" to the decide.process.exit1 panel</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/17/24 15:28:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified so that when using a joindef the refresh exit goes back via setup.vars incase the joinfile changes.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/18/21 03:11:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified to allow a background action and set the background flag to true if one is entered.  Also replaced direct calls for add/update/delete to use the se.base.method application.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/18/16 05:37:20</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added a background flag.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">01/17/27 03:48:12</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">removed $L.exit="added" from the dup.after.save panel</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">01/17/27 03:33:17</rev.date>
        <rev.desc sctype="array"/>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/16/21 03:51:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will now project to the joinfile when mode # "add", so that data entered in the transverse file is not lost.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/16/16 08:21:44</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added modifications to allow a joindef record to be defined in the Object record.  Then the joined record is used as $L.file while the original list is $L.list.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/12/08 16:31:18</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified to reset $L.same after a process in case the standard process is run after and that process is "ok".</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">joeh</rev.name>
        <rev.date type="dateTime">01/11/28 14:20:51</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified the add.record.radd panel to exit to display if a trigger fails.  Should fix beta ticket IM00074</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/12/26 07:44:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added new routine to fetch phases to catch exceptions caused by ocm.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/11/14 11:38:41</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will refetch state if the refresh option is called (setup.reselect).</rev.desc>
        </rev.desc>
        <change.no type="decimal">18574</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/11/23 08:52:30</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Won't change states if the State changes from NULL to the default state.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/10/17 13:08:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Changed to set $L.state.name if "State" in record changes.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/11/16 08:03:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified apm.yes.no panels to have a message level of 3.</rev.desc>
        </rev.desc>
        <change.no type="decimal">15081</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">01/11/03 08:30:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will reset the mode to the base mode when moving between records.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/22/05 07:51:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified to turn off reclist if mode#"add".</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/22/04 08:37:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified so that a saved action will process if the exit from previous action is NULL or "normal".</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/20/06 14:43:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added capability for lock on display.</rev.desc>
        </rev.desc>
        <change.no type="decimal">16443</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/21/05 08:58:12</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will now only continue with a saved action if the exit of the previous action was "normal".</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/19/27 16:04:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified to not prompt for save on U-turn arrow.  The RTE now handles this.</rev.desc>
        </rev.desc>
        <change.no type="decimal">15776</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/19/04 02:28:11</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Changed call to fduplicate to :  $L.void=rtecall("copycurrent", $L.errcode, $L.file.save, $L.file)</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/19/00 06:49:27</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Cursor position is kept when doing a validity lookup.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/18/23 09:10:57</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">On decide.process.exit.1 changed the condition to check for a State change from a ~= to a same().  Because same() will give a false result for a comparison to NULL while = gives unknown.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/18/22 06:08:20</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will now get the parent and put it into $L.parent even when not locked.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/18/10 04:19:18</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added a "deleted" exit that will check for a lock, unlock if necessary, and then reposition.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/17/10 06:21:50</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will not prompt for save if the "update" field in the environment record evaluates to false.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/16/26 09:28:47</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will correctly parse qbe format name if it is a variable.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/16/20 07:40:17</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added $L.related.id and $L.related.filename to list of engine variables passed to display and se.call.process.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">12/16/06 08:23:04</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Removed $L.same=same($L.file, $L.file.save) from after.process.  Turns out that it wasn't necessary.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/16/06 07:15:21</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added a "setupadd" exit that doesn't go back through the reselect RTE call, otherwise same as reselect.  Just that the record hasn't been added yet so it can't be reselected.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">12/16/06 06:53:05</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">On after.process, reset $L.same after a process is called.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/16/01 09:57:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added initial format control functionality.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/16/01 08:21:23</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Perform a get.base.form.name on $L.format to get correct format control and link records.</rev.desc>
        </rev.desc>
        <change.no type="decimal">4466</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/15/26 08:44:22</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added $L.exit.when.done to list of variables that are passed in and out of processes.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">12/15/25 06:41:31</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Nullsub'd default.object in $L.object to false in statements on panels get.format and duplicate.record.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/15/24 08:37:11</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">On the duplicate record panel, nullsubed the open and close states with the default state...</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/15/24 06:27:37</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Moved $L.locked=false to the start panel from setup.vars.  Had to do this for Change to support phase changes.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/15/23 08:40:10</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added $L.messages to the parameters passed to a process.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">joeh</rev.name>
        <rev.date type="dateTime">12/15/23 04:09:37</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">changes for outputing error codes from triggers</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/15/18 08:26:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Now passes $L.file.save to the display app.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/15/18 07:28:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Initial process may now modify the $L.format variable, and if so the $L.fc.name variable is updated.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/15/11 03:59:19</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Same change as below, except for Phase.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/15/11 03:50:17</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will not send the "Category does not exist" message if the mode is "add"</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">12/14/27 10:57:18</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added a post-process exit ("openstate") that sets $L.mode to "add" .</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">12/14/25 09:37:41</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Now calls format.cdis on the master format control.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">Phil</rev.name>
        <rev.date type="dateTime">12/14/20 08:46:17</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added unlocking when $L.exit="restart" and there is a lock.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">12/14/20 08:34:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">When $L.exit="closestate", set $L.mode="close" and the State to the close.state.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">Phil</rev.name>
        <rev.date type="dateTime">12/14/19 08:05:54</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added functionaltiy for qopensave so that it will go to a new view of a record after re-qopening a last call record.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/14/19 02:29:30</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will pass a value of true in the variable "$L.engine" to display.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/14/10 03:43:56</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed the check for State to use the open.state for records that do not have a State field when the $L.mode="add".</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">12/11/22 12:55:28</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Don't display the title if the unique key has more than one field.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/11/16 15:17:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added a not authorized message.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/11/16 13:15:56</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Cleaned up delete behavior in non record list mode.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/11/14 12:01:11</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed so $L.file.save is recreated when you refresh a list in record list mode.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/11/14 11:50:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added functionality to check for $G.prompt.for.save for next, previous, and cancel.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/11/03 14:32:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">deleted a fduplicate call that screwed up the file variable.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/12/00 07:36:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added rte calls so that it was only necessary to fetch a record once.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/10/20 14:32:33</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed the way pagelists chose their format so that the last change no longer causes pagelists to always pick the file name.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">12/10/11 14:17:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Fixed a typo that did not allow a stored format name to be used.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added support for files with no unique keys.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added the functionality to run a script when prompted by format control.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified the "normal" exit from a process to call the format control display app before returning to display proper.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">Phil</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added rtecall for recordsize, to check that the record size is not larger than use defined value.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">joeh</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified return action so that it will return $L.action.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">joeh</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified get.format panel to pass $L.mode into the call.init.process panel via $L.value.names and $L.values</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">joeh</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Changed  it so that it uses new $L.action="addsave"  This adds  a new record, and then exits without displaying the record again.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">joeh</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Changed panel "get.format" to use file.name in $L.object instead of object.name in $L.object.  (object.name wasn't in the dbdict.)</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array"/>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array"/>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array"/>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date NullValue="1" type="dateTime"/>
        <rev.desc sctype="array"/>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rmurray</rev.name>
        <rev.date type="dateTime">04/16/10 03:50:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">f</rev.desc>
        </rev.desc>
        <change.no type="decimal">0</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/16/03 06:21:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">fr</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">04/15/02 23:56:32</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">fro</rev.desc>
        </rev.desc>
        <change.no type="decimal">33639</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/14/16 14:32:10</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/13/26 15:53:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">04/12/29 14:19:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from d</rev.desc>
        </rev.desc>
        <change.no type="decimal">34944</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">04/12/21 15:44:22</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from de</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">joeh</rev.name>
        <rev.date type="dateTime">04/12/21 15:20:45</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from dev</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">04/12/12 13:58:21</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from devt</rev.desc>
        </rev.desc>
        <change.no type="decimal">34444</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">04/12/08 14:23:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from devtx</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">03/24/12 11:12:17</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from devtx:</rev.desc>
        </rev.desc>
        <change.no type="decimal">33688</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">03/23/23 10:32:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from devtx</rev.desc>
        </rev.desc>
        <change.no type="decimal">33688</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">03/23/14 04:56:20</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from devtx.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">03/23/08 12:40:18</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">from devtx.</rev.desc>
        </rev.desc>
        <change.no type="decimal">32884</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">03/21/26 09:51:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">rom devtx.</rev.desc>
        </rev.desc>
        <change.no type="decimal">25272</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">03/21/21 06:14:03</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">om devtx.</rev.desc>
        </rev.desc>
        <change.no type="decimal">28058</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">03/21/14 04:57:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">m devtx.</rev.desc>
        </rev.desc>
        <change.no type="decimal">32597</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">03/19/01 11:56:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx.</rev.desc>
        </rev.desc>
        <change.no type="decimal">32523</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">03/17/25 03:41:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx.</rev.desc>
        </rev.desc>
        <change.no type="decimal">14580</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">03/17/24 09:22:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx</rev.desc>
        </rev.desc>
        <change.no type="decimal">14718</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">03/17/24 08:52:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">03/17/24 06:19:33</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx t</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">03/17/23 05:19:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ti</rev.desc>
        </rev.desc>
        <change.no type="decimal">14701</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">03/17/18 12:46:26</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx tic</rev.desc>
        </rev.desc>
        <change.no type="decimal">14655</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">03/17/17 11:29:31</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx tick</rev.desc>
        </rev.desc>
        <change.no type="decimal">14636</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">03/13/02 18:42:37</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticke</rev.desc>
        </rev.desc>
        <change.no type="decimal">28389</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">03/16/23 10:27:44</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket</rev.desc>
        </rev.desc>
        <change.no type="decimal">14277</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">03/15/25 10:30:07</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket</rev.desc>
        </rev.desc>
        <change.no type="decimal">28389</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">03/14/24 11:01:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket -</rev.desc>
        </rev.desc>
        <change.no type="decimal">25139</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">03/13/17 14:46:33</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket -</rev.desc>
        </rev.desc>
        <change.no type="decimal">12198</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">03/13/16 14:05:05</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket - changing count panel to use apm.count.records (like in se.list.engine) instead of count.records to eliminate the "do you really want to count all the records" prompt.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">03/13/09 18:58:58</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket - changng count panel to use apm.count.records (like in se.list.engine) instead of count.records to eliminate the "do you really want to count all the records" prompt.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/19/31 23:05:28</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket - changg count panel to use apm.count.records (like in se.list.engine) instead of count.records to eliminate the "do you really want to count all the records" prompt.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/17/27 11:39:59</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket - chang count panel to use apm.count.records (like in se.list.engine) instead of count.records to eliminate the "do you really want to count all the records" prompt.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">02/17/19 16:41:36</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket - change count panel to use apm.count.records (like in se.list.engine) instead of count.records to eliminate the "do you really want to count all the records" prompt.</rev.desc>
        </rev.desc>
        <change.no type="decimal">28441</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">02/17/29 07:37:17</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">devtx ticket - changed count panel to use apm.count.records (like in se.list.engine) instead of count.records to eliminate the "do you really want to count all the records" prompt.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
    </rev.array>
    <descript sctype="array">
      <descript sctype="string">update panel after.process, improve comments</descript>
      <descript sctype="string">panel: check.base.exit.</descript>
      <descript sctype="string">panel:check.base.exit.1</descript>
      <descript sctype="string">Add a branch for background schedule to avoid dead loops.</descript>
      <descript sctype="string">update panel setup.tableAccess, change code from</descript>
      <descript sctype="string">if $L.soap then ($L.file.temp=$L.file.save)</descript>
      <descript sctype="string">to:</descript>
      <descript sctype="string">if ($L.soap and $L.mode="update") then ($L.file.temp=$L.file.save)</descript>
      <descript sctype="string">Panel: check.get.phase</descript>
      <descript sctype="string">Fix the phase when the phase is WorkflowPhase.</descript>
      <descript sctype="string">For joined ci types</descript>
      <descript sctype="string">Panel: setup.vars</descript>
      <descript sctype="string">CI which type is joined workflow phase is not correct.</descript>
      <descript sctype="string">Panel: duplicate.record</descript>
      <descript sctype="string">Set $L.file back to $L.list when do add action.</descript>
      <descript sctype="string">Panel: exit.normal</descript>
      <descript sctype="string">when setback is true return $L.list.temp.</descript>
      <descript sctype="string">Panel: change.wfPhase</descript>
      <descript sctype="string">So in RAD se.view.engine, panel change.wfPhase, it should check the phase.file.name, if it is still using WorkflowPhase, just assign $L.wfPhase to $L.phase instead of query again.</descript>
      <descript sctype="string">add panel reset.tableAccess.after.save, reset table access in lock mode</descript>
      <descript sctype="string">The change task category list on dynamic search page are hard code strings.</descript>
      <descript sctype="string">Make the title localized</descript>
      <descript sctype="string">delete panel reset.tableAccess, update panel setup.tableAccess to improve webservice tableAccess</descript>
      <descript sctype="string">Transition not tracked in timeDuration4request</descript>
      <descript sctype="string">Add a button to refresh the record and its phase of workflow</descript>
      <descript sctype="string">Copy Record Option in Change Management Saves the new Change Automatically</descript>
      <descript sctype="string">update start panel, support $G.de.view.thread</descript>
      <descript sctype="string">add panel reset.tableAccess</descript>
      <descript sctype="string">Panel:post.display</descript>
      <descript sctype="string">Line 10:</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull(watch.variables in $L.object)) do (if ($L.i in watch.variables in $L.object)#"$" then if (not  (null(evaluate(parse($L.i in watch.variables in $L.object, 2))))) then ($L.same=false))</descript>
      <descript sctype="string"/>
      <descript sctype="string">Copied to panel:after.process</descript>
      <descript sctype="string">Line 10:</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull(watch.variables in $L.object)) do (if ($L.i in watch.variables in $L.object)#"$" then if (not  (null(evaluate(parse($L.i in watch.variables in $L.object, 2))))) then ($L.same=false))</descript>
      <descript sctype="string">Against file.save to check folder rights.</descript>
      <descript sctype="string">Security role doesn't work correctly for some scenario when the Update right is "When Assigned to workgroup"</descript>
      <descript sctype="string">User could not switch CI ticket after refresh the list</descript>
      <descript sctype="string">change the frefresh parameter from $L.file to $L.list</descript>
      <descript sctype="string">update panel no.bg.auth, change msg to:</descript>
      <descript sctype="string">$L.no.auth.msg=scmsg(15, "doceng", {operator(), filename($L.file), $L.action})</descript>
      <descript sctype="string">QCCR1E125371 Indexing into a unknown type datum which is not a compound data type (Ruleset.run,run.javascript)</descript>
      <descript sctype="string">remove the wrong calling setsort after call frefresh</descript>
      <descript sctype="string">QCCR1E124646, The invalide value of a ci field is not cleared when you cancel the current thread</descript>
      <descript sctype="string">Modified the panel check.unlock.object by adding expression of $L.void=display.value.copy($L.file, $L.file.save) to make display value clean</descript>
      <descript sctype="string">QCCR1E124501, approval in current phase is not triggered when auto transition move to next phase when optimize save enabled.</descript>
      <descript sctype="string">QCCR1E123449, CI update value is not displayed after change device type.</descript>
      <descript sctype="string">QCCR1E123403, The page return to the list from qbe when fail to save&amp;exit for NONPD</descript>
      <descript sctype="string">QCCR1E123798, $L.phase value is incorrect on display when add incident but failed validation on default transition.</descript>
      <descript sctype="string">QCCR1E123162, search ticket from foreground, oldrecord phase and field value is null on init state.</descript>
      <descript sctype="string">QCCR1E123587, $L.wfPhase and $L.wfPhase.save are incorrect if enable optimize save for auto-transition.</descript>
      <descript sctype="string">QCCR1E123584, object varaiable cannot be shared between each rule states</descript>
      <descript sctype="string">QCCR1E122997, [Performance Improvement] enhance the rule type "validate against table", to ignore the validation if the value is not changed</descript>
      <descript sctype="string">-- make sure the $L.file.save is not the same as $L.file while adding the record from backend.</descript>
      <descript sctype="string">QCCR1E123011, In the PD wrapper migrated workflow, directly put the workflow subform into the non-PD forms does not work.</descript>
      <descript sctype="string">Make sure the display rules are executed after us.find.</descript>
      <descript sctype="string">[Performance Improvement] merge 2 save into 1 save for auto-transition</descript>
      <descript sctype="string">When doing "refresh" action, calling frefresh RTE functions instead of select function</descript>
      <descript sctype="string">CI logical.name value is not in creating CI response. Adde one line in panel of exit.normal</descript>
      <descript sctype="string">if ($L.action="add" and $L.soap="true") then ($INTO.LIST=$L.file)</descript>
      <descript sctype="string">support PD wrapper to make sure the ruleset on generated workflow working.</descript>
      <descript sctype="string">Unrecoverable error occurs when click back on solution matching window which is using the generated workflow</descript>
      <descript sctype="string">support legacy workflow options to enahnce for wrapper PD</descript>
      <descript sctype="string">fix the issue that the format level fc is not invoked if format is the same as file name and the record has workflow</descript>
      <descript sctype="string">SM 9.33+PDCP3: $L.phase variable is not available in "On display" stage</descript>
      <descript sctype="string">use setvariables and getvariables to avoid too many parse/evaluate call which cause performance issue.</descript>
      <descript sctype="string">update panel: run.display.rules.1,run.event.rules,run.init.rules</descript>
      <descript sctype="string">change jump out exit to "decide.unlock"</descript>
      <descript sctype="string">Interaction - Interaction shouldn't be locked after jump to itil record from interaction</descript>
      <descript sctype="string">Page hangs after invoking the save button of a PD request form.</descript>
      <descript sctype="string">Workflow Engine - Cannot auto move multiple phases at one time from webservice.</descript>
      <descript sctype="string">Issue for "save record prior to transition"</descript>
      <descript sctype="string">Change Problem Category on Categorization phase, 'Problem record updated' are print twice.</descript>
      <descript sctype="string">The scheduled report schedule can't be edited after click submited for Re-Planning</descript>
      <descript sctype="string">-- fix the issue that the init process is not run after changing the phase manually if "Lock on display" in object is set to true.</descript>
      <descript sctype="string">support CurrentWFPhase and SaveWFPhase in condition editor.</descript>
      <descript sctype="string">support table level rulesets/actions</descript>
      <descript sctype="string">add a new property "mtRunSaveBefore" in manualTransion</descript>
      <descript sctype="string">fix an issue that the backend transition should not save the record first at from phase.</descript>
      <descript sctype="string">fix a regress that the display rules are not executed if the $L.bg.action is null.</descript>
      <descript sctype="string">support conditional display form</descript>
      <descript sctype="string">save the record first before manually moving phase</descript>
      <descript sctype="string">add workflow level on-enter and on-exit</descript>
      <descript sctype="string">Rulesets run more times than expected</descript>
      <descript sctype="string">Format for record is incorrect when stop on auto transition then do save.</descript>
      <descript sctype="string">Can't create incident via web service if category not specified.</descript>
      <descript sctype="string">Change the logic to make sure the WSDL expression is evaluated before getting category.</descript>
      <descript sctype="string">treat as true if the backend transition condition is not set.</descript>
      <descript sctype="string">add btAction for backend transition configuration.</descript>
      <descript sctype="string">90568 and 90567, to support the cross table fileds and user option in conditiion editor.</descript>
      <descript sctype="string">set new parameter value to "exit.normal" in 3 Ruleset.runMultiple panels.</descript>
      <descript sctype="string">change panel decide.process.exit, add one more wfMode "save" in check condition, so that for bad validation, it will rollback the phase change.</descript>
      <descript sctype="string">if ($L.exit="bad.val" and $L.wfMode={"open", "save", "close"}) then ...</descript>
      <descript sctype="string">It is incorrect to clone the first or last interaction uses mode 'browse' instead of 'addclone' when click Previous or Next on the new record</descript>
      <descript sctype="string">panel:change.wfPhase</descript>
      <descript sctype="string">change to onexit and transition use the prev phase instead of next phase.</descript>
      <descript sctype="string">panel:change.wfPhase</descript>
      <descript sctype="string">issue is caused by array1 + denull(array2) will be null, use denull(nullsub(arrays),{})</descript>
      <descript sctype="string">panel:get.format</descript>
      <descript sctype="string">if master.fc is not set in object, don't use file based fc.</descript>
      <descript sctype="string">panel:check.get.phase,  set.workflow.flag</descript>
      <descript sctype="string">if $L.bg unable to find workflow, print error message.</descript>
      <descript sctype="string">panel:after.prompt.action,setup.tableAccess,check.get.parent,jump.back</descript>
      <descript sctype="string">If use don't have view right, avoid they open the record.</descript>
      <descript sctype="string">panel: start</descript>
      <descript sctype="string">set no.auth message based on filename scmsg</descript>
      <descript sctype="string">panel: start</descript>
      <descript sctype="string">set no.auth message based on filename</descript>
      <descript sctype="string">Rad error is shown while save the incident after perform cancel.</descript>
      <descript sctype="string">if the $L.mode#"add", use action="add" instead.</descript>
      <descript sctype="string">add backend event support empty to phase, so that only the transition rule will be executed.</descript>
      <descript sctype="string">panel change.wfPhase,decide.after.event,display.decide,run.event.rules,set.bg.action,setup.runEvent</descript>
      <descript sctype="string">Add support for backend event.</descript>
      <descript sctype="string">post.auto.transitions/run.display.rules/setup.init.rules</descript>
      <descript sctype="string">Change panle to</descript>
      <descript sctype="string">Change to auto transition initial and display rule.</descript>
      <descript sctype="string">Global add -&gt; Phase enter -&gt;Update Record -&gt; Global after successful add -&gt;  Global Initial  -&gt;  Phase Initial  -&gt;Global Display -&gt;Next Phase Display -&gt;  Phase  exit  -&gt; Transition-&gt;  Next Phase Enter -&gt;Update Record -&gt;Global Display -&gt;Next  Phase Display</descript>
      <descript sctype="string">change to logic to support exist -&gt; transition( manul, auto, defalut) -&gt; enter ruleset when phase changed.</descript>
      <descript sctype="string">add $bypass.bg.authcheck for backend by pass the security validation.</descript>
      <descript sctype="string">QCRQ1E65843: Task4: Move the RAD applications modified by the PD team from Perforce to SVN 	QC Ref.	QCCR1E68080- Changes for Last Task ProcessingQC Ref.	QCCR1E68359 - System becomes locked after the "Record has been Modified" message.QC Ref.	QCCR1E69197 - If a rule on a transition fails, hitting Save will re-run the transtion rules.QC Ref.	QCCR69479 - Alternate forms not working.QC Ref.	QCCR69516 - Open New Task option is not available on all workflow phases [PS Labs Issues #7515/7518]QC Ref.	QCCR1E70087 - Fixed issue:  when user attempts a phase change that fails (due to rules or fc), the phase must revert back to the original phase.Panel:	sync.category.phaseChange:	Changed the exit from duplicate.record to get.workflow.phase		Panel:	check.non.guiChange:	Changed the following condition from:	$L.action="reselect" and not $L.lock.on.display	To:	$L.action="reselect" and not $L.lock.on.display and $L.locked		Panel:	post.displayChange:	Added the following expression:	$L.wfRules={}		Panel:	display.decideChange:	Added a new exit to the "setup.altForm" panel		Panel:	setup.altFormChange:	New process panel		Panel:	setup.init.rulesChange:	Changed the following expressions from:	$L.init.value.names={"$L.format", "$L.title", "$L.parent", "$L.wfPhase", "$L.action"}+$L.value.names	$L.init.values={$L.format, $L.title, $L.parent, $L.wfPhase, $L.action}+$L.values	To:	if null(init.process in $L.state) then ($L.init.value.names={"$L.format", "$L.title", "$L.parent", "$L.wfPhase", "$L.action"}+$L.value.names;$L.init.values={$L.format, $L.title, $L.parent, $L.wfPhase, $L.action}+$L.values)		Panel:	check.base.exitChange:	Changed expession from:	if ($L.exit="bad.val" and $L.wfMode="open") then if (not same(current.phase in $L.file, current.phase in $L.file.save)) then (current.phase in $L.file=current.phase in $L.file.save;contents($L.wfPhase)=contents($L.wfPhase.save)) else ($L.wfPhase=3 in $L.cat.vars)	To:	if ($L.exit="bad.val" and $L.wfMode={"open", "close"}) then if (not same(current.phase in $L.file, current.phase in $L.file.save)) then (current.phase in $L.file=current.phase in $L.file.save;contents($L.wfPhase)=contents($L.wfPhase.save)) else ($L.wfPhase=3 in $L.cat.vars)		Panel:	decide.process.exitChange:	Changed expession from:	if ($L.exit="bad.val" and $L.wfMode="open") then if (not same(current.phase in $L.file, current.phase in $L.file.save)) then (current.phase in $L.file=current.phase in $L.file.save;contents($L.wfPhase)=contents($L.wfPhase.save))	To:	if ($L.exit="bad.val" and $L.wfMode={"open", "close"}) then if (not same(current.phase in $L.file, current.phase in $L.file.save)) then (current.phase in $L.file=current.phase in $L.file.save;contents($L.wfPhase)=contents($L.wfPhase.save))				Records are not unlocked by se.view.engine when a doAction("save") fails due to a Format Control Validation.</descript>
      <descript sctype="string">In se.view.engine, change the exit for Condition "$L.exit="bad.val" and $L.bg" of panel check.base.exit.1</descript>
      <descript sctype="string">from exit.normal to check.locked.bg</descript>
      <descript sctype="string">duplicating an interaction doesn't take the user to open interaction format</descript>
      <descript sctype="string">$L.action variable is missing, add it in Panel call.init.process and setup.init.rules</descript>
      <descript sctype="string">Added $L.orig.format to variables passed to se.call.process.</descript>
      <descript sctype="string">Same as below for save process.</descript>
      <descript sctype="string">When running a phase change during open that has an associated process, the phase needs to be reset if there is a bad validation.</descript>
      <descript sctype="string">If the first action (add action) is a Workflow phase change, the logic needs to check for an "add" process rather than always doing a base method add.</descript>
      <descript sctype="string">QCCRID: 66761</descript>
      <descript sctype="string"/>
      <descript sctype="string">In panel "exit.normal", added a  line to allow for when $exit is "error":</descript>
      <descript sctype="string"/>
      <descript sctype="string">if ($exit="error") then ($L.exit="error")</descript>
      <descript sctype="string">QCCR1E66303-When Folder Entitlement is enabled in the Incident Management Profile, the rights defined in "Update" are affecting the rights defined in "New"</descript>
      <descript sctype="string"/>
      <descript sctype="string">RAD: se.view.engine</descript>
      <descript sctype="string">panel: check.folders</descript>
      <descript sctype="string">add $L.mode into label param: Mode</descript>
      <descript sctype="string">Modify set.auto.transition panel so that we will call the right process</descript>
      <descript sctype="string">Modified the call on get.format to use str() rather than parse().  Evaluating the condition without it would try to run the expression instead of find the logical evaluation.</descript>
      <descript sctype="string">Removing parse of the updateCond from the get.format of WorkflowPhase.</descript>
      <descript sctype="string">Adding back the parse of the condition from the Workflow Phase (was removed).</descript>
      <descript sctype="string">Hua:passing object record when calling rules</descript>
      <descript sctype="string">Recompiled application to solve an issue created by the Changelist 249551 checked in for CR62662.</descript>
      <descript sctype="string">Resubmitted the 4 previous history changes.</descript>
      <descript sctype="string">PETE BUDIC's change:</descript>
      <descript sctype="string">QC63087 - Protect against auto/default transitions that create a circular loop (so we don't hang the server).</descript>
      <descript sctype="string">If a workflow has circular logic with auto/default transitions, stop the auto transitions as soon as the record ends up back in its original phase.</descript>
      <descript sctype="string">XIA XING (Wayne)'s change:</descript>
      <descript sctype="string">panel: post.cancel</descript>
      <descript sctype="string">unlock.object   $L.action~={"find", "pagelist", "listpages"} and $L.locked and use.locking in $L.object</descript>
      <descript sctype="string">setup.reselect  $L.action="refresh"</descript>
      <descript sctype="string">clear         $L.action="clear"</descript>
      <descript sctype="string">check.master.display  $L.action={"find", "pagelist", "listpages"} and $L.locked and use.locking in $L.object</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel: goto.menu.exit</descript>
      <descript sctype="string">added statements:</descript>
      <descript sctype="string">for $L.x = 1 to lng($L.temp.watch) do ($L.temp=1 in $L.x in $L.temp.watch+"=2 in $L.x in $L.temp.watch";$L.void=evaluate(parse($L.temp)))</descript>
      <descript sctype="string">for $L.x = 1 to lng($L.temp.locals) do ($L.temp=1 in $L.x in $L.temp.locals+"=2 in $L.x in $L.temp.locals";$L.void=evaluate(parse($L.temp)))</descript>
      <descript sctype="string">HUA ZHANG's change:</descript>
      <descript sctype="string">fix the issue where deleted default transition is still running</descript>
      <descript sctype="string">RAMURO@ROOPA's change:</descript>
      <descript sctype="string">Recompilation - Added the parse function when checking auto transition conditions on post.auto.transition.</descript>
      <descript sctype="string">Added ability to run transitions and actions in background.</descript>
      <descript sctype="string">Fixed running post actions when an Action is complete.</descript>
      <descript sctype="string">Use the update condition from the workflow phase record if one exists (defaulted to true).</descript>
      <descript sctype="string">Accept $L.exit.when.done if changed in rules.</descript>
      <descript sctype="string">Allow Workflow Phase records to specify variables as formats (such as format in $L.category)</descript>
      <descript sctype="string">Default format to table name if null.  Also made check for sysrestricted more efficient by checking if field exists first.</descript>
      <descript sctype="string">Added $L.allow.edit.system to the list of variables passed to display.</descript>
      <descript sctype="string">Modify the  condition in decide.process.exit.1 panel  for Setup.reselect</descript>
      <descript sctype="string">from  [$L.exit="added"] to  [ $L.exit="added" or $L.exit="reselect"]</descript>
      <descript sctype="string">Modify the check.non.gui  add  'and use.locking in $L.object' for Lock.on.display</descript>
      <descript sctype="string">Hua: support workflow based approvals</descript>
      <descript sctype="string">replace test js with a real rte call on panel get.format</descript>
      <descript sctype="string">add a hook in get.format to check for auth bit when hpsystem field is set</descript>
      <descript sctype="string">add the following condition in check.post.auto.transitions</descript>
      <descript sctype="string"/>
      <descript sctype="string">and $L.has.workflow</descript>
      <descript sctype="string">on panel check.get.workflowPhase, added a condition for get.workflow.phase exit</descript>
      <descript sctype="string">Story: 26536 - Enhanced Application Framework (EAF)</descript>
      <descript sctype="string">45871 - merge EAF code to Henry branch</descript>
      <descript sctype="string">Task: 46242 - DEV:  load in eafDocEngine unload</descript>
      <descript sctype="string">Panel:   after.process.check</descript>
      <descript sctype="string">Changed exit from:</descript>
      <descript sctype="string">decide.process.exit</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">check.post.auto.transitions</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   after.prompt.action.1</descript>
      <descript sctype="string">New exit added:</descript>
      <descript sctype="string">check.get.phase</descript>
      <descript sctype="string">Condition:</descript>
      <descript sctype="string">exists("current.phase", $L.file) and not null($L.wfPhase) and type($L.wfPhase)=6 and not same(current.phase in $L.file, name in $L.wfPhase)</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   call.base.method</descript>
      <descript sctype="string">Changed the following expression:</descript>
      <descript sctype="string">From:</descript>
      <descript sctype="string">$L.base.vars={$L.object.name, $L.save.mode, $L.orig.format, $L.category, $L.phase, $L.parent}</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.base.var.names={"$L.object.name", "$L.save.mode", "$L.orig.format", "$L.parent", "$L.exit.when.done", "$L.messages", "$L.dd.reclist", "$L.wfType", "$L.wfRules", "$L.wfMode", "$L.category", "$L.phase", "$L.wfPhase"}</descript>
      <descript sctype="string">$L.base.var.names=$L.base.var.names+denull($L.object.names)</descript>
      <descript sctype="string">$L.base.var.names=$L.base.var.names+$L.tableAccess.names</descript>
      <descript sctype="string">$L.base.values={}</descript>
      <descript sctype="string">for $L.i = 1 to lng($L.base.var.names) do ($L.i in $L.base.values=evaluate(parse($L.i in $L.base.var.names, 2)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.cat.vars={$L.category, $L.phase, $L.wfPhase}</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   call.base.method.1</descript>
      <descript sctype="string">Changed the following values:</descript>
      <descript sctype="string">From:</descript>
      <descript sctype="string">$L.base.vars</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.base.var.names</descript>
      <descript sctype="string">From:</descript>
      <descript sctype="string">{$L.category, $L.phase}</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.cat.vars</descript>
      <descript sctype="string">From:</descript>
      <descript sctype="string">&lt;blank on Variable Values&gt;</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.base.values</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   call.fc.display</descript>
      <descript sctype="string">Changed exit from:</descript>
      <descript sctype="string">display</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">run.display.rules</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   call.init.process</descript>
      <descript sctype="string">Changed expressions from:</descript>
      <descript sctype="string">$L.init.value.names={"$L.format", "$L.title", "$L.parent", "$L.action"}+$L.value.names</descript>
      <descript sctype="string">$L.init.values={$L.format, $L.title, $L.parent, $L.action}+$L.values</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.init.value.names={"$L.format", "$L.title", "$L.parent", "$L.wfPhase"}+$L.value.names</descript>
      <descript sctype="string">$L.init.values={$L.format, $L.title, $L.parent, $L.wfPhase}+$L.values</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   check.base.exit</descript>
      <descript sctype="string">Added the following expressions:</descript>
      <descript sctype="string">if ($L.exit="bad.val" and $L.wfMode="open") then if (not same(current.phase in $L.file, current.phase in $L.file.save)) then (current.phase in $L.file=current.phase in $L.file.save)</descript>
      <descript sctype="string">$L.wfMode=NULL;$L.wfType=NULL</descript>
      <descript sctype="string">$L.wfPhase=3 in $L.cat.vars</descript>
      <descript sctype="string">if ($L.exit="wfPhaseChange") then ($L.exit="resetrec")</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   check.base.exit.1</descript>
      <descript sctype="string">New exit added:</descript>
      <descript sctype="string">post.auto.transitions</descript>
      <descript sctype="string">Condition:</descript>
      <descript sctype="string">$L.has.workflow</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   check.bg</descript>
      <descript sctype="string">New exit added:</descript>
      <descript sctype="string">set.auto.phaseChange</descript>
      <descript sctype="string">Condition:</descript>
      <descript sctype="string">nullsub($L.wfAuto, false)=true</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   check.get.phase</descript>
      <descript sctype="string">Changed exit from:</descript>
      <descript sctype="string">decide.get.record</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">check.get.workflowPhase</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   check.init.process</descript>
      <descript sctype="string">Changed exit from:</descript>
      <descript sctype="string">get.format</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">setup.init.rules</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   check.no.phase</descript>
      <descript sctype="string">Changed exit from:</descript>
      <descript sctype="string">decide.get.record</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">check.get.workflowPhase</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   create.file.save</descript>
      <descript sctype="string">Changed expression from:</descript>
      <descript sctype="string">$L.copy=evaluate($L.copy) and $L.mode~="addsave"</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.copy=evaluate($L.copy) and $L.mode~="addsave" and nullsub($L.wfAuto, false)=false</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   display</descript>
      <descript sctype="string">Added the following expresssion:</descript>
      <descript sctype="string">$L.exit="normal"</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   display.decide</descript>
      <descript sctype="string">Added the following new exits:</descript>
      <descript sctype="string">Exit:</descript>
      <descript sctype="string">change.wfPhase</descript>
      <descript sctype="string">Condition:</descript>
      <descript sctype="string">$L.action="wfPhaseChange"</descript>
      <descript sctype="string">Exit:</descript>
      <descript sctype="string">setup.runAction</descript>
      <descript sctype="string">Condition:</descript>
      <descript sctype="string">$L.action="runAction"</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   display.go</descript>
      <descript sctype="string">Changed the array of local variables from:</descript>
      <descript sctype="string">{$L.dd.reclist, $L.qbe.name, $L.list, $L.locked, $L.allow.input, $L.format, $L.fc, $L.object, $L.env, $L.site, $L.modify, $L.mode, $L.mult, $L.lock.name, $L.title, $L.category, $L.phase, $L.has.link, $L.se.pagelist, true, $L.related.filename, $L.related.id, $L.parent, $L.mod.columns, $L.view}+$L.values</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">{$L.dd.reclist, $L.qbe.name, $L.list, $L.locked, $L.allow.input, $L.format, $L.fc, $L.object, $L.env, $L.site, $L.modify, $L.mode, $L.mult, $L.lock.name, $L.title, $L.category, $L.phase, $L.has.link, $L.se.pagelist, true, $L.related.filename, $L.related.id, $L.parent, $L.mod.columns, $L.view, $L.wfPhase, $L.wfMode}+$L.values</descript>
      <descript sctype="string">From:</descript>
      <descript sctype="string">{"$L.dd.reclist", "$L.dd.qbe.format", "$L.dd.traverse.list", "$L.locked", "$L.allow.input", "$L.format", "$L.fc", "$L.object", "$L.env", "$L.site", "$L.modify", "$L.mode", "$L.mult", "$L.lock.name", "$L.title", "$L.category", "$L.phase", "$L.has.link", "$L.se.pagelist", "$L.engine", "$L.related.filename", "$L.related.id", "$L.parent", "$L.mod.columns", "$L.dd.view"}+$L.value.names</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">{"$L.dd.reclist", "$L.dd.qbe.format", "$L.dd.traverse.list", "$L.locked", "$L.allow.input", "$L.format", "$L.fc", "$L.object", "$L.env", "$L.site", "$L.modify", "$L.mode", "$L.mult", "$L.lock.name", "$L.title", "$L.category", "$L.phase", "$L.has.link", "$L.se.pagelist", "$L.engine", "$L.related.filename", "$L.related.id", "$L.parent", "$L.mod.columns", "$L.dd.view", "$L.wfPhase", "$L.wfMode"}+$L.value.names</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   get.format</descript>
      <descript sctype="string">Added the following expression:</descript>
      <descript sctype="string">if (not null($L.wfPhase) and not null(displayForm in $L.wfPhase)) then ($L.format=displayForm in $L.wfPhase)</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   get.phase</descript>
      <descript sctype="string">Changed exit from:</descript>
      <descript sctype="string">decide.get.record</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">check.get.workflowPhase</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   no.phase.1</descript>
      <descript sctype="string">Changed exit from:</descript>
      <descript sctype="string">decide.get.record</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">check.get.workflowPhase</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   prepare.process</descript>
      <descript sctype="string">Changed expression from:</descript>
      <descript sctype="string">$L.value.names=$L.object.names+{"$L.fc", "$L.exit", "$L.file.save", "$L.action", "$L.mode", "$L.exit.when.done", "$L.related.filename", "$L.related.id", "$L.parent", "$L.messages", "$L.fc.master", "$L.dd.reclist", "$L.format", "$L.category", "$L.phase"}+$L.tableAccess.names</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.value.names=$L.object.names+{"$L.fc", "$L.exit", "$L.file.save", "$L.action", "$L.mode", "$L.exit.when.done", "$L.related.filename", "$L.related.id", "$L.parent", "$L.messages", "$L.fc.master", "$L.dd.reclist", "$L.format", "$L.wfType", "$L.wfRules", "$L.wfMode", "$L.wfPhase"}+$L.tableAccess.names</descript>
      <descript sctype="string"/>
      <descript sctype="string">Added the following expression:</descript>
      <descript sctype="string">$L.cat.vars={$L.object, $L.category, $L.phase, $L.wfPhase}</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   return.init.values</descript>
      <descript sctype="string">Changed exit from:</descript>
      <descript sctype="string">get.format</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">setup.init.rules</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   set.values</descript>
      <descript sctype="string">Changed expression from:</descript>
      <descript sctype="string">$L.tableAccess.names={"$L.tableAccess.view", "$L.tableAccess.new", "$L.tableAccess.close", "$L.tableAccess.delete", "$L.tableAccess.update", "$L.tableAccess.folders"}</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.tableAccess.names={"$L.tableAccess.view", "$L.tableAccess.new", "$L.tableAccess.close", "$L.tableAccess.delete", "$L.tableAccess.update", "$L.tableAccess.folders", "$L.tableAccess.expert", "$L.tableAccess.admin"}</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   setup.tableAccess</descript>
      <descript sctype="string">New expression added:</descript>
      <descript sctype="string">if (filename($L.env)="tableAccess") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, $L.env, $L.object, $L.folder.exists))</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel:   setup.vars</descript>
      <descript sctype="string">New expressions added:</descript>
      <descript sctype="string">$L.has.workflow=false</descript>
      <descript sctype="string">$L.wfAuto=false</descript>
      <descript sctype="string">$L.wfAutoPhase=false</descript>
      <descript sctype="string">$L.wfAutoRules={}</descript>
      <descript sctype="string"/>
      <descript sctype="string">Added the following panels:</descript>
      <descript sctype="string">after.display.rules</descript>
      <descript sctype="string">change.wfPhase</descript>
      <descript sctype="string">check.auto.transition</descript>
      <descript sctype="string">check.current</descript>
      <descript sctype="string">check.current.1</descript>
      <descript sctype="string">check.get.workflowPhase</descript>
      <descript sctype="string">check.init.rules</descript>
      <descript sctype="string">check.post.auto.transitions</descript>
      <descript sctype="string">decide.runAction</descript>
      <descript sctype="string">finish.init.rules</descript>
      <descript sctype="string">get.workflow.phase</descript>
      <descript sctype="string">not.same</descript>
      <descript sctype="string">post.auto.transitions</descript>
      <descript sctype="string">run.display.rules</descript>
      <descript sctype="string">run.display.rules.1</descript>
      <descript sctype="string">run.init.rules</descript>
      <descript sctype="string">runAction</descript>
      <descript sctype="string">set.auto.phaseChange</descript>
      <descript sctype="string">set.workflow.flag</descript>
      <descript sctype="string">setup.init.rules</descript>
      <descript sctype="string">setup.runAction</descript>
      <descript sctype="string">QC54122 - The RAD applications se.search.engine and se.view.engine do not consider that the PM module can have different access configuration for problems, problem tasks, known errors and known error tasks.</descript>
      <descript sctype="string">Panel:	setup.tableAccess</descript>
      <descript sctype="string">From:</descript>
      <descript sctype="string">if (exists("tableAccess", $L.env) and not null(tableAccess in $L.env)) then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccess in $L.env, $L.object, $L.folder.exists))</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">if (exists("tableAccess", $L.env) and not null(tableAccess in $L.env) and filename($L.file)~="rootcause" and filename($L.file)~="rootcausetask" and filename($L.file)~="knownerror" and filename($L.file)~="knownerrortask") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccess in $L.env, $L.object, $L.folder.exists))</descript>
      <descript sctype="string">if (exists("tableAccessProb", $L.env) and not null(tableAccessProb in $L.env) and filename($L.file)="rootcause") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccessProb in $L.env, $L.object, exists("folder", $L.file)))</descript>
      <descript sctype="string">if (exists("tableAccessTask", $L.env) and not null(tableAccessTask in $L.env) and filename($L.file)="rootcausetask") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccessTask in $L.env, $L.object, exists("folder", $L.file)))</descript>
      <descript sctype="string">if (exists("tableAccessKE", $L.env) and not null(tableAccessKE in $L.env) and filename($L.file)="knownerror") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccessKE in $L.env, $L.object, exists("folder", $L.file)))</descript>
      <descript sctype="string">if (exists("tableAccessKETask", $L.env) and not null(tableAccessKETask in $L.env) and filename($L.file)="knownerrortask") then ($L.void=jscall("tableAccess.setAccessVars", $L.file, tableAccessKETask in $L.env, $L.object, exists("folder", $L.file)))</descript>
      <descript sctype="string">Modified the 'refresh.set.many' panel so that the following expression:</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (not null($L.dd.sort) and not same($L.dd.sort, {}) and not same($L.dd.sort, $L.sort)) then ($L.void=setsort($L.file, $L.dd.sort, $L.sort.type))</descript>
      <descript sctype="string"/>
      <descript sctype="string">is replaced with:</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (not null($L.view) and not null(groupByFieldName in $L.view) and not same(groupByFieldName in $L.view, {})) then ($L.dd.sort=sortFieldName in $L.view;$L.gg.sort=groupByFieldName in $L.view;$L.sort.type={};$L.gg.sort.type={};for $L.i = 1 to lng(denull(sortFieldName in $L.view)) do (if ($L.i in sortType in $L.view)#"d" then ($L.i in $L.sort.type=1) else ($L.i in $L.sort.type=0));for $L.i = 1 to lng(denull(groupByFieldName in $L.view)) do (if ($L.i in groupSortType in $L.view)#"d" then ($L.i in $L.gg.sort.type=1) else ($L.i in $L.gg.sort.type=0));$L.void=setsort($L.file, $L.dd.sort, $L.sort.type, $L.gg.sort, $L.gg.sort.type);$L.void=rtecall("rfirst", $L.rc, $L.file)) else (if (not null($L.dd.sort) and not same($L.dd.sort, {}) and not same($L.dd.sort, $L.sort)) then ($L.void=setsort($L.file, $L.dd.sort, $L.sort.type)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">This prevents the wrong records from being reshuffled under each group after a list refresh.</descript>
      <descript sctype="string">QC8467 - Attempting to use "expand array" on a Affected Ci's in Change Management - Could possibly be renamed to "Data Corruption Wizard".</descript>
      <descript sctype="string">Removed the panel "edit.array" of type "edit.array"</descript>
      <descript sctype="string">Removed the exists to the panel "edit.array" from the following panels:</descript>
      <descript sctype="string">- display.decide</descript>
      <descript sctype="string">set $L.special.type in start panel</descript>
      <descript sctype="string">Panel 'record.changed.msg':</descript>
      <descript sctype="string">Changed:</descript>
      <descript sctype="string">$L.msg=scmsg(52, "us", {$L.bg.action})</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.msg=scmsg(52, "us")</descript>
      <descript sctype="string">QC8713:</descript>
      <descript sctype="string">- Changed the name of 'not.same' panel to 'refresh.record'</descript>
      <descript sctype="string"/>
      <descript sctype="string">- Added 'not.same' process panel:</descript>
      <descript sctype="string">$L.msg=scmsg(52, "us", {$L.bg.action})</descript>
      <descript sctype="string">exit normal to 'bg.msg'</descript>
      <descript sctype="string"/>
      <descript sctype="string">- Added message panel 'bg.msg':</descript>
      <descript sctype="string">Display $L.msg and exit normal to 'refresh.record'</descript>
      <descript sctype="string">QC6029:on panel prepare.process, add $L.category and $L.phase in the $L.value.names so that when $L.category and $L.phase changed when calling a process, those changes will be brought back.</descript>
      <descript sctype="string">Hua:added a panel in se.view.engine so that when a record is reselected, I will check to see if $L.phase and $L.category is out of sync. If they are, then reselect $L.category and $L.phase.</descript>
      <descript sctype="string">DE3257</descript>
      <descript sctype="string">panel:  call.init.process</descript>
      <descript sctype="string">added $L.action to the init values</descript>
      <descript sctype="string">panel:  prepare.process</descript>
      <descript sctype="string">added $L.format to the $L.value and $L.object.names variables</descript>
      <descript sctype="string">DE3186  updated the start panel so that the expression starting with:</descript>
      <descript sctype="string">if (not null($L.bg.action))....</descript>
      <descript sctype="string">now reads</descript>
      <descript sctype="string">if (not same($L.bg.action, NULL))...</descript>
      <descript sctype="string">$L.bg.action was equal to "" which was causing the not null funciton to fail.</descript>
      <descript sctype="string">SCR 40833 - Added a lock name parameter to be passed when a record is being modified by updates from the event records.</descript>
      <descript sctype="string">DE2897</descript>
      <descript sctype="string">Don't do a refresh on a delete.</descript>
      <descript sctype="string">check if the update field is type 10 (in addition to type 2 or 4)</descript>
      <descript sctype="string">Panel post.display</descript>
      <descript sctype="string">Changed expression:</descript>
      <descript sctype="string">if exists("update", $L.env) then if (type(update in $L.env)=4) then ($L.can.update=evaluate(update in $L.env)) else (if type(update in $L.env=2) then ($L.can.update=$L.tableAccess.update));$L.can.update=nullsub($L.can.update, true)</descript>
      <descript sctype="string">to:</descript>
      <descript sctype="string">if exists("update", $L.env) then if (type(update in $L.env)={4, 10}) then ($L.can.update=evaluate(update in $L.env)) else (if type(update in $L.env=2) then ($L.can.update=$L.tableAccess.update));$L.can.update=nullsub($L.can.update, true)</descript>
      <descript sctype="string"/>
      <descript sctype="string">Short version:  =4 to ={4,10}</descript>
      <descript sctype="string">Don't try to select a save copy of the record if the record id in NULL.  Instead just init a blank copy of the file variable.</descript>
      <descript sctype="string">Panel check.get.save.copy.bg</descript>
      <descript sctype="string">Added new exit and condition at top of list</descript>
      <descript sctype="string">init.save.copy    $L.bg and null($L.record.id)</descript>
      <descript sctype="string">Panel init.save.copy</descript>
      <descript sctype="string">New rinit pane ($L.file.save, filename($L.file))</descript>
      <descript sctype="string">Normal exit: decide.extaccess</descript>
      <descript sctype="string">SCR 40833 - Task 35400: Modified se.view.engine, "lock.bg" panel to exit to "check.current" instead of "bg.record.changed" where the code will check to see if the record is current and if it is not, then we refresh the record and check again. If the record is the same, then the code exits to "set.bg.lock" and goes on with setting the lock on the record. New panels "check.current", "check.current.1", and "not.same" were added. Deleted unused panel "bg.record.changed" and "record.changed.msg".</descript>
      <descript sctype="string">SCR40469 - panel set.new.state: replaced the expression '$L.skip.copy=false' with 'if (status in $L.file)~#"reopen" then ($L.skip.copy=false) else ($L.skip.copy=true)</descript>
      <descript sctype="string">Default the qbe format name to filename.qbe in case it is not specified in the list State.</descript>
      <descript sctype="string">Set $L.dd.reclist to 0 if $L.mult is explicitly false.</descript>
      <descript sctype="string">Panel get.format</descript>
      <descript sctype="string">Removed if (profile.appl in $L.object="revision.view.environment") then ($L.screen.id="revision.view.record";use.locking in $L.object=false)</descript>
      <descript sctype="string">DE1648</descript>
      <descript sctype="string">Recompile due to change to previous panel</descript>
      <descript sctype="string">Pass the view on to the display application.</descript>
      <descript sctype="string">Recompiled to fix broken parameters.</descript>
      <descript sctype="string">Send view information to the inbox add routine.</descript>
      <descript sctype="string">Had to add additional folder selection checking (for permissions).</descript>
      <descript sctype="string">Use thread variable for extaccess record instead of selecting it.  This variable will be set in se.external.action.</descript>
      <descript sctype="string">will set state correctly in duplicate.record</descript>
      <descript sctype="string">Panel get.save.copy.bg</descript>
      <descript sctype="string">Changed no records exit to init.extaccess</descript>
      <descript sctype="string">Added allowed folder list.</descript>
      <descript sctype="string">Added hook for applying templates</descript>
      <descript sctype="string">Added hook for creating templates.</descript>
      <descript sctype="string">Keep the view when passed in from scm.advanced</descript>
      <descript sctype="string">Removed call to obsolete function current.window()</descript>
      <descript sctype="string">Moved initializations into JavaScript to reduce size of code record.</descript>
      <descript sctype="string">Changed normal exit on after.prompt.action.1 panel from check.master.display TO check.get.save.copy.bg allowing State initialization process/fc processing and save of $L.file.save to occur after a reselect.</descript>
      <descript sctype="string">devtx J0045: Modified process panel no.category to check if the record is entered via ess and if so, then doo not display the messge. Changed:</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.no.cat.msg=scmsg(4, "object", {category in $L.list, category.file.name in $L.object})</descript>
      <descript sctype="string"/>
      <descript sctype="string">to:</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (not nullsub(ess.entry in $L.file, false)) then ($L.no.cat.msg=scmsg(4, "object", {category in $L.list, category.file.name in $L.object}))</descript>
      <descript sctype="string">Panel setup.vars</descript>
      <descript sctype="string">Change how the title is built for add mode to:</descript>
      <descript sctype="string">if ($L.mode="add") then ($L.title=scmsg(188, "object", {nullsub($L.object.name, "Database Record")}))</descript>
      <descript sctype="string">devtx I1447</descript>
      <descript sctype="string">updated the get.link panel to pass in $L.special.type to the 'se.get.link.application'</descript>
      <descript sctype="string">continuation of issue listed below</descript>
      <descript sctype="string">updated the start panel...updated the line that set $L.special.type=$INTO.SPECIAL</descript>
      <descript sctype="string">if nothing was passed in then the type (based on the parameter definition) was set to an array which caused issues with the nullsub on the setup.vars panel.</descript>
      <descript sctype="string">Changed the expression to:</descript>
      <descript sctype="string">if (type($INTO.SPECIAL)=8) then ($L.special.type=NULL) else ($L.special.type=$INTO.SPECIAL)</descript>
      <descript sctype="string">devtx I0936:</descript>
      <descript sctype="string">updated the setup.vars panel.  When the object was a 'special' type the code was still trying to set up the message using the filename which in the case of special object types doesn't actually exist. (example...joinfiles).</descript>
      <descript sctype="string">changed the following expression:</descript>
      <descript sctype="string">$L.object.name=scmsg(nullsub(filename($L.file), "tablename")</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">$L.object.name=scmsg(nullsub($L.special.type, filename($L.file)), "tablename")</descript>
      <descript sctype="string">This way the correct object record/filename will be used when searching for the scmessage record.</descript>
      <descript sctype="string">When "State" was set it was overriding open and close States.  Fixed parenthesis placement.</descript>
      <descript sctype="string">Added ability to use the XML Fill ability.  At this time it is hardcoded to the "options" and "option.validations" fields.</descript>
      <descript sctype="string">fixed special object parameter</descript>
      <descript sctype="string">Added special object type to parameter panel.</descript>
      <descript sctype="string">Application was no properly doing a refresh when taking the refresh exit from lock.on.display.</descript>
      <descript sctype="string">panel:  prepare.process</descript>
      <descript sctype="string">Added $L.dd.reclist to the $L.value.names list so that the process record can check whether reclist is turned on or not.</descript>
      <descript sctype="string">no changes</descript>
      <descript sctype="string">added 'else ($L.rc=true)' to the expression below.</descript>
      <descript sctype="string">This way $L.rc always has a value and is always reset each time through.</descript>
      <descript sctype="string">CP SCR24794</descript>
      <descript sctype="string">issue where datapolicy is called when not needed...no changes were made and action~='ok,save,add'</descript>
      <descript sctype="string">panel:  post.display</descript>
      <descript sctype="string">updated the following expression:</descript>
      <descript sctype="string">if ($L.action={"ok", "save", "add"} or not null($L.process.save)) then ($L.rc=false;$L.rc=rtecall("policycheck", $L.errcode, $L.file))</descript>
      <descript sctype="string">to:</descript>
      <descript sctype="string">if ($L.action={"ok", "save", "add"} or not null($L.process.save) and not $L.same) then ($L.rc=false;$L.rc=rtecall("policycheck", $L.errcode, $L.file))</descript>
      <descript sctype="string">This way datapolicy will always be called when the action is = ok,save,add and will not be called if the action is equal to anything else and $L.same=true</descript>
      <descript sctype="string">CP scr32957</descript>
      <descript sctype="string">panel: display.decide</descript>
      <descript sctype="string">removed the exit for db.mass.function.joinfile with a condition of:</descript>
      <descript sctype="string">$L.action={"massupdate", "massdelete"} and not null(evaluate(parse(joindef in $L.object, 2)))</descript>
      <descript sctype="string">also removed the panel 'db.mass.function.joinfile'</descript>
      <descript sctype="string">The mass.update application takes care of the joinfile issue so it was not necessary to do so in the se.view.engine as well.</descript>
      <descript sctype="string">Changed the count panel to go against $L.list rather than $L.file.  Otherwise the count would always return 1 for a joinfile.</descript>
      <descript sctype="string">devtx ticket I1982:</descript>
      <descript sctype="string">panel:  duplicate.record</descript>
      <descript sctype="string">removed the following expression:</descript>
      <descript sctype="string">if (not nullsub(default.object in $L.object, false)) then if exists("State", $L.file) then if null(State in $L.file) then ($L.mode="add";State in $L.file=open.state in $L.object;$L.state.name=State in $L.file)</descript>
      <descript sctype="string">This was causing issues with the upgrade rootcause records since the field is nulled out in the upgrade process so the mode always gets set to 'add' and never 'update'</descript>
      <descript sctype="string">Modified how the object name (for display) was handled.</descript>
      <descript sctype="string">panel decide.get.record</descript>
      <descript sctype="string">changed first condition to not null(joindef in $L.object)</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel get.joinfile</descript>
      <descript sctype="string">changed second expression on first line to:</descript>
      <descript sctype="string">if (index("$", joindef in $L.object)&gt;0) then ($L.joinfile.name=evaluate(parse(joindef in $L.object, 2))) else ($L.joinfile.name=joindef in $L.object)</descript>
      <descript sctype="string">Added a "backrestart" exit as a base action.</descript>
      <descript sctype="string">Added pre.find and post.find panels to save and restore non-local (not $L.*) variables.  This protects against thread variables like $pmc.actions and $apm.activity getting overwritten.</descript>
      <descript sctype="string">sends bad.val as exit if display format control fails validation.</descript>
      <descript sctype="string">Debug code only, removed.</descript>
      <descript sctype="string">Exits for failed validation exits on calls to format control (call.master.init, call.fc.init, call.master.display, call.fc.display) changed from exit.normal to a new decision panel called decide.unlock; if object is locked, routes to badval.unlock.object, unlocking the object before exiting.</descript>
      <descript sctype="string">added exit to 'decide.process.exit.1' panel:  reevaluate</descript>
      <descript sctype="string">This will simply reevaluate the state record and the i/o condition</descript>
      <descript sctype="string">added $L.exit="invalid.action" to the invalid.action panel.</descript>
      <descript sctype="string">reversal of SCR32523:</descript>
      <descript sctype="string">panel:  print.1</descript>
      <descript sctype="string">changed the variable being passed into the us.print.prompt application back to '$L.print.format' from '$L.base.format'.</descript>
      <descript sctype="string">Made $L.fc.master available to processes.</descript>
      <descript sctype="string">Removed repeated actions.</descript>
      <descript sctype="string">Added "refresh" to list of actions to check for changes to the record before performing.</descript>
      <descript sctype="string">Added "locked" and "changed" settings for $L.exit for background processing.</descript>
      <descript sctype="string">panel: print</descript>
      <descript sctype="string">changed the following expression:</descript>
      <descript sctype="string">if ($L.action="printlist") then ($L.print.file=$L.file;$L.print.qbe=true)</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">if ($L.action="printlist") then ($L.print.file=$L.list;$L.print.qbe=true)</descript>
      <descript sctype="string">panel:  display.decide</descript>
      <descript sctype="string">added exit before the db.mass.function exit</descript>
      <descript sctype="string">exit: db.mass.function.joinfile</descript>
      <descript sctype="string">cond: $L.action={"massupdate", "massdelete"} and not null(evaluate(parse(joindef in $L.object, 2)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel: db.mass.function.joinfile (process panel)</descript>
      <descript sctype="string">expression:</descript>
      <descript sctype="string">$L.format=file.name in $L.object</descript>
      <descript sctype="string">normal exit: db.mass.function</descript>
      <descript sctype="string">clone process was not being executed after the save was processed.</descript>
      <descript sctype="string">panel:   set.not.locked</descript>
      <descript sctype="string">changed normal exit from</descript>
      <descript sctype="string">'after.prompt.action'</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">'check.save.action'</descript>
      <descript sctype="string">panel: check.save.action (added decision panel)</descript>
      <descript sctype="string">exit: reset.action</descript>
      <descript sctype="string">cond: not null($L.save.action)</descript>
      <descript sctype="string">normal exit: after.prompt.action</descript>
      <descript sctype="string">This way if there is still an action that needs to be performed (the original action selected before the save was executed) it will still be performed after the save process is complete.</descript>
      <descript sctype="string">panel: db.mass.function</descript>
      <descript sctype="string">passed $L.object to the db.mass.functions application</descript>
      <descript sctype="string">panel:  print.1</descript>
      <descript sctype="string">The variable '$L.print.format' was being passed into the us.print.prompt application.  This variable is not set anywhere in the application so is NULL.</descript>
      <descript sctype="string">Changed the print.1 panel to pass in the '$L.base.format' variable which contains the base format name. (ie...print format)</descript>
      <descript sctype="string">Remove the nullsub() from the $L.allow.input condition on the get.format panel.</descript>
      <descript sctype="string">modified the query on build.extaccess.sql to read:</descript>
      <descript sctype="string">$L.extaccess.sql="name=\""+filename($L.file)+"\""</descript>
      <descript sctype="string">Don't prompt for save if in background.</descript>
      <descript sctype="string">Added call to get extaccess record and run expressions if in the background.</descript>
      <descript sctype="string">devtx BUG14701</descript>
      <descript sctype="string">added a flag variable:  $L.bg.process.done</descript>
      <descript sctype="string">This is set to true on the prepare.process panel if running in the background.</descript>
      <descript sctype="string">This flag was then added to the condition on the check.bg panel:</descript>
      <descript sctype="string">$L.bg and (same($L.action, $L.bg.action) or nullsub($L.bg.process.done, false))</descript>
      <descript sctype="string">devtx BUG14655:</descript>
      <descript sctype="string">changes to correct problems with actions requested via javascript (ie background actions).</descript>
      <descript sctype="string">Changed panels starting from check.non.gui</descript>
      <descript sctype="string">and decide.validate</descript>
      <descript sctype="string">devtx BUG14636</descript>
      <descript sctype="string">changed the 'one record' exit on the get.joinfile.record panel from 'duplicate.record' to 'check.background'.  Added 'check.background' panel to see if in background.  If we are in background then this panel exits to 'project.joinfile' which is a new project panel.  This will preserve any changes made to the record before entering the doc engine.</descript>
      <descript sctype="string">this was also for BUG14445</descript>
      <descript sctype="string">Changed the following expression on the first line of the post.display panel in the se.view.engine:</descript>
      <descript sctype="string">if $L.locked then ($L.mode="update")</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">if ($L.locked and $L.mode~#"close") then ($L.mode="update")</descript>
      <descript sctype="string">devtx14277:</descript>
      <descript sctype="string">$L.file.save was being lost for bg processing; modified 1st expression line on create.file.save to prevent the setting of $L.file.save for $G.bg=true ($L.file.save for background processing already set with call to se.get.record on panel get.save.copy.bg)</descript>
      <descript sctype="string">added the following to the post.display panel:</descript>
      <descript sctype="string">if $L.locked then ($L.mode="update")</descript>
      <descript sctype="string">This way the mode will get set to 'update' if the user locks the record.</descript>
      <descript sctype="string">(pbudic): changed exit for get.browse.state on the check.non.gui panel to use ~#"add" rather than ~="add"</descript>
      <descript sctype="string">When refreshing a list, have to go back to setup.vars as the record being displayed may have been (and probably was) changed.</descript>
      <descript sctype="string">When checking for category or phase, use $L.file instead of $L.list.</descript>
      <descript sctype="string">Fixed exit when running in background and data policy fails to reflect a "bad.val" exit so that the return code is correct.</descript>
      <descript sctype="string">Added call to authorize external actions.</descript>
      <descript sctype="string">Set not authorized exit.</descript>
      <descript sctype="string">changed the exit for the get.browse.state from get.format to set.values.  This way the initial process will be called even in browse mode.</descript>
      <descript sctype="string">Change to print qbe list flag for easier debugging.</descript>
      <descript sctype="string">Added a suppress messages flag - if true, messages normally sent by se.base.method will not get sent.</descript>
      <descript sctype="string">Modified application to exit if engine.access in $L.object is false - the file is not accessible through the engine.</descript>
      <descript sctype="string">on the 'get.format' panel:</descript>
      <descript sctype="string">Changed the expression:</descript>
      <descript sctype="string">$L.allow.input=nullsub(evaluate(parse(input.condition in $L.state, 2)), true)</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">$L.allow.input=nullsub(evaluate(input.condition in $L.state, 2), true)</descript>
      <descript sctype="string">Now checks if a file is either a paging or revision file and sets it to the correct special object type to be passed into se.get.object:</descript>
      <descript sctype="string">- added set.special.type to be called between start and get.object</descript>
      <descript sctype="string">- on get.object, set Special Object Type to $L.special.type</descript>
      <descript sctype="string">Fixed background processing to unlock records and fixed the background flag when calling a process.</descript>
      <descript sctype="string">On start, set mode to "add" if the background action is "add"</descript>
      <descript sctype="string">- changed expression from if (not null($L.bg.action)) then ($L.bg=true) to if (not null($L.bg.action)) then ($L.bg=true;if ($L.bg.action="add") then ($L.mode="add"))</descript>
      <descript sctype="string">- moved the following mode-related expressions to the end of the panel:  $L.initial.mode=$L.mode;if $L.mode#"add" then ($L.dd.reclist=false)</descript>
      <descript sctype="string">Fix for check to see if record changed.  NULL entries cause by new fields being added no longer cause the engine to think the record has changed.</descript>
      <descript sctype="string">When calling a process that results in an application error, engine will drop back to displaying the record instead of dropping to the menu.</descript>
      <descript sctype="string">Added watch variables from Object record.  Watch Variables are checked to see if they are not null on post.display.  If any are not null, then the record is considered to be changed.</descript>
      <descript sctype="string">Added a new exit for "unlock" so that processes that have actions that are not "save" can unlock a record after the process is complete (im.close is the example in this case).</descript>
      <descript sctype="string">Added exit to unlock.object with the following condition:</descript>
      <descript sctype="string">$L.action="reselect" and not $L.lock.on.display</descript>
      <descript sctype="string">This way when a user uses the undo button the lock is released.</descript>
      <descript sctype="string">Recompiled due to changes to se.base.method - a suppress flag parameter was added.</descript>
      <descript sctype="string">changed the following line (on panels 'check.master.display' and 'check.master.init')</descript>
      <descript sctype="string">name in $L.fc.master~=name in $L.fc</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">not same(name in $L.fc.master, name in $L.fc)</descript>
      <descript sctype="string">This ensures that if there isn't a master format control the detail format control record will still be executed.</descript>
      <descript sctype="string">modified the get.record panel.  Changed the expression to:</descript>
      <descript sctype="string">if ($L.action~="add") then ($L.void=rtecall("refresh", $L.errcode, $L.file))</descript>
      <descript sctype="string">This way the refresh doesn't happen when doing an add.</descript>
      <descript sctype="string">added the exit "setup.reselect.joinfile" to the decide.process.exit.1 panel.  The setup.reselect.joinfile panel moves the values from the fields that make up the unique key from $L.file to $L.list.  This way the $L.temp.tag on the next panel is set correctly and the query against the joinfile on the get.joinfile.record panel will work correctly and the record is displayed correctly after the add is complete.</descript>
      <descript sctype="string">Modified the exit after adding a record that is a joinfile to reset the unique key in the $L.list variable so that the record is selected properly.</descript>
      <descript sctype="string">Removed the 2 places where $L.print.format is setup.  This makes the value null unless it is specifically set in a process.  This allows the us.print routines to choose the format for special case files - like incidents.</descript>
      <descript sctype="string">Now passes in the background flag correctly to se.get.object.</descript>
      <descript sctype="string">When you pass in a background action, it passes the final $L.exit parameter out through the same parameter.</descript>
      <descript sctype="string">Added additional changes for background processing.</descript>
      <descript sctype="string">The set.new.state panel now goes to check.non.gui instead of to get.state.  This routes it back through the check for Lock on Display after changing states.</descript>
      <descript sctype="string">Fixed exit when no action is hit to go to check.master.display rather than display (so display fc is run).</descript>
      <descript sctype="string">Reset $L.exit.when.done to false if process exits with "cancel"</descript>
      <descript sctype="string">Modified line on after.prompt.action to read:</descript>
      <descript sctype="string">if ($L.mode#"add" or $L.mode#"close") then ($L.mode=$L.initial.mode)</descript>
      <descript sctype="string">changed exits for pagelist, find, fill from exit.menu to goto.menu.exit -- which sets $L.action to "menu" and then goes to post.cancel.  This makes sure the record is unlocked before exiting.</descript>
      <descript sctype="string">Will not reset $L.file.save when going through the "newstate" exit.</descript>
      <descript sctype="string">Created new panel (create.file.save) that creates the $L.file.save parameter after initial processes and format control, but before display.</descript>
      <descript sctype="string">No passes $L.messages into the process.</descript>
      <descript sctype="string">Modified exit for "newcat" on decide.process.exit.1 to reselect $L.category, then go to set.values.</descript>
      <descript sctype="string">Put in a hardcoded fix on post.display to force $L.same to false if we are in Incident Management and the $apm.activity or $pmc.actions variable are not null.</descript>
      <descript sctype="string">compile only</descript>
      <descript sctype="string">Added an exit to decide.process.exit.1 to unlock the record after a save if Lock on Display isn't turned on.  Changed the normal exit on after.prompt.action.1 from display to check.master.display.</descript>
      <descript sctype="string">Modified check.non.gui to only call lock.on.display is the record isn't locked.</descript>
      <descript sctype="string">modified the se.view.engine application.</descript>
      <descript sctype="string">The get.format panel was being called before the initial process was being called.  In the initial process the format variables (format in $L.file and $L.format) were being set.  Since this was happening after the get.format panel these variables were empty.</descript>
      <descript sctype="string">Broke the get.format panel into 2 panels.</descript>
      <descript sctype="string">The first panel is called from the get.state panel.  This panel sets the $L.value.names and $L.values variables.</descript>
      <descript sctype="string">The get.format panel now sets up the format name but no longer initializes the $L.value.names and $L.values variables.</descript>
      <descript sctype="string">Now passes category and phase to se.base.method.</descript>
      <descript sctype="string">Changed to pass master format control record to se.base.method</descript>
      <descript sctype="string">added the following to the post.display panel:</descript>
      <descript sctype="string">$L.locked.temp=nullsub($L.locked.temp, $L.locked)</descript>
      <descript sctype="string"/>
      <descript sctype="string">changed the end of the condition expressions for both prompt.save exits on the decide.prompt.save panel:</descript>
      <descript sctype="string">was:</descript>
      <descript sctype="string">and not $L.same and $G.prompt.for.save</descript>
      <descript sctype="string">changed to:</descript>
      <descript sctype="string">and (not $L.same or $L.locked.temp) and $G.prompt.for.save</descript>
      <descript sctype="string"/>
      <descript sctype="string">added the following to the set.save.action panel:</descript>
      <descript sctype="string">$L.locked.temp=false</descript>
      <descript sctype="string">(this prevents the prompt.save looping)</descript>
      <descript sctype="string"/>
      <descript sctype="string">added the following to the set.not.locked panel:</descript>
      <descript sctype="string">$L.locked.temp=NULL</descript>
      <descript sctype="string">(This is so this variable gets set correctly on the post.display panel)</descript>
      <descript sctype="string">Modified exit for "setupadd" on decide.process.exit.1 to setup.vars to reflect changes in where category and phase are selected.</descript>
      <descript sctype="string">removed last modification</descript>
      <descript sctype="string">added if ($L.mode="add") then ($L.mode="update") to the decide.process.exit panel</descript>
      <descript sctype="string">pass category and phase to the base methods.</descript>
      <descript sctype="string">Modified check.non.gui to bypass locking if $L.mode~#"add".  The previous condition was $L.mode~="add", which didn't account for when $L.mode="addsave".</descript>
      <descript sctype="string">Modified to keep sort order on refresh.</descript>
      <descript sctype="string">Added se.get.link to allow for master (file) links.</descript>
      <descript sctype="string">added exit "refreshjoinfile" to the decide.process.exit1 panel</descript>
      <descript sctype="string">Modified so that when using a joindef the refresh exit goes back via setup.vars incase the joinfile changes.</descript>
      <descript sctype="string">Modified to allow a background action and set the background flag to true if one is entered.  Also replaced direct calls for add/update/delete to use the se.base.method application.</descript>
      <descript sctype="string">Added a background flag.</descript>
      <descript sctype="string">removed $L.exit="added" from the dup.after.save panel</descript>
      <descript sctype="string">changed $L.exit="normal" on the dup.after.save panel</descript>
      <descript sctype="string">Will now project to the joinfile when mode # "add", so that data entered in the transverse file is not lost.</descript>
      <descript sctype="string">Added modifications to allow a joindef record to be defined in the Object record.  Then the joined record is used as $L.file while the original list is $L.list.</descript>
      <descript sctype="string">Modified to reset $L.same after a process in case the standard process is run after and that process is "ok".</descript>
      <descript sctype="string">Modified the add.record.radd panel to exit to display if a trigger fails.  Should fix beta ticket IM00074</descript>
      <descript sctype="string">Added new routine to fetch phases to catch exceptions caused by ocm.</descript>
      <descript sctype="string">Will refetch state if the refresh option is called (setup.reselect).</descript>
      <descript sctype="string">Won't change states if the State changes from NULL to the default state.</descript>
      <descript sctype="string">Changed to set $L.state.name if "State" in record changes.</descript>
      <descript sctype="string">Modified apm.yes.no panels to have a message level of 3.</descript>
      <descript sctype="string">Will reset the mode to the base mode when moving between records.</descript>
      <descript sctype="string">Modified to turn off reclist if mode#"add".</descript>
      <descript sctype="string">Modified so that a saved action will process if the exit from previous action is NULL or "normal".</descript>
      <descript sctype="string">Added capability for lock on display.</descript>
      <descript sctype="string">Will now only continue with a saved action if the exit of the previous action was "normal".</descript>
      <descript sctype="string">Modified to not prompt for save on U-turn arrow.  The RTE now handles this.</descript>
      <descript sctype="string">Changed call to fduplicate to :  $L.void=rtecall("copycurrent", $L.errcode, $L.file.save, $L.file)</descript>
      <descript sctype="string">Cursor position is kept when doing a validity lookup.</descript>
      <descript sctype="string">On decide.process.exit.1 changed the condition to check for a State change from a ~= to a same().  Because same() will give a false result for a comparison to NULL while = gives unknown.</descript>
      <descript sctype="string">Will now get the parent and put it into $L.parent even when not locked.</descript>
      <descript sctype="string">Added a "deleted" exit that will check for a lock, unlock if necessary, and then reposition.</descript>
      <descript sctype="string">Will not prompt for save if the "update" field in the environment record evaluates to false.</descript>
      <descript sctype="string">Will correctly parse qbe format name if it is a variable.</descript>
      <descript sctype="string">Added $L.related.id and $L.related.filename to list of engine variables passed to display and se.call.process.</descript>
      <descript sctype="string">Removed $L.same=same($L.file, $L.file.save) from after.process.  Turns out that it wasn't necessary.</descript>
      <descript sctype="string">Added a "setupadd" exit that doesn't go back through the reselect RTE call, otherwise same as reselect.  Just that the record hasn't been added yet so it can't be reselected.</descript>
      <descript sctype="string">On after.process, reset $L.same after a process is called.</descript>
      <descript sctype="string">Added initial format control functionality.</descript>
      <descript sctype="string">Perform a get.base.form.name on $L.format to get correct format control and link records.</descript>
      <descript sctype="string">Added $L.exit.when.done to list of variables that are passed in and out of processes.</descript>
      <descript sctype="string">Nullsub'd default.object in $L.object to false in statements on panels get.format and duplicate.record.</descript>
      <descript sctype="string">On the duplicate record panel, nullsubed the open and close states with the default state...</descript>
      <descript sctype="string">Moved $L.locked=false to the start panel from setup.vars.  Had to do this for Change to support phase changes.</descript>
      <descript sctype="string">Added $L.messages to the parameters passed to a process.</descript>
      <descript sctype="string">changes for outputing error codes from triggers</descript>
      <descript sctype="string">Now passes $L.file.save to the display app.</descript>
      <descript sctype="string">Initial process may now modify the $L.format variable, and if so the $L.fc.name variable is updated.</descript>
      <descript sctype="string">Same change as below, except for Phase.</descript>
      <descript sctype="string">Will not send the "Category does not exist" message if the mode is "add"</descript>
      <descript sctype="string">Added a post-process exit ("openstate") that sets $L.mode to "add" .</descript>
      <descript sctype="string">Now calls format.cdis on the master format control.</descript>
      <descript sctype="string">added unlocking when $L.exit="restart" and there is a lock.</descript>
      <descript sctype="string">When $L.exit="closestate", set $L.mode="close" and the State to the close.state.</descript>
      <descript sctype="string">added functionaltiy for qopensave so that it will go to a new view of a record after re-qopening a last call record.</descript>
      <descript sctype="string">Will pass a value of true in the variable "$L.engine" to display.</descript>
      <descript sctype="string">Fixed the check for State to use the open.state for records that do not have a State field when the $L.mode="add".</descript>
      <descript sctype="string">Don't display the title if the unique key has more than one field.</descript>
      <descript sctype="string">Added a not authorized message.</descript>
      <descript sctype="string">Cleaned up delete behavior in non record list mode.</descript>
      <descript sctype="string">Fixed so $L.file.save is recreated when you refresh a list in record list mode.</descript>
      <descript sctype="string">Added functionality to check for $G.prompt.for.save for next, previous, and cancel.</descript>
      <descript sctype="string">deleted a fduplicate call that screwed up the file variable.</descript>
      <descript sctype="string">Added rte calls so that it was only necessary to fetch a record once.</descript>
      <descript sctype="string">Fixed the way pagelists chose their format so that the last change no longer causes pagelists to always pick the file name.</descript>
      <descript sctype="string">Fixed a typo that did not allow a stored format name to be used.</descript>
      <descript sctype="string">Added support for files with no unique keys.</descript>
      <descript sctype="string">Added the functionality to run a script when prompted by format control.</descript>
      <descript sctype="string">Modified the "normal" exit from a process to call the format control display app before returning to display proper.</descript>
      <descript sctype="string">added rtecall for recordsize, to check that the record size is not larger than use defined value.</descript>
      <descript sctype="string">Modified return action so that it will return $L.action.</descript>
      <descript sctype="string">Modified get.format panel to pass $L.mode into the call.init.process panel via $L.value.names and $L.values</descript>
      <descript sctype="string">Changed  it so that it uses new $L.action="addsave"  This adds  a new record, and then exits without displaying the record again.</descript>
      <descript sctype="string">Changed panel "get.format" to use file.name in $L.object instead of object.name in $L.object.  (object.name wasn't in the dbdict.)</descript>
    </descript>
    <release type="string">A9901</release>
    <sysmodcount type="decimal">0</sysmodcount>
    <sysmoduser type="string">falcon</sysmoduser>
    <sysmodtime type="dateTime">06/15/21 00:44:38</sysmodtime>
  </record>
</recordset>
