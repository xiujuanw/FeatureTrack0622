<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="enclapplrev">
  <record id="application.name=&quot;calendar.calc.date.neg&quot;" recordid="calendar.calc.date.neg">
    <application.name type="string">calendar.calc.date.neg</application.name>
    <rev.array sctype="array">
      <rev.array sctype="structure">
        <rev.name type="string">zhanzhen</rev.name>
        <rev.date type="dateTime">03/02/16 16:38:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">SM should support calculation of next.breach on several duty tables</rev.desc>
        </rev.desc>
        <change.no type="decimal">130200</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhouanqing</rev.name>
        <rev.date type="dateTime">12/04/13 10:28:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Wrong SLA alerts for 25%, 50% when there is holiday falling in the active duration</rev.desc>
          <rev.desc sctype="string">When two holiday days are in one week and the week is in the alert calculate period, the alert date is not correct.</rev.desc>
          <rev.desc sctype="string">In the loop, the value should be the length of $L.holiday.array but not 1 in $L.holiday.array</rev.desc>
        </rev.desc>
        <change.no type="decimal">97066</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhouanqing</rev.name>
        <rev.date type="dateTime">11/28/13 12:19:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Wrong SLA alerts for 25%, 50% when there is holiday falling in the active duration</rev.desc>
          <rev.desc sctype="string">Use denull function</rev.desc>
        </rev.desc>
        <change.no type="decimal">97066</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhouanqing</rev.name>
        <rev.date type="dateTime">08/19/13 07:12:54</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Wrong SLA alerts for 25%, 50% when there is holiday falling in the active duration</rev.desc>
        </rev.desc>
        <change.no type="decimal">97066</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lmingyan</rev.name>
        <rev.date type="dateTime">06/07/13 20:32:04</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">The result is caculated incorrectly when using Day and also checked 'Including Holiday hours in Working hours'</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel:start.calc.loop</rev.desc>
          <rev.desc sctype="string">add statement:</rev.desc>
          <rev.desc sctype="string">if $L.include.holidays then ($L.holiday.start={};$L.holiday.end={})</rev.desc>
        </rev.desc>
        <change.no type="decimal">95698</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">06/07/13 07:42:11</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">The result is caculated incorrectly when using Day and also checked 'Including Holiday hours in Working hours'</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel:start.calc.loop</rev.desc>
          <rev.desc sctype="string">add statement:</rev.desc>
          <rev.desc sctype="string">if $L.include.holidays then ($L.holiday.start={};$L.holiday.end={})</rev.desc>
        </rev.desc>
        <change.no type="decimal">95698</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">corvinoa</rev.name>
        <rev.date type="dateTime">06/27/11 06:57:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Adding the holiday paramater to optionally override the holiday group in the duty table.</rev.desc>
        </rev.desc>
        <change.no type="decimal">61661</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">yuli</rev.name>
        <rev.date type="dateTime">12/14/10 06:58:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Service Level Objective (SLO) interval times are being calculated incorrectly when using calholiday records in combination with operators and contacts in different time zones.</rev.desc>
          <rev.desc sctype="string">*panel "decide.get.holidays":</rev.desc>
          <rev.desc sctype="string">Changed exit "init.holiday" to "check.time.zone" decision panel</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">*New decision panel: "check.time.zone":</rev.desc>
          <rev.desc sctype="string">Going to "change.timezone" with condition: '$L.do.tz.calc'</rev.desc>
          <rev.desc sctype="string">Normal exit to: "init.holiday"</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">*New us.change.timezone panel "change.timezone":</rev.desc>
          <rev.desc sctype="string">$L.time.zone</rev.desc>
          <rev.desc sctype="string">Normal exit to "init.holiday"</rev.desc>
          <rev.desc sctype="string">panel:start</rev.desc>
          <rev.desc sctype="string">add the following statement</rev.desc>
          <rev.desc sctype="string">$L.osoffset=jscall("tzFunctions.getOSOffset")</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel:set.holiday.array</rev.desc>
          <rev.desc sctype="string">$L.holiday.start={start.date in $L.holiday}+$L.holiday.start</rev.desc>
          <rev.desc sctype="string">$L.holiday.end={end.date in $L.holiday}+$L.holiday.end</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">if (not null(noTimeZone in $L.holiday) and noTimeZone in $L.holiday) then ($L.holiday.start=$L.holiday.start+{jscall("tzFunctions.convertStringtoDate", str.start.date in $L.holiday) - $L.osoffset - get.timezoneoffset()};$L.holiday.end=$L.holiday.end+{jscall("tzFunctions.convertStringtoDate", str.end.date in $L.holiday) - $L.osoffset - get.timezoneoffset()}) else ($L.holiday.start=$L.holiday.start+{start.date in $L.holiday};$L.holiday.end=$L.holiday.end+{end.date in $L.holiday})</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel 'get.holiday.query'</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and start.date&lt;'"+$L.start+"'"</rev.desc>
          <rev.desc sctype="string">$L.include.holidays=nullsub(include.holidays in $L.duty.table, false)</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">$L.dateformat=jscall("DateOrderConstant.yyyymmdd")</rev.desc>
          <rev.desc sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and ( start.date&lt;'"+$L.start+"' or str.start.date&lt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")"</rev.desc>
          <rev.desc sctype="string">$L.include.holidays=nullsub(include.holidays in $L.duty.table, false)</rev.desc>
        </rev.desc>
        <change.no type="decimal">59316</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">08/05/09 21:25:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Replaced the following expression on 'reset.local.tz':</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">date.order in $L.tzfile=$L.date.order</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">with:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">date.order in $L.tzfile=nullsub($lo.date.order, date.order in $L.tzfile)</rev.desc>
        </rev.desc>
        <change.no type="decimal">40747</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">08/05/09 19:31:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Removed the 'get.operator.record' panel and modified 'get.switchovers' and 'reset.local.tz' so that the date format is now based on '$lo.date.order' and only one parameter is passed into 'set.timezone()'.</rev.desc>
        </rev.desc>
        <change.no type="decimal">40747</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified the following panels:</rev.desc>
          <rev.desc sctype="string">* get.switchovers - added the following expressions (the first two are executed before the existing switchover code, the last one after)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (not null($L.operator)) then ($L.date.order=nullsub(date.order in $L.operator, date.order in $L.tzfile)) else ($L.date.order=date.order in $L.tzfile)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if ($L.do.tz.calc or $L.date.order~=1) then (date.order in $L.tzfile=1;set.timezone($L.tzfile, operator()))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if ($L.date.order~=1) then (date.order in $L.tzfile=$L.date.order;set.timezone($L.tzfile, operator()))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">* get.time.zone - changed the normal exit from 'decide.switch.time.zone' to 'get.switchovers'</rev.desc>
          <rev.desc sctype="string">* decide.switch.time.zone - removed from system</rev.desc>
          <rev.desc sctype="string">* swtich.time.zone - removed from system</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">This will process the switchover dates in the mm/dd/yy format, which is how they need to be entered into the 'tzfile' records, prior to switching over to the appropriate date format.  This way, they will all be correctly accounted for even if the user is logged in using a different format.</rev.desc>
        </rev.desc>
        <change.no type="decimal">41149</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Hua: on panel get.operator, add a exit to get.time.zone when no record found. Also added condition to handle when $L.operator on panel reset.local.tz and switch.time.zone</rev.desc>
        </rev.desc>
        <change.no type="decimal">7556</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hzhang</rev.name>
        <rev.date type="dateTime">03/31/09 05:16:03</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Took the expression: $L.holiday.array={} out of the 'while' statement so the array of holidays wouldn't get cleaned up if the holiday was in the middle of the week.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: do.partial.week</rev.desc>
          <rev.desc sctype="string">Changed the expression:</rev.desc>
          <rev.desc sctype="string">$L.temp in $L.holiday.array={$L.i in $L.holiday.start, $L.i in $L.holiday.end}</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">if (index({$L.i in $L.holiday.start, $L.i in $L.holiday.end}, $L.holiday.array)=0) then ($L.temp in $L.holiday.array={$L.i in $L.holiday.start, $L.i in $L.holiday.end}</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: do.partial.week</rev.desc>
          <rev.desc sctype="string">Added the expression:</rev.desc>
          <rev.desc sctype="string">$L.holiday.array=denull($L.holiday.array)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: do.partial.week</rev.desc>
          <rev.desc sctype="string">Changed the expression:</rev.desc>
          <rev.desc sctype="string">if (not null($L.holiday.array)) then for $L.i = 1 to lng(1 in $L.times) do for $L.x = 1 to lng($L.holiday.array) do (if ($L.i in 2 in $L.times="start") then if ($L.i in 1 in $L.times&gt;1 in $L.x in $L.holiday.array and $L.i in 1 in $L.times&lt;2 in $L.x in $L.holiday.array) then ($L.i in 1 in $L.times=2 in $L.x in $L.holiday.array) else (if ($L.i in 1 in $L.times&gt;1 in $L.x in $L.holiday.array and $L.i in 1 in $L.times&lt;2 in $L.x in $L.holiday.array) then ($L.i in 1 in $L.times=1 in $L.x in $L.holiday.array)));</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">if (not null($L.holiday.array)) then for $L.i = 1 to lng(1 in $L.times) do for $L.x = 1 to lng(1 in $L.holiday.array) do (if ($L.i in 2 in $L.times="start") then (if ($L.i in 1 in $L.times&gt;=1 in $L.x in $L.holiday.array and $L.i in 1 in $L.times&lt;=2 in $L.x in $L.holiday.array) then if (not $L.include.holidays) then ($L.i in 1 in $L.times=2 in $L.x in $L.holiday.array) else ($L.i in 1 in $L.times=1 in $L.x in $L.holiday.array)) else (if ($L.i in 1 in $L.times&gt;=1 in $L.x in $L.holiday.array and $L.i in 1 in $L.times&lt;=2 in $L.x in $L.holiday.array) then if (not $L.include.holidays) then ($L.i in 1 in $L.times=1 in $L.x in $L.holiday.array) else ($L.i in 1 in $L.times=2 in $L.x in $L.holiday.array)));</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: do.partial.week</rev.desc>
          <rev.desc sctype="string">Changed the expression:</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng($L.holiday.start) do (if ($L.i in $L.holiday.start&gt;$L.current.time)</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng($L.holiday.start) do (if ($L.i in $L.holiday.start&gt;=$L.current.time)</rev.desc>
        </rev.desc>
        <change.no type="decimal">4115</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ffaegh</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">SCR40747: Executing the 'calendar.calc.date' application caused the date format to be reset to the tzfile 'date.order' setting instead of the 'date.order' setting in either the operator or company record ('$lo.date.order'). Modified to use the operator's date if one is defined.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Changed panels 'swtich.time.zone' and 'reset.local.tz':</rev.desc>
          <rev.desc sctype="string">Added the following line at the top:</rev.desc>
          <rev.desc sctype="string">date.order in $L.tzfile=nullsub(date.order in $L.operator, date.order in $L.tzfile)</rev.desc>
          <rev.desc sctype="string">Modified the second line from:</rev.desc>
          <rev.desc sctype="string">set.timezone($L.tzfile)</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">set.timezone($L.tzfile, operator())</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Added panel 'get.operator.record' of se.get.record format:</rev.desc>
          <rev.desc sctype="string">Exits to 'get.time.zone'</rev.desc>
          <rev.desc sctype="string">Modified all panels that exited to the 'get.time.zone' panel exit to the 'get.operator.record' panel instead.</rev.desc>
        </rev.desc>
        <change.no type="decimal">40747</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel do.partial.week</rev.desc>
          <rev.desc sctype="string">Changed  8th expression from:</rev.desc>
          <rev.desc sctype="string">if (not null($L.switchovers)) then for $L.i = 1 to lng(denull($L.switchovers)) do (if ($L.i in $L.switchovers&gt;$L.current.time) then ($L.switchovers=delete($L.switchovers, $L.i);$L.i-=1))</rev.desc>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string">if (not null($L.switchovers)) then for $L.i = 1 to lng(denull($L.switchovers)) do (if ($L.i in $L.switchovers&gt;$L.current.time) then ($L.switchovers=delete($L.switchovers, $L.i);if (lng($L.switchovers)&gt;0) then $L.i-=1))</rev.desc>
        </rev.desc>
        <change.no type="decimal">41125</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified last condition on the decide.week.start panel (RAD=calendar.calc.date.neg) from $L.interval&lt; to $L.interval&lt;=</rev.desc>
        </rev.desc>
        <change.no type="decimal">40831</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel get.holidays</rev.desc>
          <rev.desc sctype="string">Added sort field of start.date</rev.desc>
        </rev.desc>
        <change.no type="decimal">38400</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">06/03/06 18:29:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Removed $L.i-=1 from $L.holiday.start=delete($L.holiday.start, $L.i) expression to prevent application looping.</rev.desc>
        </rev.desc>
        <change.no type="decimal">38055</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added code  to call the duration subroutine RAD=calendar.calc.duration whenever the weekly duration of the caldutyhour record is NULL (new panels added: decide.weekly.duration and get.weekly.duration)</rev.desc>
        </rev.desc>
        <change.no type="decimal">38037</change.no>
      </rev.array>
    </rev.array>
    <descript sctype="array">
      <descript sctype="string">SM should support calculation of next.breach on several duty tables</descript>
      <descript sctype="string">Wrong SLA alerts for 25%, 50% when there is holiday falling in the active duration</descript>
      <descript sctype="string">When two holiday days are in one week and the week is in the alert calculate period, the alert date is not correct.</descript>
      <descript sctype="string">In the loop, the value should be the length of $L.holiday.array but not 1 in $L.holiday.array</descript>
      <descript sctype="string">Wrong SLA alerts for 25%, 50% when there is holiday falling in the active duration</descript>
      <descript sctype="string">Use denull function</descript>
      <descript sctype="string">Wrong SLA alerts for 25%, 50% when there is holiday falling in the active duration</descript>
      <descript sctype="string">The result is caculated incorrectly when using Day and also checked 'Including Holiday hours in Working hours'</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel:start.calc.loop</descript>
      <descript sctype="string">add statement:</descript>
      <descript sctype="string">if $L.include.holidays then ($L.holiday.start={};$L.holiday.end={})</descript>
      <descript sctype="string">The result is caculated incorrectly when using Day and also checked 'Including Holiday hours in Working hours'</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel:start.calc.loop</descript>
      <descript sctype="string">add statement:</descript>
      <descript sctype="string">if $L.include.holidays then ($L.holiday.start={};$L.holiday.end={})</descript>
      <descript sctype="string">Adding the holiday paramater to optionally override the holiday group in the duty table.</descript>
      <descript sctype="string">Service Level Objective (SLO) interval times are being calculated incorrectly when using calholiday records in combination with operators and contacts in different time zones.</descript>
      <descript sctype="string">*panel "decide.get.holidays":</descript>
      <descript sctype="string">Changed exit "init.holiday" to "check.time.zone" decision panel</descript>
      <descript sctype="string"/>
      <descript sctype="string">*New decision panel: "check.time.zone":</descript>
      <descript sctype="string">Going to "change.timezone" with condition: '$L.do.tz.calc'</descript>
      <descript sctype="string">Normal exit to: "init.holiday"</descript>
      <descript sctype="string"/>
      <descript sctype="string">*New us.change.timezone panel "change.timezone":</descript>
      <descript sctype="string">$L.time.zone</descript>
      <descript sctype="string">Normal exit to "init.holiday"</descript>
      <descript sctype="string">panel:start</descript>
      <descript sctype="string">add the following statement</descript>
      <descript sctype="string">$L.osoffset=jscall("tzFunctions.getOSOffset")</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel:set.holiday.array</descript>
      <descript sctype="string">$L.holiday.start={start.date in $L.holiday}+$L.holiday.start</descript>
      <descript sctype="string">$L.holiday.end={end.date in $L.holiday}+$L.holiday.end</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">if (not null(noTimeZone in $L.holiday) and noTimeZone in $L.holiday) then ($L.holiday.start=$L.holiday.start+{jscall("tzFunctions.convertStringtoDate", str.start.date in $L.holiday) - $L.osoffset - get.timezoneoffset()};$L.holiday.end=$L.holiday.end+{jscall("tzFunctions.convertStringtoDate", str.end.date in $L.holiday) - $L.osoffset - get.timezoneoffset()}) else ($L.holiday.start=$L.holiday.start+{start.date in $L.holiday};$L.holiday.end=$L.holiday.end+{end.date in $L.holiday})</descript>
      <descript sctype="string"/>
      <descript sctype="string"/>
      <descript sctype="string">panel 'get.holiday.query'</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and start.date&lt;'"+$L.start+"'"</descript>
      <descript sctype="string">$L.include.holidays=nullsub(include.holidays in $L.duty.table, false)</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">$L.dateformat=jscall("DateOrderConstant.yyyymmdd")</descript>
      <descript sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and ( start.date&lt;'"+$L.start+"' or str.start.date&lt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")"</descript>
      <descript sctype="string">$L.include.holidays=nullsub(include.holidays in $L.duty.table, false)</descript>
      <descript sctype="string">Replaced the following expression on 'reset.local.tz':</descript>
      <descript sctype="string"/>
      <descript sctype="string">date.order in $L.tzfile=$L.date.order</descript>
      <descript sctype="string"/>
      <descript sctype="string">with:</descript>
      <descript sctype="string"/>
      <descript sctype="string">date.order in $L.tzfile=nullsub($lo.date.order, date.order in $L.tzfile)</descript>
      <descript sctype="string">Removed the 'get.operator.record' panel and modified 'get.switchovers' and 'reset.local.tz' so that the date format is now based on '$lo.date.order' and only one parameter is passed into 'set.timezone()'.</descript>
      <descript sctype="string">Modified the following panels:</descript>
      <descript sctype="string">* get.switchovers - added the following expressions (the first two are executed before the existing switchover code, the last one after)</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (not null($L.operator)) then ($L.date.order=nullsub(date.order in $L.operator, date.order in $L.tzfile)) else ($L.date.order=date.order in $L.tzfile)</descript>
      <descript sctype="string"/>
      <descript sctype="string">if ($L.do.tz.calc or $L.date.order~=1) then (date.order in $L.tzfile=1;set.timezone($L.tzfile, operator()))</descript>
      <descript sctype="string"/>
      <descript sctype="string">if ($L.date.order~=1) then (date.order in $L.tzfile=$L.date.order;set.timezone($L.tzfile, operator()))</descript>
      <descript sctype="string"/>
      <descript sctype="string">* get.time.zone - changed the normal exit from 'decide.switch.time.zone' to 'get.switchovers'</descript>
      <descript sctype="string">* decide.switch.time.zone - removed from system</descript>
      <descript sctype="string">* swtich.time.zone - removed from system</descript>
      <descript sctype="string"/>
      <descript sctype="string">This will process the switchover dates in the mm/dd/yy format, which is how they need to be entered into the 'tzfile' records, prior to switching over to the appropriate date format.  This way, they will all be correctly accounted for even if the user is logged in using a different format.</descript>
      <descript sctype="string">Hua: on panel get.operator, add a exit to get.time.zone when no record found. Also added condition to handle when $L.operator on panel reset.local.tz and switch.time.zone</descript>
      <descript sctype="string">Took the expression: $L.holiday.array={} out of the 'while' statement so the array of holidays wouldn't get cleaned up if the holiday was in the middle of the week.</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: do.partial.week</descript>
      <descript sctype="string">Changed the expression:</descript>
      <descript sctype="string">$L.temp in $L.holiday.array={$L.i in $L.holiday.start, $L.i in $L.holiday.end}</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">if (index({$L.i in $L.holiday.start, $L.i in $L.holiday.end}, $L.holiday.array)=0) then ($L.temp in $L.holiday.array={$L.i in $L.holiday.start, $L.i in $L.holiday.end}</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: do.partial.week</descript>
      <descript sctype="string">Added the expression:</descript>
      <descript sctype="string">$L.holiday.array=denull($L.holiday.array)</descript>
      <descript sctype="string"/>
      <descript sctype="string"/>
      <descript sctype="string">Panel: do.partial.week</descript>
      <descript sctype="string">Changed the expression:</descript>
      <descript sctype="string">if (not null($L.holiday.array)) then for $L.i = 1 to lng(1 in $L.times) do for $L.x = 1 to lng($L.holiday.array) do (if ($L.i in 2 in $L.times="start") then if ($L.i in 1 in $L.times&gt;1 in $L.x in $L.holiday.array and $L.i in 1 in $L.times&lt;2 in $L.x in $L.holiday.array) then ($L.i in 1 in $L.times=2 in $L.x in $L.holiday.array) else (if ($L.i in 1 in $L.times&gt;1 in $L.x in $L.holiday.array and $L.i in 1 in $L.times&lt;2 in $L.x in $L.holiday.array) then ($L.i in 1 in $L.times=1 in $L.x in $L.holiday.array)));</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">if (not null($L.holiday.array)) then for $L.i = 1 to lng(1 in $L.times) do for $L.x = 1 to lng(1 in $L.holiday.array) do (if ($L.i in 2 in $L.times="start") then (if ($L.i in 1 in $L.times&gt;=1 in $L.x in $L.holiday.array and $L.i in 1 in $L.times&lt;=2 in $L.x in $L.holiday.array) then if (not $L.include.holidays) then ($L.i in 1 in $L.times=2 in $L.x in $L.holiday.array) else ($L.i in 1 in $L.times=1 in $L.x in $L.holiday.array)) else (if ($L.i in 1 in $L.times&gt;=1 in $L.x in $L.holiday.array and $L.i in 1 in $L.times&lt;=2 in $L.x in $L.holiday.array) then if (not $L.include.holidays) then ($L.i in 1 in $L.times=1 in $L.x in $L.holiday.array) else ($L.i in 1 in $L.times=2 in $L.x in $L.holiday.array)));</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: do.partial.week</descript>
      <descript sctype="string">Changed the expression:</descript>
      <descript sctype="string">for $L.i = 1 to lng($L.holiday.start) do (if ($L.i in $L.holiday.start&gt;$L.current.time)</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">for $L.i = 1 to lng($L.holiday.start) do (if ($L.i in $L.holiday.start&gt;=$L.current.time)</descript>
      <descript sctype="string">SCR40747: Executing the 'calendar.calc.date' application caused the date format to be reset to the tzfile 'date.order' setting instead of the 'date.order' setting in either the operator or company record ('$lo.date.order'). Modified to use the operator's date if one is defined.</descript>
      <descript sctype="string"/>
      <descript sctype="string">Changed panels 'swtich.time.zone' and 'reset.local.tz':</descript>
      <descript sctype="string">Added the following line at the top:</descript>
      <descript sctype="string">date.order in $L.tzfile=nullsub(date.order in $L.operator, date.order in $L.tzfile)</descript>
      <descript sctype="string">Modified the second line from:</descript>
      <descript sctype="string">set.timezone($L.tzfile)</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">set.timezone($L.tzfile, operator())</descript>
      <descript sctype="string"/>
      <descript sctype="string">Added panel 'get.operator.record' of se.get.record format:</descript>
      <descript sctype="string">Exits to 'get.time.zone'</descript>
      <descript sctype="string">Modified all panels that exited to the 'get.time.zone' panel exit to the 'get.operator.record' panel instead.</descript>
      <descript sctype="string">Panel do.partial.week</descript>
      <descript sctype="string">Changed  8th expression from:</descript>
      <descript sctype="string">if (not null($L.switchovers)) then for $L.i = 1 to lng(denull($L.switchovers)) do (if ($L.i in $L.switchovers&gt;$L.current.time) then ($L.switchovers=delete($L.switchovers, $L.i);$L.i-=1))</descript>
      <descript sctype="string">to:</descript>
      <descript sctype="string">if (not null($L.switchovers)) then for $L.i = 1 to lng(denull($L.switchovers)) do (if ($L.i in $L.switchovers&gt;$L.current.time) then ($L.switchovers=delete($L.switchovers, $L.i);if (lng($L.switchovers)&gt;0) then $L.i-=1))</descript>
      <descript sctype="string">Panel do.partial.week</descript>
      <descript sctype="string">Changed  8th expression from:</descript>
      <descript sctype="string">if (not null($L.switchovers)) then for $L.i = 1 to lng(denull($L.switchovers)) do (if ($L.i in $L.switchovers&lt;$L.current.time) then ($L.switchovers=delete($L.switchovers, $L.i);$L.i-=1))</descript>
      <descript sctype="string">to:</descript>
      <descript sctype="string">if (not null($L.switchovers)) then for $L.i = 1 to lng(denull($L.switchovers)) do (if ($L.i in $L.switchovers&lt;$L.current.time) then ($L.switchovers=delete($L.switchovers, $L.i);if (lng($L.switchovers)&gt;0) then $L.i-=1))</descript>
      <descript sctype="string">Modified last condition on the decide.week.start panel (RAD=calendar.calc.date.neg) from $L.interval&lt; to $L.interval&lt;=</descript>
      <descript sctype="string">Panel get.holidays</descript>
      <descript sctype="string">Added sort field of start.date</descript>
      <descript sctype="string">Removed $L.i-=1 from $L.holiday.start=delete($L.holiday.start, $L.i) expression to prevent application looping.</descript>
      <descript sctype="string">added code  to call the duration subroutine RAD=calendar.calc.duration whenever the weekly duration of the caldutyhour record is NULL (new panels added: decide.weekly.duration and get.weekly.duration)</descript>
    </descript>
    <release type="string">SC6</release>
    <sysmodcount type="decimal">12</sysmodcount>
    <sysmoduser type="string">falcon</sysmoduser>
    <sysmodtime type="dateTime">03/02/16 16:38:34</sysmodtime>
  </record>
</recordset>
