<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="enclapplrev">
  <record id="application.name=&quot;calendar.calc.date.pos&quot;" recordid="calendar.calc.date.pos">
    <application.name type="string">calendar.calc.date.pos</application.name>
    <rev.array sctype="array">
      <rev.array sctype="structure">
        <rev.name type="string">zhanzhen</rev.name>
        <rev.date type="dateTime">03/02/16 16:38:43</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">SM should support calculation of next.breach on several duty tables</rev.desc>
        </rev.desc>
        <change.no type="decimal">130200</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhanzhen</rev.name>
        <rev.date type="dateTime">10/18/15 09:04:32</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Incorrect date calculation using holidays and dutyhours</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">rootcause: there is a holiday cross week, and not handle the holiday end</rev.desc>
        </rev.desc>
        <change.no type="decimal">126814</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lmingyan</rev.name>
        <rev.date type="dateTime">06/08/13 02:32:43</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">The result is caculated incorrectly when using Day and also checked 'Including Holiday hours in Working hours'</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel:start.calc.loop</rev.desc>
          <rev.desc sctype="string">add statement:</rev.desc>
          <rev.desc sctype="string">if $L.include.holidays then ($L.holiday.start={};$L.holiday.end={})</rev.desc>
        </rev.desc>
        <change.no type="decimal">95698</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">06/07/13 13:40:32</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">The result is caculated incorrectly when using Day and also checked 'Including Holiday hours in Working hours'</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel:start.calc.loop</rev.desc>
          <rev.desc sctype="string">add statement:</rev.desc>
          <rev.desc sctype="string">if $L.include.holidays then ($L.holiday.start={};$L.holiday.end={})</rev.desc>
        </rev.desc>
        <change.no type="decimal">95698</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhenqing</rev.name>
        <rev.date type="dateTime">02/03/13 02:51:32</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Service Manager will hang when calculating end date under some circumstance</rev.desc>
        </rev.desc>
        <change.no type="decimal">90619</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">06/29/11 09:53:41</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QC Task 61662 - Update code for calendar.calc.date.pos application to accept holiday.group parameter</rev.desc>
          <rev.desc sctype="string">Code changes</rev.desc>
          <rev.desc sctype="string">Panel: parameter</rev.desc>
          <rev.desc sctype="string">Added the new parameter "Holiday schedule" ($INTO.HOLIDAY) of type query</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: start</rev.desc>
          <rev.desc sctype="string">Added the following code lines:</rev.desc>
          <rev.desc sctype="string">$L.holiday.name=$INTO.HOLIDAY</rev.desc>
          <rev.desc sctype="string">if ($L.holiday.name="" or $L.holiday.name="null") then ($L.holiday.name=NULL)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: decide.get.holidays</rev.desc>
          <rev.desc sctype="string">Changed the condition from:</rev.desc>
          <rev.desc sctype="string">not null(holiday.table in $L.duty.table)</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">not null(holiday.table in $L.duty.table) or not null($L.holiday.name)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: get.holiday.query</rev.desc>
          <rev.desc sctype="string">Changed an expression from:</rev.desc>
          <rev.desc sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and (end.date&gt;'"+$L.start+"' or str.end.date&gt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")"</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub($L.holiday.name, holiday.table in $L.duty.table)+"\" and ( start.date&lt;'"+$L.start+"' or str.start.date&lt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")</rev.desc>
        </rev.desc>
        <change.no type="decimal">61662</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">06/29/11 07:31:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QC Task 61662 - Update code for calendar.calc.date.pos application to accept holiday.group parameter</rev.desc>
          <rev.desc sctype="string">Code changes</rev.desc>
          <rev.desc sctype="string">Panel: parameter</rev.desc>
          <rev.desc sctype="string">Added the new parameter "Holiday schedule" ($INTO.HOLIDAY) of type query</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: start</rev.desc>
          <rev.desc sctype="string">Added the following code line:</rev.desc>
          <rev.desc sctype="string">$L.holiday.group=$INTO.HOLIDAY</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: decide.get.holidays</rev.desc>
          <rev.desc sctype="string">Changed the condition from:</rev.desc>
          <rev.desc sctype="string">not null(holiday.table in $L.duty.table)</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">not null(holiday.table in $L.duty.table) or not null($L.holiday.group)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: get.holiday.query</rev.desc>
          <rev.desc sctype="string">Changed an expression from:</rev.desc>
          <rev.desc sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and (end.date&gt;'"+$L.start+"' or str.end.date&gt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")"</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (not null($L.holiday.group)) then ($L.holiday.sql="holiday.tables=\""+$L.holiday.group+"\" and (end.date&gt;'"+$L.start+"' or str.end.date&gt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")") else ($L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and (end.date&gt;'"+$L.start+"' or str.end.date&gt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")")</rev.desc>
        </rev.desc>
        <change.no type="decimal">61662</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">yuli</rev.name>
        <rev.date type="dateTime">12/14/10 07:04:32</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">*panel "decide.get.holidays":</rev.desc>
          <rev.desc sctype="string">Changed exit "init.holiday" to "check.time.zone" decision panel</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">*New decision panel: "check.time.zone":</rev.desc>
          <rev.desc sctype="string">Going to "change.timezone" with condition: '$L.do.tz.calc'</rev.desc>
          <rev.desc sctype="string">Normal exit to: "init.holiday"</rev.desc>
          <rev.desc sctype="string">Service Level Objective (SLO) interval times are being calculated incorrectly when using calholiday records in combination with operators and contacts in different time zones.</rev.desc>
          <rev.desc sctype="string">*New us.change.timezone panel "change.timezone":</rev.desc>
          <rev.desc sctype="string">$L.time.zone</rev.desc>
          <rev.desc sctype="string">Normal exit to "init.holiday"</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel:start</rev.desc>
          <rev.desc sctype="string">add the following statement</rev.desc>
          <rev.desc sctype="string">$L.osoffset=jscall("tzFunctions.getOSOffset")</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel 'get.holiday.query'</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and end.date&gt;'"+$L.start+"'"</rev.desc>
          <rev.desc sctype="string">$L.include.holidays=nullsub(include.holidays in $L.duty.table, false)</rev.desc>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string">$L.dateformat=jscall("DateOrderConstant.yyyymmdd")</rev.desc>
          <rev.desc sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and (end.date&gt;'"+$L.start+"' or str.end.date&gt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")"</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.include.holidays=nullsub(include.holidays in $L.duty.table, false)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">set.holiday.array</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.holiday.start=$L.holiday.start+{start.date in $L.holiday}</rev.desc>
          <rev.desc sctype="string">$L.holiday.end=$L.holiday.end+{end.date in $L.holiday}</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">if (not null(noTimeZone in $L.holiday) and noTimeZone in $L.holiday) then ($L.holiday.start=$L.holiday.start+{jscall("tzFunctions.convertStringtoDate", str.start.date in $L.holiday) - $L.osoffset - get.timezoneoffset()};$L.holiday.end=$L.holiday.end+{jscall("tzFunctions.convertStringtoDate", str.end.date in $L.holiday) - $L.osoffset - get.timezoneoffset()}) else ($L.holiday.start=$L.holiday.start+{start.date in $L.holiday};$L.holiday.end=$L.holiday.end+{end.date in $L.holiday})</rev.desc>
        </rev.desc>
        <change.no type="decimal">59316</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">yu li</rev.name>
        <rev.date type="dateTime">11/20/09 20:05:48</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Calendar.calc.date.pos application is not taking holidays into account when calculating time intervals.</rev.desc>
        </rev.desc>
        <change.no type="decimal">49157</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">yu li</rev.name>
        <rev.date type="dateTime">11/17/09 01:36:20</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Calendar.calc.date.pos application is not taking holidays into account when calculating time intervals.</rev.desc>
        </rev.desc>
        <change.no type="decimal">49157</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">08/05/09 21:23:31</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Replaced the following expression on 'reset.local.tz':</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">date.order in $L.tzfile=$L.date.order</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">with:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">date.order in $L.tzfile=nullsub($lo.date.order, date.order in $L.tzfile)</rev.desc>
        </rev.desc>
        <change.no type="decimal">40747</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">08/05/09 19:39:51</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Removed the 'get.operator.record' panel and modified 'get.switchovers' and 'reset.local.tz' so that the date format is now based on '$lo.date.order' and only one parameter is passed into 'set.timezone()'.</rev.desc>
        </rev.desc>
        <change.no type="decimal">40747</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified the following panels:</rev.desc>
          <rev.desc sctype="string">* get.switchovers - added the following expressions (the first two are executed before the existing switchover code, the last one after)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (not null($L.operator)) then ($L.date.order=nullsub(date.order in $L.operator, date.order in $L.tzfile)) else ($L.date.order=date.order in $L.tzfile)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if ($L.do.tz.calc or $L.date.order~=1) then (date.order in $L.tzfile=1;set.timezone($L.tzfile, operator()))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if ($L.date.order~=1) then (date.order in $L.tzfile=$L.date.order;set.timezone($L.tzfile, operator()))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">* get.time.zone - changed the normal exit from 'decide.switch.time.zone' to 'get.switchovers'</rev.desc>
          <rev.desc sctype="string">* decide.switch.time.zone - removed from system</rev.desc>
          <rev.desc sctype="string">* swtich.time.zone - removed from system</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">This will process the switchover dates in the mm/dd/yy format, which is how they need to be entered into the 'tzfile' records, prior to switching over to the appropriate date format.  This way, they will all be correctly accounted for even if the user is logged in using a different format.</rev.desc>
        </rev.desc>
        <change.no type="decimal">41149</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Hua: on panel get.operator, add a exit to get.time.zone when no record found. Also added condition to handle when $L.operator on panel reset.local.tz and switch.time.zone</rev.desc>
        </rev.desc>
        <change.no type="decimal">7556</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ffaegh</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">SCR40747: Executing the 'calendar.calc.date' application caused the date format to be reset to the tzfile 'date.order' setting instead of the 'date.order' setting in either the operator or company record ('$lo.date.order'). Modified to use the operator's date if one is defined.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Changed panels 'swtich.time.zone' and 'reset.local.tz':</rev.desc>
          <rev.desc sctype="string">Added the following line at the top:</rev.desc>
          <rev.desc sctype="string">date.order in $L.tzfile=nullsub(date.order in $L.operator, date.order in $L.tzfile)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Modified the second line from:</rev.desc>
          <rev.desc sctype="string">set.timezone($L.tzfile)</rev.desc>
          <rev.desc sctype="string">To:</rev.desc>
          <rev.desc sctype="string">set.timezone($L.tzfile, operator())</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Added panel 'get.operator.record' of se.get.record format:</rev.desc>
          <rev.desc sctype="string">Exits to 'get.time.zone'</rev.desc>
          <rev.desc sctype="string">Added panel 'get.operator.record' of se.get.record format:</rev.desc>
          <rev.desc sctype="string">Exits to 'get.time.zone'</rev.desc>
          <rev.desc sctype="string">Modified all panels that exited to the 'get.time.zone' panel (check.parms, decide.get.holidays,get.holidays,set.next.holiday) exit to the 'get.operator.record' panel instead.</rev.desc>
        </rev.desc>
        <change.no type="decimal">40747</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">05/02/08 01:44:04</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel do.partial.week</rev.desc>
          <rev.desc sctype="string">Changed  8th expression from:</rev.desc>
          <rev.desc sctype="string">if (not null($L.switchovers)) then for $L.i = 1 to lng(denull($L.switchovers)) do (if ($L.i in $L.switchovers&lt;$L.current.time) then ($L.switchovers=delete($L.switchovers, $L.i);$L.i-=1))</rev.desc>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string">if (not null($L.switchovers)) then for $L.i = 1 to lng(denull($L.switchovers)) do (if ($L.i in $L.switchovers&lt;$L.current.time) then ($L.switchovers=delete($L.switchovers, $L.i);if (lng($L.switchovers)&gt;0) then $L.i-=1))</rev.desc>
        </rev.desc>
        <change.no type="decimal">41125</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel get.holidays</rev.desc>
          <rev.desc sctype="string">Added sort field of start.date</rev.desc>
        </rev.desc>
        <change.no type="decimal">38400</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">07/03/06 14:26:50</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Removed $L.i-=1 from $L.holiday.start=delete($L.holiday.start, $L.i) expression to prevent application looping.</rev.desc>
        </rev.desc>
        <change.no type="decimal">38055</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">prietke</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added code  to call the duration subroutine RAD=calendar.calc.duration whenever the weekly duration of the caldutyhour record is NULL (new panels added: decide.weekly.duration and get.weekly.duration)</rev.desc>
        </rev.desc>
        <change.no type="decimal">38037</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">If the duty table doesn't exist, now defaults to simple (24x7) calculation.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added capability for "Full Day" processing.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added capability for including holidays rather than excluding.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
    </rev.array>
    <descript sctype="array">
      <descript sctype="string">SM should support calculation of next.breach on several duty tables</descript>
      <descript sctype="string">Incorrect date calculation using holidays and dutyhours</descript>
      <descript sctype="string"/>
      <descript sctype="string">rootcause: there is a holiday cross week, and not handle the holiday end</descript>
      <descript sctype="string">The result is caculated incorrectly when using Day and also checked 'Including Holiday hours in Working hours'</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel:start.calc.loop</descript>
      <descript sctype="string">add statement:</descript>
      <descript sctype="string">if $L.include.holidays then ($L.holiday.start={};$L.holiday.end={})</descript>
      <descript sctype="string">The result is caculated incorrectly when using Day and also checked 'Including Holiday hours in Working hours'</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel:start.calc.loop</descript>
      <descript sctype="string">add statement:</descript>
      <descript sctype="string">if $L.include.holidays then ($L.holiday.start={};$L.holiday.end={})</descript>
      <descript sctype="string">Service Manager will hang when calculating end date under some circumstance</descript>
      <descript sctype="string">QC Task 61662 - Update code for calendar.calc.date.pos application to accept holiday.group parameter</descript>
      <descript sctype="string">Code changes</descript>
      <descript sctype="string">Panel: parameter</descript>
      <descript sctype="string">Added the new parameter "Holiday schedule" ($INTO.HOLIDAY) of type query</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: start</descript>
      <descript sctype="string">Added the following code lines:</descript>
      <descript sctype="string">$L.holiday.name=$INTO.HOLIDAY</descript>
      <descript sctype="string">if ($L.holiday.name="" or $L.holiday.name="null") then ($L.holiday.name=NULL)</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: decide.get.holidays</descript>
      <descript sctype="string">Changed the condition from:</descript>
      <descript sctype="string">not null(holiday.table in $L.duty.table)</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">not null(holiday.table in $L.duty.table) or not null($L.holiday.name)</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: get.holiday.query</descript>
      <descript sctype="string">Changed an expression from:</descript>
      <descript sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and (end.date&gt;'"+$L.start+"' or str.end.date&gt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")"</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub($L.holiday.name, holiday.table in $L.duty.table)+"\" and ( start.date&lt;'"+$L.start+"' or str.start.date&lt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")</descript>
      <descript sctype="string">QC Task 61662 - Update code for calendar.calc.date.pos application to accept holiday.group parameter</descript>
      <descript sctype="string">Code changes</descript>
      <descript sctype="string">Panel: parameter</descript>
      <descript sctype="string">Added the new parameter "Holiday schedule" ($INTO.HOLIDAY) of type query</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: start</descript>
      <descript sctype="string">Added the following code line:</descript>
      <descript sctype="string">$L.holiday.group=$INTO.HOLIDAY</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: decide.get.holidays</descript>
      <descript sctype="string">Changed the condition from:</descript>
      <descript sctype="string">not null(holiday.table in $L.duty.table)</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">not null(holiday.table in $L.duty.table) or not null($L.holiday.group)</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: get.holiday.query</descript>
      <descript sctype="string">Changed an expression from:</descript>
      <descript sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and (end.date&gt;'"+$L.start+"' or str.end.date&gt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")"</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (not null($L.holiday.group)) then ($L.holiday.sql="holiday.tables=\""+$L.holiday.group+"\" and (end.date&gt;'"+$L.start+"' or str.end.date&gt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")") else ($L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and (end.date&gt;'"+$L.start+"' or str.end.date&gt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")")</descript>
      <descript sctype="string"/>
      <descript sctype="string">*panel "decide.get.holidays":</descript>
      <descript sctype="string">Changed exit "init.holiday" to "check.time.zone" decision panel</descript>
      <descript sctype="string"/>
      <descript sctype="string">*New decision panel: "check.time.zone":</descript>
      <descript sctype="string">Going to "change.timezone" with condition: '$L.do.tz.calc'</descript>
      <descript sctype="string">Normal exit to: "init.holiday"</descript>
      <descript sctype="string">Service Level Objective (SLO) interval times are being calculated incorrectly when using calholiday records in combination with operators and contacts in different time zones.</descript>
      <descript sctype="string">*New us.change.timezone panel "change.timezone":</descript>
      <descript sctype="string">$L.time.zone</descript>
      <descript sctype="string">Normal exit to "init.holiday"</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel:start</descript>
      <descript sctype="string">add the following statement</descript>
      <descript sctype="string">$L.osoffset=jscall("tzFunctions.getOSOffset")</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel 'get.holiday.query'</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and end.date&gt;'"+$L.start+"'"</descript>
      <descript sctype="string">$L.include.holidays=nullsub(include.holidays in $L.duty.table, false)</descript>
      <descript sctype="string">to:</descript>
      <descript sctype="string">$L.dateformat=jscall("DateOrderConstant.yyyymmdd")</descript>
      <descript sctype="string">$L.holiday.sql="holiday.tables=\""+nullsub(holiday.table in $L.duty.table)+"\" and (end.date&gt;'"+$L.start+"' or str.end.date&gt;\""+jscall("tzFunctions.convertDatetoString", $L.start, $L.dateformat)+"\")"</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.include.holidays=nullsub(include.holidays in $L.duty.table, false)</descript>
      <descript sctype="string"/>
      <descript sctype="string"/>
      <descript sctype="string"/>
      <descript sctype="string">set.holiday.array</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.holiday.start=$L.holiday.start+{start.date in $L.holiday}</descript>
      <descript sctype="string">$L.holiday.end=$L.holiday.end+{end.date in $L.holiday}</descript>
      <descript sctype="string"/>
      <descript sctype="string">to</descript>
      <descript sctype="string">if (not null(noTimeZone in $L.holiday) and noTimeZone in $L.holiday) then ($L.holiday.start=$L.holiday.start+{jscall("tzFunctions.convertStringtoDate", str.start.date in $L.holiday) - $L.osoffset - get.timezoneoffset()};$L.holiday.end=$L.holiday.end+{jscall("tzFunctions.convertStringtoDate", str.end.date in $L.holiday) - $L.osoffset - get.timezoneoffset()}) else ($L.holiday.start=$L.holiday.start+{start.date in $L.holiday};$L.holiday.end=$L.holiday.end+{end.date in $L.holiday})</descript>
      <descript sctype="string">Calendar.calc.date.pos application is not taking holidays into account when calculating time intervals.</descript>
      <descript sctype="string">Calendar.calc.date.pos application is not taking holidays into account when calculating time intervals.</descript>
      <descript sctype="string">Replaced the following expression on 'reset.local.tz':</descript>
      <descript sctype="string"/>
      <descript sctype="string">date.order in $L.tzfile=$L.date.order</descript>
      <descript sctype="string"/>
      <descript sctype="string">with:</descript>
      <descript sctype="string"/>
      <descript sctype="string">date.order in $L.tzfile=nullsub($lo.date.order, date.order in $L.tzfile)</descript>
      <descript sctype="string">Removed the 'get.operator.record' panel and modified 'get.switchovers' and 'reset.local.tz' so that the date format is now based on '$lo.date.order' and only one parameter is passed into 'set.timezone()'.</descript>
      <descript sctype="string">Modified the following panels:</descript>
      <descript sctype="string">* get.switchovers - added the following expressions (the first two are executed before the existing switchover code, the last one after)</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (not null($L.operator)) then ($L.date.order=nullsub(date.order in $L.operator, date.order in $L.tzfile)) else ($L.date.order=date.order in $L.tzfile)</descript>
      <descript sctype="string"/>
      <descript sctype="string">if ($L.do.tz.calc or $L.date.order~=1) then (date.order in $L.tzfile=1;set.timezone($L.tzfile, operator()))</descript>
      <descript sctype="string"/>
      <descript sctype="string">if ($L.date.order~=1) then (date.order in $L.tzfile=$L.date.order;set.timezone($L.tzfile, operator()))</descript>
      <descript sctype="string"/>
      <descript sctype="string">* get.time.zone - changed the normal exit from 'decide.switch.time.zone' to 'get.switchovers'</descript>
      <descript sctype="string">* decide.switch.time.zone - removed from system</descript>
      <descript sctype="string">* swtich.time.zone - removed from system</descript>
      <descript sctype="string"/>
      <descript sctype="string">This will process the switchover dates in the mm/dd/yy format, which is how they need to be entered into the 'tzfile' records, prior to switching over to the appropriate date format.  This way, they will all be correctly accounted for even if the user is logged in using a different format.</descript>
      <descript sctype="string">Hua: on panel get.operator, add a exit to get.time.zone when no record found. Also added condition to handle when $L.operator on panel reset.local.tz and switch.time.zone</descript>
      <descript sctype="string">SCR40747: Executing the 'calendar.calc.date' application caused the date format to be reset to the tzfile 'date.order' setting instead of the 'date.order' setting in either the operator or company record ('$lo.date.order'). Modified to use the operator's date if one is defined.</descript>
      <descript sctype="string"/>
      <descript sctype="string">Changed panels 'swtich.time.zone' and 'reset.local.tz':</descript>
      <descript sctype="string">Added the following line at the top:</descript>
      <descript sctype="string">date.order in $L.tzfile=nullsub(date.order in $L.operator, date.order in $L.tzfile)</descript>
      <descript sctype="string"/>
      <descript sctype="string">Modified the second line from:</descript>
      <descript sctype="string">set.timezone($L.tzfile)</descript>
      <descript sctype="string">To:</descript>
      <descript sctype="string">set.timezone($L.tzfile, operator())</descript>
      <descript sctype="string"/>
      <descript sctype="string">Added panel 'get.operator.record' of se.get.record format:</descript>
      <descript sctype="string">Exits to 'get.time.zone'</descript>
      <descript sctype="string">Added panel 'get.operator.record' of se.get.record format:</descript>
      <descript sctype="string">Exits to 'get.time.zone'</descript>
      <descript sctype="string">Modified all panels that exited to the 'get.time.zone' panel (check.parms, decide.get.holidays,get.holidays,set.next.holiday) exit to the 'get.operator.record' panel instead.</descript>
      <descript sctype="string">Panel do.partial.week</descript>
      <descript sctype="string">Changed  8th expression from:</descript>
      <descript sctype="string">if (not null($L.switchovers)) then for $L.i = 1 to lng(denull($L.switchovers)) do (if ($L.i in $L.switchovers&lt;$L.current.time) then ($L.switchovers=delete($L.switchovers, $L.i);$L.i-=1))</descript>
      <descript sctype="string">to:</descript>
      <descript sctype="string">if (not null($L.switchovers)) then for $L.i = 1 to lng(denull($L.switchovers)) do (if ($L.i in $L.switchovers&lt;$L.current.time) then ($L.switchovers=delete($L.switchovers, $L.i);if (lng($L.switchovers)&gt;0) then $L.i-=1))</descript>
      <descript sctype="string">Panel get.holidays</descript>
      <descript sctype="string">Added sort field of start.date</descript>
      <descript sctype="string">Removed $L.i-=1 from $L.holiday.start=delete($L.holiday.start, $L.i) expression to prevent application looping.</descript>
      <descript sctype="string">added code  to call the duration subroutine RAD=calendar.calc.duration whenever the weekly duration of the caldutyhour record is NULL (new panels added: decide.weekly.duration and get.weekly.duration)</descript>
      <descript sctype="string">If the duty table doesn't exist, now defaults to simple (24x7) calculation.</descript>
      <descript sctype="string">Added capability for "Full Day" processing.</descript>
      <descript sctype="string">Added capability for including holidays rather than excluding.</descript>
    </descript>
    <release type="string">SC6</release>
    <sysmodcount type="decimal">13</sysmodcount>
    <sysmoduser type="string">falcon</sysmoduser>
    <sysmodtime type="dateTime">03/02/16 16:38:53</sysmodtime>
  </record>
</recordset>
