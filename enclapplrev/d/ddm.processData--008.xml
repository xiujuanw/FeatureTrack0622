<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="enclapplrev">
  <record id="application.name=&quot;ddm.processData&quot;" recordid="ddm.processData">
    <application.name type="string">ddm.processData</application.name>
    <rev.array sctype="array">
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">12/29/15 19:52:52</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Delete panel next.rule</rev.desc>
        </rev.desc>
        <change.no type="decimal">130478</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hanrui</rev.name>
        <rev.date type="dateTime">07/21/15 19:33:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Roll back previous modification, and modified below panels to align with the new requirement</rev.desc>
          <rev.desc sctype="string">get.old.setup</rev.desc>
          <rev.desc sctype="string">init.reconcile.sql</rev.desc>
          <rev.desc sctype="string">prepare.rule.lookup</rev.desc>
          <rev.desc sctype="string">decide.init.ddmRule</rev.desc>
          <rev.desc sctype="string">decide.run.rule</rev.desc>
        </rev.desc>
        <change.no type="decimal">125839</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hanrui</rev.name>
        <rev.date type="dateTime">07/19/15 18:34:14</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified panel decide.overall.action to set udmdb.id as NULL when removing CI from ucmdb.</rev.desc>
        </rev.desc>
        <change.no type="decimal">125839</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hanrui</rev.name>
        <rev.date type="dateTime">06/08/15 15:59:06</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Story ucmdb reconciliation rule enhancement to directly read ddmreconcile table, set ucmdb.id as default reconcile rule</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hanrui</rev.name>
        <rev.date type="dateTime">05/28/15 08:17:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Story ucmdb reconciliation rule enhancement to directly read ddmreconcile table</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xuejun</rev.name>
        <rev.date type="dateTime">04/19/15 20:04:17</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">the logical name can't be changed due to the display name story</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">06/09/14 02:14:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel: decide.call.engine</rev.desc>
          <rev.desc sctype="string">Add new exit:</rev.desc>
          <rev.desc sctype="string">if ï¼ˆ"cirelationship"=$L.filename and (not  (null($L.file.save)) or $L.action.save="delete"))</rev.desc>
          <rev.desc sctype="string">return init.change.rel</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel init.change.rel</rev.desc>
          <rev.desc sctype="string">Add line in top</rev.desc>
          <rev.desc sctype="string">if (not null($L.action.save)) then ($L.action=$L.action.save)</rev.desc>
        </rev.desc>
        <change.no type="decimal">109431</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">12/02/13 22:13:47</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel: decide.run.rule</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Move the next.rule up</rev.desc>
        </rev.desc>
        <change.no type="decimal">101796</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">11/30/13 18:47:21</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel: init.change.rel</rev.desc>
          <rev.desc sctype="string">Add line</rev.desc>
          <rev.desc sctype="string">if (not  ($L.ret)) then ($L.exit="badval")</rev.desc>
        </rev.desc>
        <change.no type="decimal">101483</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">11/23/13 22:13:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">start.loop</rev.desc>
          <rev.desc sctype="string">1.</rev.desc>
          <rev.desc sctype="string">Change</rev.desc>
          <rev.desc sctype="string">$L.orig.file=$L.file</rev.desc>
          <rev.desc sctype="string">To</rev.desc>
          <rev.desc sctype="string">if (filename($L.orig.file)~="cirelationship" or $L.action~="delete") then (</rev.desc>
          <rev.desc sctype="string">$L.orig.file=$L.file</rev.desc>
          <rev.desc sctype="string">)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">2.</rev.desc>
          <rev.desc sctype="string">Delete</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (filename($L.orig.file)="cirelationship" and $L.action="delete") then</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(related.cis in $L.orig.file) do (</rev.desc>
          <rev.desc sctype="string">$L.i in related.cis in $L.orig.file=""</rev.desc>
          <rev.desc sctype="string">)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">To</rev.desc>
          <rev.desc sctype="string">if (filename($L.orig.file)~="cirelationship" or $L.action~="delete") then (</rev.desc>
          <rev.desc sctype="string">$L.orig.file=$L.file</rev.desc>
          <rev.desc sctype="string">)</rev.desc>
          <rev.desc sctype="string">$L.active.fields={}</rev.desc>
          <rev.desc sctype="string">$L.active.fields=jscall("dataModEvent.getActiveDmeFields", $L.id.escape, $L.filename)</rev.desc>
          <rev.desc sctype="string">if null($L.active.fields) then (</rev.desc>
          <rev.desc sctype="string">$L.active.fields={}</rev.desc>
          <rev.desc sctype="string">)</rev.desc>
        </rev.desc>
        <change.no type="decimal">101483</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">11/03/13 18:06:46</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Start Panel:</rev.desc>
          <rev.desc sctype="string">set $L.id=nullsub($L.id, "")</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Start.loop</rev.desc>
          <rev.desc sctype="string">if ($L.action="add") then (</rev.desc>
          <rev.desc sctype="string">$L.file.save=$L.file.update;</rev.desc>
          <rev.desc sctype="string">if (filename($L.orig.file)~="cirelationship" and exists("logical.name", $L.file)) then (</rev.desc>
          <rev.desc sctype="string">$L.void=jscall("discoveryEvent.populateNewCI", $L.file, $L.rule);</rev.desc>
          <rev.desc sctype="string">$L.id=logical.name in $L.file;</rev.desc>
          <rev.desc sctype="string">$L.id=nullsub($L.id, "");</rev.desc>
          <rev.desc sctype="string">$L.id.escape=$L.id;</rev.desc>
          <rev.desc sctype="string">$L.void=rtecall("escstr", 0, $L.id.escape)</rev.desc>
          <rev.desc sctype="string">)</rev.desc>
          <rev.desc sctype="string">)</rev.desc>
        </rev.desc>
        <change.no type="decimal">100515</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhenqing</rev.name>
        <rev.date type="dateTime">06/12/13 14:05:29</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Problem in RAD Application ddm.ProcessData</rev.desc>
          <rev.desc sctype="string">if the exit panel is decide.init.ddmRule, the $L.rule.sql will be empty, so get.rules.1 will execute true query.</rev.desc>
          <rev.desc sctype="string">change the exit panel to prepare.rule.lookup work fine, the relateship could be create normally.</rev.desc>
        </rev.desc>
        <change.no type="decimal">95642</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">12/19/12 13:50:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">1) Panel get.file.copy.again:</rev.desc>
          <rev.desc sctype="string">Change</rev.desc>
          <rev.desc sctype="string">query:logical.name="+logical.name in $L.file+" and ucmdb.id=NULL and type="+type in $L.file+"		//query:</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">query:logical.name="+$L.id.escape+" and ucmdb.id=NULL and type="+type in $L.file+"		//query:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">2) Panel reset.update.file:</rev.desc>
          <rev.desc sctype="string">Change</rev.desc>
          <rev.desc sctype="string">$L.void=rtecall("tag", $errcode, $L.tag, $L.file.save)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.id=$L.tag</rev.desc>
          <rev.desc sctype="string">$L.di=index(";", $L.id)</rev.desc>
          <rev.desc sctype="string">$L.void=strclpl($L.id, $L.di)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (filename($L.file)="cirelationship") then (</rev.desc>
          <rev.desc sctype="string">$L.id=logical.name in $L.file</rev.desc>
          <rev.desc sctype="string">)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">$L.id=logical.name in $L.file.save</rev.desc>
          <rev.desc sctype="string">$L.id.escape=$L.id</rev.desc>
          <rev.desc sctype="string">$L.void=rtecall("escstr", 0, $L.id.escape)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">3) Panel start: Add lines</rev.desc>
          <rev.desc sctype="string">$L.id=logical.name in $L.file</rev.desc>
          <rev.desc sctype="string">$L.id.escape=$L.id</rev.desc>
          <rev.desc sctype="string">$L.void=rtecall("escstr", 0, $L.id.escape)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">4) Panel start.loop</rev.desc>
          <rev.desc sctype="string">Delete lines</rev.desc>
          <rev.desc sctype="string">$L.void=rtecall("tag", $errcode, $L.tag, $L.file);</rev.desc>
          <rev.desc sctype="string">$L.id=$L.tag;</rev.desc>
          <rev.desc sctype="string">$L.di=index(";", $L.id);</rev.desc>
          <rev.desc sctype="string">$L.void=strclpl($L.id, $L.di);</rev.desc>
          <rev.desc sctype="string">if (filename($L.file)="cirelationship") then (</rev.desc>
          <rev.desc sctype="string">$L.id=logical.name in $L.file</rev.desc>
          <rev.desc sctype="string">)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Change line</rev.desc>
          <rev.desc sctype="string">$L.active.fields=jscall("dataModEvent.getActiveDmeFields", $L.id, $L.filename)</rev.desc>
          <rev.desc sctype="string">To</rev.desc>
          <rev.desc sctype="string">$L.active.fields=jscall("dataModEvent.getActiveDmeFields", $L.id.escape, $L.filename)</rev.desc>
        </rev.desc>
        <change.no type="decimal">89310</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">11/25/12 14:35:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">1. ddm.processData::setup.change and</rev.desc>
          <rev.desc sctype="string">Add line:</rev.desc>
          <rev.desc sctype="string">type in $L.change=type in $L.file</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">2. ddm.processData::setup.incident</rev.desc>
          <rev.desc sctype="string">Add line:</rev.desc>
          <rev.desc sctype="string">type in $L.incident=type in $L.file</rev.desc>
        </rev.desc>
        <change.no type="decimal">88450</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">09/11/12 19:25:18</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E78698</rev.desc>
          <rev.desc sctype="string">Panel: set reconcile.sql</rev.desc>
          <rev.desc sctype="string">1. Change the SQL to</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.sql=$L.fname+"=\""+$L.fValue+"\"</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">2. Then, check the ucmdb.id by decision panel</rev.desc>
        </rev.desc>
        <change.no type="decimal">78698</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">09/01/12 12:22:37</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">9.31 testing found add relationship directly can't trigger history log.</rev.desc>
        </rev.desc>
        <change.no type="decimal">71482</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">07/14/12 02:34:51</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">check.group.event</rev.desc>
          <rev.desc sctype="string">create.update.copy</rev.desc>
          <rev.desc sctype="string">decide.run.rule</rev.desc>
          <rev.desc sctype="string">decide.set.add</rev.desc>
          <rev.desc sctype="string">init.change.rel</rev.desc>
          <rev.desc sctype="string">init.relationship</rev.desc>
          <rev.desc sctype="string">start</rev.desc>
          <rev.desc sctype="string">start.loop</rev.desc>
          <rev.desc sctype="string">set.ddm.rule</rev.desc>
          <rev.desc sctype="string">Change the condition to handle the cirelationship unplanned/validation process. The core function are done in javascript.</rev.desc>
        </rev.desc>
        <change.no type="decimal">71482</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">05/22/12 03:55:49</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel: set.reconcile.sql</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Change</rev.desc>
          <rev.desc sctype="string">$L.fValue=str($L.fValue)</rev.desc>
          <rev.desc sctype="string">$L.sql=$L.fname+"=\""+$L.fValue+"\" and ucmdb.id=NULL"</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">To</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.fValue=str($L.fValue)</rev.desc>
          <rev.desc sctype="string">$L.rc=0</rev.desc>
          <rev.desc sctype="string">$L.ret=rtecall("escstr", $L.rc, $L.fValue)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.sql=$L.fname+"=\""+$L.fValue+"\" and ucmdb.id=NULL"</rev.desc>
          <rev.desc sctype="string">$L.sql=nullsub($L.sql, "false")</rev.desc>
        </rev.desc>
        <change.no type="decimal">75743</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">03/17/12 22:44:42</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E73701 A uCMDB expression that is defined in extaccess is executed twice.</rev.desc>
          <rev.desc sctype="string">Review By Qi, Qing-Song, cleanup variable $extaccess in panel:start in case the express execute twice</rev.desc>
        </rev.desc>
        <change.no type="decimal">73701</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">02/20/12 01:50:37</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">start</rev.desc>
          <rev.desc sctype="string">fix quote issue, simply remove it from logical.name to avoid query syntax issue</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">02/12/12 17:58:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">start.loop</rev.desc>
          <rev.desc sctype="string">fix istatus can't get old value issue</rev.desc>
        </rev.desc>
        <change.no type="decimal">62429</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">02/09/12 14:30:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">decide.overall.action  avoid to use $L.mode which may impact the call.engine</rev.desc>
        </rev.desc>
        <change.no type="decimal">62429</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">02/04/12 07:17:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">start.loop,setup.incident,setup.change,decide.overall.action,device.create.group</rev.desc>
          <rev.desc sctype="string">support logical delete</rev.desc>
        </rev.desc>
        <change.no type="decimal">62429</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">01/28/12 22:18:33</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel:check.post.exception</rev.desc>
          <rev.desc sctype="string">avoid delete can't create change for it's $L.elng=0 always. (will not change any attribute)</rev.desc>
        </rev.desc>
        <change.no type="decimal">62429</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">12/31/11 13:22:40</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel:get.file.copy.again</rev.desc>
          <rev.desc sctype="string">change the query rule limit on the same ci type</rev.desc>
        </rev.desc>
        <change.no type="decimal">62429</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">12/26/11 07:48:23</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel:merge.record</rev.desc>
          <rev.desc sctype="string">set the orig file when it use createonly</rev.desc>
        </rev.desc>
        <change.no type="decimal">62429</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">12/25/11 09:53:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel: start.loop</rev.desc>
          <rev.desc sctype="string">add the defalut value set during ci update/add</rev.desc>
        </rev.desc>
        <change.no type="decimal">62429</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">12/16/11 00:11:37</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel: setup.incident</rev.desc>
          <rev.desc sctype="string">added the statements:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.expression="var incident = vars.$L_incident; var id=vars.$L_id; var exceptionFields=vars.$L_exception_field;"</rev.desc>
          <rev.desc sctype="string">$L.expression+="var oldValues=vars.$L_exception_old; var newValues=vars.$L_exception_new; var action=vars.$L_action; var foreignId = vars.$L_foreignId;"</rev.desc>
          <rev.desc sctype="string">$L.expression+=str(incidentExpressions in $L.rule)</rev.desc>
          <rev.desc sctype="string">js($L.expression)</rev.desc>
        </rev.desc>
        <change.no type="decimal">70871</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">11/19/11 23:18:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel:start.loop</rev.desc>
          <rev.desc sctype="string">fix cirelationship logical.name renamed issue.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">11/17/11 02:58:57</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel:start.loop</rev.desc>
          <rev.desc sctype="string">add unique name for update records. (the old one will change wrong ci record</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">11/05/11 07:29:44</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Panel: check.parameters</rev.desc>
          <rev.desc sctype="string">added new exit: set.invalid.data.del</rev.desc>
          <rev.desc sctype="string">with condition: not $L.valid and $L.action="delete"</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">changed the condition for exit: set.invalid.data</rev.desc>
          <rev.desc sctype="string">from</rev.desc>
          <rev.desc sctype="string">not $L.valid</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">not $L.valid and $L.action~="delete"</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Added new panel: set.invalid.data.del in process type with statements:</rev.desc>
          <rev.desc sctype="string">$L.exit="invalid.data.del"</rev.desc>
          <rev.desc sctype="string">exit: normal: exit.normal</rev.desc>
        </rev.desc>
        <change.no type="decimal">69774</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">11/01/11 16:24:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">66941 [CI Deletion Enhancement] CI record is removed directly although "Update record to status" option is selected for to be deleted record.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">panjun</rev.name>
        <rev.date type="dateTime">09/03/11 07:59:22</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QCCR1E68428 Updated to Open: "meaningless SQL statements consume 70% DB time when sync CI from uCMDB to SM</rev.desc>
          <rev.desc sctype="string">Panel:get.old.get.old.setup</rev.desc>
          <rev.desc sctype="string">remove useless tagquery for it always null and this cause the performance issue</rev.desc>
        </rev.desc>
        <change.no type="decimal">68428</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">08/19/11 02:39:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">[CI Deletion Enhancement]</rev.desc>
          <rev.desc sctype="string">Panel: decide.overall.action</rev.desc>
          <rev.desc sctype="string">Add statements:</rev.desc>
          <rev.desc sctype="string">if ($L.related="deleteByStatus" and $L.action="*SOAP*delete" and $L.filename~="cirelationship") then ($L.action="*SOAP*save";istatus in $L.file=deleteStatus in $L.rule)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if ($L.related="addSetDep" and $L.action="*SOAP*add" and $L.filename="cirelationship") then (outage.dependency in $L.file=true;outage.threshold in $L.file=1)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: create.update.copy</rev.desc>
          <rev.desc sctype="string">Add statements:</rev.desc>
          <rev.desc sctype="string">if ($L.action="delete" and filename($L.file)~="cirelationship") then ($L.invalidDel=jscall("discoveryEvent.invalidDelCall", filename($L.file), type in $L.file.update))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel: decide.merge</rev.desc>
          <rev.desc sctype="string">new exit:exit.normal</rev.desc>
        </rev.desc>
        <change.no type="decimal">66941</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">08/05/11 11:05:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: merge.record</rev.desc>
          <rev.desc sctype="string">Change statements from</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng($L.fields) do ($L.field.name=$L.i in $L.fields;$L.index=index("[", $L.field.name);if ($L.index&gt;0) then ($L.field.name=substr($L.field.name, 1, $L.index - 1));$L.statement=$L.field.name+" in $L.file.update="+$L.field.name+" in $L.file";$L.void=evaluate(parse($L.statement, 11)))</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng($L.fields) do ($L.field.name=$L.i in $L.fields;$L.index=index("[", $L.field.name);if ($L.index&gt;0) then ($L.struct.name=substr($L.field.name, 1, $L.index - 1);$L.field.name=substr($L.field.name, $L.index+1, lng($L.field.name) - $L.index - 1);$L.length=max(lng($L.field.name in $L.file), lng($L.field.name in $L.file.update));$L.statement="for(var i=0; i&lt;"+$L.length+"; i++) { system.vars.$L_file_update['"+$L.struct.name+"'][i]['"+$L.field.name+"'] = system.vars.$L_file['"+$L.struct.name+"'][i]['"+$L.field.name+"'] }";js($L.statement)) else ($L.statement=$L.field.name+" in $L.file.update="+$L.field.name+" in $L.file";$L.void=evaluate(parse($L.statement, 11))))</rev.desc>
        </rev.desc>
        <change.no type="decimal">67447</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">08/05/11 10:37:02</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: start</rev.desc>
          <rev.desc sctype="string">added the following statements,</rev.desc>
          <rev.desc sctype="string">$L.extaccess=$extaccess</rev.desc>
          <rev.desc sctype="string">$L.exp.lng=lng(denull(expressions in $L.extaccess))</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to $L.exp.lng do (if (not null($L.i in expressions in $L.extaccess)) then ($L.void=evaluate($L.i in expressions in $L.extaccess)))</rev.desc>
        </rev.desc>
        <change.no type="decimal">66514</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">08/05/11 10:18:26</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: check.post.exception</rev.desc>
          <rev.desc sctype="string">changed the statement</rev.desc>
          <rev.desc sctype="string">if ($L.elng=0) then ($L.related="")</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">if ($L.elng=0) then ($L.related="none")</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel: decide.call.engine</rev.desc>
          <rev.desc sctype="string">changed the condition from</rev.desc>
          <rev.desc sctype="string">lng($L.related)=0</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">$L.mode="add" and $L.related="none"</rev.desc>
        </rev.desc>
        <change.no type="decimal">66293</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">08/05/11 10:09:45</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: start.loop</rev.desc>
          <rev.desc sctype="string">changed the statement</rev.desc>
          <rev.desc sctype="string">if ($L.action="add") then for $L.i = 1 to lng(denull($L.fields)) do ($L.field=$L.i in $L.fields;if (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=$L.field in $L.old;$L.x in $L.exception.new=$L.field in $L.orig.file)) else for $L.i = 1 to lng(denull(rules in $L.rule)) do ($L.field=1 in $L.i in rules in $L.rule;$L.cond=nullsub(2 in $L.i in rules in $L.rule, true);if (evaluate($L.cond) and (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0)) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=$L.field in $L.old;$L.x in $L.exception.new=$L.field in $L.orig.file))</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">if ($L.action="add") then for $L.i = 1 to lng(denull($L.fields)) do ($L.field=$L.i in $L.fields;$L.index=index("[", $L.field);if ($L.index&gt;0) then ($L.tmpindex=$L.index;while ($L.tmpindex&gt;0) do ($L.index=$L.tmpindex+1;$L.tmpindex=index("[", $L.field, $L.index));$L.field=substr($L.field, $L.index, lng($L.field) - $L.index));if (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0) then ($L.x=lng(denull($L.exception.field))+1;if (index($L.field, fieldName in $L.rule)&gt;0) then ($L.x in $L.exception.field=$L.field) else ($L.x in $L.exception.field=$L.i in $L.fields);$L.x in $L.exception.old=str($L.field in $L.old);$L.x in $L.exception.new=str($L.field in $L.orig.file))) else for $L.i = 1 to lng(denull(rules in $L.rule)) do ($L.field=1 in $L.i in rules in $L.rule;$L.cond=nullsub(2 in $L.i in rules in $L.rule, true);if (evaluate($L.cond) and (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0)) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=str($L.field in $L.old);$L.x in $L.exception.new=str($L.field in $L.orig.file)))</rev.desc>
        </rev.desc>
        <change.no type="decimal">66643</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">08/05/11 09:52:06</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: get.file.copy</rev.desc>
          <rev.desc sctype="string">changed exit if no records selected by query from init.reconcile to decide.get.file.copy.again</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">created new decision panel with name: decide.get.file.copy.again</rev.desc>
          <rev.desc sctype="string">added exit get.file.copy.again with codition nullsub($L.from.ucmdb, false) and not null(logical.name in $L.file)</rev.desc>
          <rev.desc sctype="string">exit normal: init.reconcile, error: exit.error.msg</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">create new select panel with name: get.file.copy.again</rev.desc>
          <rev.desc sctype="string">file variable: $L.file.update</rev.desc>
          <rev.desc sctype="string">query: "logical.name=\""+logical.name in $L.file+"\" and ucmdb.id=NULL"</rev.desc>
          <rev.desc sctype="string">exit if no records selected by query: init.reconcile</rev.desc>
          <rev.desc sctype="string">exit if one records selected by query: create.update.copy</rev.desc>
          <rev.desc sctype="string">exit normal: create.update.copy, error: exit.error.msg</rev.desc>
        </rev.desc>
        <change.no type="decimal">66387</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">05/16/11 19:37:25</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: merge.record</rev.desc>
          <rev.desc sctype="string">Change statements from</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng($L.fields) do ($L.field.name=$L.i in $L.fields;$L.index=index("[", $L.field.name);if ($L.index&gt;0) then ($L.tmpindex=$L.index;while ($L.tmpindex&gt;0) do ($L.index=$L.tmpindex+1;$L.tmpindex=index("[", $L.field.name, $L.index));$L.field.name=substr($L.field.name, $L.index, lng($L.field.name) - $L.index));$L.statement=$L.field.name+" in $L.file.update="+$L.field.name+" in $L.file";$L.void=evaluate(parse($L.statement, 11)))</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng($L.fields) do ($L.field.name=$L.i in $L.fields;$L.index=index("[", $L.field.name);if ($L.index&gt;0) then ($L.field.name=substr($L.field.name, 1, $L.index - 1));$L.statement=$L.field.name+" in $L.file.update="+$L.field.name+" in $L.file";$L.void=evaluate(parse($L.statement, 11)))</rev.desc>
        </rev.desc>
        <change.no type="decimal">64683</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">05/14/11 00:35:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: get.old.setup</rev.desc>
          <rev.desc sctype="string">added statements in the end:</rev.desc>
          <rev.desc sctype="string">$L.sql=nullsub($L.sql, false)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel: try.reconcile</rev.desc>
          <rev.desc sctype="string">added new sort fields in order: sequence, fieldName</rev.desc>
        </rev.desc>
        <change.no type="decimal">64393</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">04/11/11 14:36:26</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: start</rev.desc>
          <rev.desc sctype="string">added statements:</rev.desc>
          <rev.desc sctype="string">$L.valid=true</rev.desc>
          <rev.desc sctype="string">$L.filename=filename($L.file)</rev.desc>
          <rev.desc sctype="string">if ($L.filename="cirelationship") then ($L.valid=jscall("discoveryEvent.translateUcmdbRelationship", $L.file))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel: check.parameters</rev.desc>
          <rev.desc sctype="string">added new exit: set.invalid.data with condition: not $L.valid</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">new panel: set.invalid.data in process type</rev.desc>
          <rev.desc sctype="string">added statements:</rev.desc>
          <rev.desc sctype="string">$L.exit="invalid.data"</rev.desc>
          <rev.desc sctype="string">exit:</rev.desc>
          <rev.desc sctype="string">normal: exit.normal, error: exit.error.msg</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel: get.old.setup</rev.desc>
          <rev.desc sctype="string">removed statements:</rev.desc>
          <rev.desc sctype="string">$L.filename=filename($L.file)</rev.desc>
          <rev.desc sctype="string">if ($L.filename="cirelationship") then ($L.valid=jscall("discoveryEvent.translateUcmdbRelationship", $L.file))</rev.desc>
        </rev.desc>
        <change.no type="decimal">62555</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">12/27/10 01:34:10</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: start.loop</rev.desc>
          <rev.desc sctype="string">Change statements from</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to $L.lng do ($L.field=1 in $L.i in rules in $L.rule;$L.cond=nullsub(2 in $L.i in rules in $L.rule, true);if (evaluate($L.cond) and (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0)) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=$L.field in $L.old;$L.x in $L.exception.new=$L.field in $L.orig.file))</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">if ($L.action="add") then for $L.i = 1 to lng(denull($L.fields)) do ($L.field=$L.i in $L.fields;if (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=$L.field in $L.old;$L.x in $L.exception.new=$L.field in $L.orig.file)) else for $L.i = 1 to lng(denull(rules in $L.rule)) do ($L.field=1 in $L.i in rules in $L.rule;$L.cond=nullsub(2 in $L.i in rules in $L.rule, true);if (evaluate($L.cond) and (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0)) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=$L.field in $L.old;$L.x in $L.exception.new=$L.field in $L.orig.file))</rev.desc>
        </rev.desc>
        <change.no type="decimal">59422</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">10/03/21 15:53:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Add parameter, label: Fields to be updated:, Input Field: names, variable: $INTO.FIELDS</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: start, add statement, $L.fields=nullsub($INTO.FIELDS, {})</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Panel: create.update.copy, change exits normal from duplicate.copy to decide.merge</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Add panel, type: decision, name: decide.merge</rev.desc>
          <rev.desc sctype="string">exit: merge.record, condition for exit: lng($L.fields)&gt;0</rev.desc>
          <rev.desc sctype="string">exits normal: duplicate.copy, error: exit.error.msg</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">New panel, type: process, name: merge.record</rev.desc>
          <rev.desc sctype="string">statements:</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng($L.fields) do ($L.field.name=$L.i in $L.fields;$L.index=index("[", $L.field.name);if ($L.index&gt;0) then ($L.tmpindex=$L.index;while ($L.tmpindex&gt;0) do ($L.index=$L.tmpindex+1;$L.tmpindex=index("[", $L.field.name, $L.index));$L.field.name=substr($L.field.name, $L.index, lng($L.field.name) - $L.index));$L.statement=$L.field.name+" in $L.file.update="+$L.field.name+" in $L.file";$L.void=evaluate(parse($L.statement, 11)))</rev.desc>
        </rev.desc>
        <change.no type="decimal">54707</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/26/24 22:42:36</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">on panel decide call engine added another exit.normal condition</rev.desc>
        </rev.desc>
        <change.no type="decimal">52529</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/26/24 19:42:02</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">on panel check.post.exception</rev.desc>
          <rev.desc sctype="string">added a line so that when no excption found, do not create another change or incident since one already exist</rev.desc>
        </rev.desc>
        <change.no type="decimal">52529</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/26/19 11:27:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added the following line in panel prepare.rule.lookup</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (filename($L.orig.file)="cirelationship" and $L.action="delete") then for $L.i = 1 to lng(related.cis in $L.orig.file) do ($L.i in related.cis in $L.orig.file="")</rev.desc>
        </rev.desc>
        <change.no type="decimal">48731</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">09/03/23 12:49:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">QC48741 - Modified the 'set.add' panel to include the following expression:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">if (filename($L.file)="cirelationship") then ($L.id=logical.name in $L.file)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">This will prevent the 'Affected CI' field for all incidents and changes created for UCMDB relationships from being set to &lt;relationship.name&gt;;&lt;logical.name&gt;.</rev.desc>
        </rev.desc>
        <change.no type="decimal">48741</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/02/24 05:19:06</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">on panel set.reconsile.sql, add the line at the end to make sure reconciliation rule only applies to CI from same company in multi-tenant integration.</rev.desc>
        </rev.desc>
        <change.no type="decimal">31219</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ffaegh</rev.name>
        <rev.date type="dateTime">09/02/16 23:14:29</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Set the company field in dataModEvent when replicating CIs from ucmdb for multi tenant.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Modified set.event.fields and setup the company field. added:</rev.desc>
          <rev.desc sctype="string">if ($G.multi=true)  then (company in $L.event= company in $L.file)</rev.desc>
        </rev.desc>
        <change.no type="decimal">32155</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/02/10 05:00:03</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">on panel start.loop, save ucmdb.id first and set it to $L.file at the end. On panel set.recouncile.rule.sql, add ucmdb.id=NULL at the end of the sql</rev.desc>
        </rev.desc>
        <change.no type="decimal">48418</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/02/08 07:24:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">on setup.change, add $L.file when calling script populateChange</rev.desc>
        </rev.desc>
        <change.no type="decimal">31333</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ffaegh</rev.name>
        <rev.date type="dateTime">09/01/26 01:11:59</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added the following line to the panel 'setup.incident' in order to set the field to true when the incident is created via ucmdb discovery:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">modEvent in $L.incident=true</rev.desc>
        </rev.desc>
        <change.no type="decimal">31451</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/01/25 06:13:22</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">on panel setup.incident, pass in $L.file when calling javascript popualteIncident</rev.desc>
        </rev.desc>
        <change.no type="decimal">31448</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/01/24 07:19:48</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add if ($L.action="add") then ($L.action="ignore") to set.incident.id os that we will not attempt to add the ci when the rule says to open incident.</rev.desc>
        </rev.desc>
        <change.no type="decimal">31332</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">09/01/24 05:00:03</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">convert company from id to company code which will be used as part of unique key for query replciated ci.</rev.desc>
        </rev.desc>
        <change.no type="decimal">29015</change.no>
      </rev.array>
    </rev.array>
    <descript sctype="array">
      <descript sctype="string">Delete panel next.rule</descript>
      <descript sctype="string">Roll back previous modification, and modified below panels to align with the new requirement</descript>
      <descript sctype="string">get.old.setup</descript>
      <descript sctype="string">init.reconcile.sql</descript>
      <descript sctype="string">prepare.rule.lookup</descript>
      <descript sctype="string">decide.init.ddmRule</descript>
      <descript sctype="string">decide.run.rule</descript>
      <descript sctype="string">Modified panel decide.overall.action to set udmdb.id as NULL when removing CI from ucmdb.</descript>
      <descript sctype="string">Story ucmdb reconciliation rule enhancement to directly read ddmreconcile table, set ucmdb.id as default reconcile rule</descript>
      <descript sctype="string">Story ucmdb reconciliation rule enhancement to directly read ddmreconcile table</descript>
      <descript sctype="string">the logical name can't be changed due to the display name story</descript>
      <descript sctype="string">Panel: decide.call.engine</descript>
      <descript sctype="string">Add new exit:</descript>
      <descript sctype="string">if ï¼ˆ"cirelationship"=$L.filename and (not  (null($L.file.save)) or $L.action.save="delete"))</descript>
      <descript sctype="string">return init.change.rel</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel init.change.rel</descript>
      <descript sctype="string">Add line in top</descript>
      <descript sctype="string">if (not null($L.action.save)) then ($L.action=$L.action.save)</descript>
      <descript sctype="string">Panel: decide.run.rule</descript>
      <descript sctype="string"/>
      <descript sctype="string">Move the next.rule up</descript>
      <descript sctype="string">Panel: init.change.rel</descript>
      <descript sctype="string">Add line</descript>
      <descript sctype="string">if (not  ($L.ret)) then ($L.exit="badval")</descript>
      <descript sctype="string">start.loop</descript>
      <descript sctype="string">1.</descript>
      <descript sctype="string">Change</descript>
      <descript sctype="string">$L.orig.file=$L.file</descript>
      <descript sctype="string">To</descript>
      <descript sctype="string">if (filename($L.orig.file)~="cirelationship" or $L.action~="delete") then (</descript>
      <descript sctype="string">$L.orig.file=$L.file</descript>
      <descript sctype="string">)</descript>
      <descript sctype="string"/>
      <descript sctype="string">2.</descript>
      <descript sctype="string">Delete</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (filename($L.orig.file)="cirelationship" and $L.action="delete") then</descript>
      <descript sctype="string">for $L.i = 1 to lng(related.cis in $L.orig.file) do (</descript>
      <descript sctype="string">$L.i in related.cis in $L.orig.file=""</descript>
      <descript sctype="string">)</descript>
      <descript sctype="string"/>
      <descript sctype="string"/>
      <descript sctype="string">To</descript>
      <descript sctype="string">if (filename($L.orig.file)~="cirelationship" or $L.action~="delete") then (</descript>
      <descript sctype="string">$L.orig.file=$L.file</descript>
      <descript sctype="string">)</descript>
      <descript sctype="string">$L.active.fields={}</descript>
      <descript sctype="string">$L.active.fields=jscall("dataModEvent.getActiveDmeFields", $L.id.escape, $L.filename)</descript>
      <descript sctype="string">if null($L.active.fields) then (</descript>
      <descript sctype="string">$L.active.fields={}</descript>
      <descript sctype="string">)</descript>
      <descript sctype="string">Start Panel:</descript>
      <descript sctype="string">set $L.id=nullsub($L.id, "")</descript>
      <descript sctype="string"/>
      <descript sctype="string">Start.loop</descript>
      <descript sctype="string">if ($L.action="add") then (</descript>
      <descript sctype="string">$L.file.save=$L.file.update;</descript>
      <descript sctype="string">if (filename($L.orig.file)~="cirelationship" and exists("logical.name", $L.file)) then (</descript>
      <descript sctype="string">$L.void=jscall("discoveryEvent.populateNewCI", $L.file, $L.rule);</descript>
      <descript sctype="string">$L.id=logical.name in $L.file;</descript>
      <descript sctype="string">$L.id=nullsub($L.id, "");</descript>
      <descript sctype="string">$L.id.escape=$L.id;</descript>
      <descript sctype="string">$L.void=rtecall("escstr", 0, $L.id.escape)</descript>
      <descript sctype="string">)</descript>
      <descript sctype="string">)</descript>
      <descript sctype="string">Problem in RAD Application ddm.ProcessData</descript>
      <descript sctype="string">if the exit panel is decide.init.ddmRule, the $L.rule.sql will be empty, so get.rules.1 will execute true query.</descript>
      <descript sctype="string">change the exit panel to prepare.rule.lookup work fine, the relateship could be create normally.</descript>
      <descript sctype="string">1) Panel get.file.copy.again:</descript>
      <descript sctype="string">Change</descript>
      <descript sctype="string">query:logical.name="+logical.name in $L.file+" and ucmdb.id=NULL and type="+type in $L.file+"		//query:</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">query:logical.name="+$L.id.escape+" and ucmdb.id=NULL and type="+type in $L.file+"		//query:</descript>
      <descript sctype="string"/>
      <descript sctype="string">2) Panel reset.update.file:</descript>
      <descript sctype="string">Change</descript>
      <descript sctype="string">$L.void=rtecall("tag", $errcode, $L.tag, $L.file.save)</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.id=$L.tag</descript>
      <descript sctype="string">$L.di=index(";", $L.id)</descript>
      <descript sctype="string">$L.void=strclpl($L.id, $L.di)</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (filename($L.file)="cirelationship") then (</descript>
      <descript sctype="string">$L.id=logical.name in $L.file</descript>
      <descript sctype="string">)</descript>
      <descript sctype="string"/>
      <descript sctype="string">to</descript>
      <descript sctype="string">$L.id=logical.name in $L.file.save</descript>
      <descript sctype="string">$L.id.escape=$L.id</descript>
      <descript sctype="string">$L.void=rtecall("escstr", 0, $L.id.escape)</descript>
      <descript sctype="string"/>
      <descript sctype="string">3) Panel start: Add lines</descript>
      <descript sctype="string">$L.id=logical.name in $L.file</descript>
      <descript sctype="string">$L.id.escape=$L.id</descript>
      <descript sctype="string">$L.void=rtecall("escstr", 0, $L.id.escape)</descript>
      <descript sctype="string"/>
      <descript sctype="string">4) Panel start.loop</descript>
      <descript sctype="string">Delete lines</descript>
      <descript sctype="string">$L.void=rtecall("tag", $errcode, $L.tag, $L.file);</descript>
      <descript sctype="string">$L.id=$L.tag;</descript>
      <descript sctype="string">$L.di=index(";", $L.id);</descript>
      <descript sctype="string">$L.void=strclpl($L.id, $L.di);</descript>
      <descript sctype="string">if (filename($L.file)="cirelationship") then (</descript>
      <descript sctype="string">$L.id=logical.name in $L.file</descript>
      <descript sctype="string">)</descript>
      <descript sctype="string"/>
      <descript sctype="string">Change line</descript>
      <descript sctype="string">$L.active.fields=jscall("dataModEvent.getActiveDmeFields", $L.id, $L.filename)</descript>
      <descript sctype="string">To</descript>
      <descript sctype="string">$L.active.fields=jscall("dataModEvent.getActiveDmeFields", $L.id.escape, $L.filename)</descript>
      <descript sctype="string">1. ddm.processData::setup.change and</descript>
      <descript sctype="string">Add line:</descript>
      <descript sctype="string">type in $L.change=type in $L.file</descript>
      <descript sctype="string"/>
      <descript sctype="string">2. ddm.processData::setup.incident</descript>
      <descript sctype="string">Add line:</descript>
      <descript sctype="string">type in $L.incident=type in $L.file</descript>
      <descript sctype="string">QCCR1E78698</descript>
      <descript sctype="string">Panel: set reconcile.sql</descript>
      <descript sctype="string">1. Change the SQL to</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.sql=$L.fname+"=\""+$L.fValue+"\"</descript>
      <descript sctype="string"/>
      <descript sctype="string">2. Then, check the ucmdb.id by decision panel</descript>
      <descript sctype="string">9.31 testing found add relationship directly can't trigger history log.</descript>
      <descript sctype="string">check.group.event</descript>
      <descript sctype="string">create.update.copy</descript>
      <descript sctype="string">decide.run.rule</descript>
      <descript sctype="string">decide.set.add</descript>
      <descript sctype="string">init.change.rel</descript>
      <descript sctype="string">init.relationship</descript>
      <descript sctype="string">start</descript>
      <descript sctype="string">start.loop</descript>
      <descript sctype="string">set.ddm.rule</descript>
      <descript sctype="string">Change the condition to handle the cirelationship unplanned/validation process. The core function are done in javascript.</descript>
      <descript sctype="string">Panel: set.reconcile.sql</descript>
      <descript sctype="string"/>
      <descript sctype="string">Change</descript>
      <descript sctype="string">$L.fValue=str($L.fValue)</descript>
      <descript sctype="string">$L.sql=$L.fname+"=\""+$L.fValue+"\" and ucmdb.id=NULL"</descript>
      <descript sctype="string"/>
      <descript sctype="string">To</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.fValue=str($L.fValue)</descript>
      <descript sctype="string">$L.rc=0</descript>
      <descript sctype="string">$L.ret=rtecall("escstr", $L.rc, $L.fValue)</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.sql=$L.fname+"=\""+$L.fValue+"\" and ucmdb.id=NULL"</descript>
      <descript sctype="string">$L.sql=nullsub($L.sql, "false")</descript>
      <descript sctype="string">QCCR1E73701 A uCMDB expression that is defined in extaccess is executed twice.</descript>
      <descript sctype="string">Review By Qi, Qing-Song, cleanup variable $extaccess in panel:start in case the express execute twice</descript>
      <descript sctype="string">start</descript>
      <descript sctype="string">fix quote issue, simply remove it from logical.name to avoid query syntax issue</descript>
      <descript sctype="string">start.loop</descript>
      <descript sctype="string">fix istatus can't get old value issue</descript>
      <descript sctype="string">decide.overall.action  avoid to use $L.mode which may impact the call.engine</descript>
      <descript sctype="string">start.loop,setup.incident,setup.change,decide.overall.action,device.create.group</descript>
      <descript sctype="string">support logical delete</descript>
      <descript sctype="string">Panel:check.post.exception</descript>
      <descript sctype="string">avoid delete can't create change for it's $L.elng=0 always. (will not change any attribute)</descript>
      <descript sctype="string">Panel:get.file.copy.again</descript>
      <descript sctype="string">change the query rule limit on the same ci type</descript>
      <descript sctype="string">Panel:merge.record</descript>
      <descript sctype="string">set the orig file when it use createonly</descript>
      <descript sctype="string">Panel: start.loop</descript>
      <descript sctype="string">add the defalut value set during ci update/add</descript>
      <descript sctype="string">Panel: setup.incident</descript>
      <descript sctype="string">added the statements:</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.expression="var incident = vars.$L_incident; var id=vars.$L_id; var exceptionFields=vars.$L_exception_field;"</descript>
      <descript sctype="string">$L.expression+="var oldValues=vars.$L_exception_old; var newValues=vars.$L_exception_new; var action=vars.$L_action; var foreignId = vars.$L_foreignId;"</descript>
      <descript sctype="string">$L.expression+=str(incidentExpressions in $L.rule)</descript>
      <descript sctype="string">js($L.expression)</descript>
      <descript sctype="string">Panel:start.loop</descript>
      <descript sctype="string">fix cirelationship logical.name renamed issue.</descript>
      <descript sctype="string">Panel:start.loop</descript>
      <descript sctype="string">add unique name for update records. (the old one will change wrong ci record</descript>
      <descript sctype="string">Panel: check.parameters</descript>
      <descript sctype="string">added new exit: set.invalid.data.del</descript>
      <descript sctype="string">with condition: not $L.valid and $L.action="delete"</descript>
      <descript sctype="string"/>
      <descript sctype="string">changed the condition for exit: set.invalid.data</descript>
      <descript sctype="string">from</descript>
      <descript sctype="string">not $L.valid</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">not $L.valid and $L.action~="delete"</descript>
      <descript sctype="string"/>
      <descript sctype="string">Added new panel: set.invalid.data.del in process type with statements:</descript>
      <descript sctype="string">$L.exit="invalid.data.del"</descript>
      <descript sctype="string">exit: normal: exit.normal</descript>
      <descript sctype="string">66941 [CI Deletion Enhancement] CI record is removed directly although "Update record to status" option is selected for to be deleted record.</descript>
      <descript sctype="string">QCCR1E68428 Updated to Open: "meaningless SQL statements consume 70% DB time when sync CI from uCMDB to SM</descript>
      <descript sctype="string">Panel:get.old.get.old.setup</descript>
      <descript sctype="string">remove useless tagquery for it always null and this cause the performance issue</descript>
      <descript sctype="string">[CI Deletion Enhancement]</descript>
      <descript sctype="string">Panel: decide.overall.action</descript>
      <descript sctype="string">Add statements:</descript>
      <descript sctype="string">if ($L.related="deleteByStatus" and $L.action="*SOAP*delete" and $L.filename~="cirelationship") then ($L.action="*SOAP*save";istatus in $L.file=deleteStatus in $L.rule)</descript>
      <descript sctype="string"/>
      <descript sctype="string">if ($L.related="addSetDep" and $L.action="*SOAP*add" and $L.filename="cirelationship") then (outage.dependency in $L.file=true;outage.threshold in $L.file=1)</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: create.update.copy</descript>
      <descript sctype="string">Add statements:</descript>
      <descript sctype="string">if ($L.action="delete" and filename($L.file)~="cirelationship") then ($L.invalidDel=jscall("discoveryEvent.invalidDelCall", filename($L.file), type in $L.file.update))</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel: decide.merge</descript>
      <descript sctype="string">new exit:exit.normal</descript>
      <descript sctype="string">panel: merge.record</descript>
      <descript sctype="string">Change statements from</descript>
      <descript sctype="string">for $L.i = 1 to lng($L.fields) do ($L.field.name=$L.i in $L.fields;$L.index=index("[", $L.field.name);if ($L.index&gt;0) then ($L.field.name=substr($L.field.name, 1, $L.index - 1));$L.statement=$L.field.name+" in $L.file.update="+$L.field.name+" in $L.file";$L.void=evaluate(parse($L.statement, 11)))</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">for $L.i = 1 to lng($L.fields) do ($L.field.name=$L.i in $L.fields;$L.index=index("[", $L.field.name);if ($L.index&gt;0) then ($L.struct.name=substr($L.field.name, 1, $L.index - 1);$L.field.name=substr($L.field.name, $L.index+1, lng($L.field.name) - $L.index - 1);$L.length=max(lng($L.field.name in $L.file), lng($L.field.name in $L.file.update));$L.statement="for(var i=0; i&lt;"+$L.length+"; i++) { system.vars.$L_file_update['"+$L.struct.name+"'][i]['"+$L.field.name+"'] = system.vars.$L_file['"+$L.struct.name+"'][i]['"+$L.field.name+"'] }";js($L.statement)) else ($L.statement=$L.field.name+" in $L.file.update="+$L.field.name+" in $L.file";$L.void=evaluate(parse($L.statement, 11))))</descript>
      <descript sctype="string">panel: start</descript>
      <descript sctype="string">added the following statements,</descript>
      <descript sctype="string">$L.extaccess=$extaccess</descript>
      <descript sctype="string">$L.exp.lng=lng(denull(expressions in $L.extaccess))</descript>
      <descript sctype="string">for $L.i = 1 to $L.exp.lng do (if (not null($L.i in expressions in $L.extaccess)) then ($L.void=evaluate($L.i in expressions in $L.extaccess)))</descript>
      <descript sctype="string">panel: check.post.exception</descript>
      <descript sctype="string">changed the statement</descript>
      <descript sctype="string">if ($L.elng=0) then ($L.related="")</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">if ($L.elng=0) then ($L.related="none")</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel: decide.call.engine</descript>
      <descript sctype="string">changed the condition from</descript>
      <descript sctype="string">lng($L.related)=0</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">$L.mode="add" and $L.related="none"</descript>
      <descript sctype="string">panel: start.loop</descript>
      <descript sctype="string">changed the statement</descript>
      <descript sctype="string">if ($L.action="add") then for $L.i = 1 to lng(denull($L.fields)) do ($L.field=$L.i in $L.fields;if (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=$L.field in $L.old;$L.x in $L.exception.new=$L.field in $L.orig.file)) else for $L.i = 1 to lng(denull(rules in $L.rule)) do ($L.field=1 in $L.i in rules in $L.rule;$L.cond=nullsub(2 in $L.i in rules in $L.rule, true);if (evaluate($L.cond) and (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0)) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=$L.field in $L.old;$L.x in $L.exception.new=$L.field in $L.orig.file))</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">if ($L.action="add") then for $L.i = 1 to lng(denull($L.fields)) do ($L.field=$L.i in $L.fields;$L.index=index("[", $L.field);if ($L.index&gt;0) then ($L.tmpindex=$L.index;while ($L.tmpindex&gt;0) do ($L.index=$L.tmpindex+1;$L.tmpindex=index("[", $L.field, $L.index));$L.field=substr($L.field, $L.index, lng($L.field) - $L.index));if (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0) then ($L.x=lng(denull($L.exception.field))+1;if (index($L.field, fieldName in $L.rule)&gt;0) then ($L.x in $L.exception.field=$L.field) else ($L.x in $L.exception.field=$L.i in $L.fields);$L.x in $L.exception.old=str($L.field in $L.old);$L.x in $L.exception.new=str($L.field in $L.orig.file))) else for $L.i = 1 to lng(denull(rules in $L.rule)) do ($L.field=1 in $L.i in rules in $L.rule;$L.cond=nullsub(2 in $L.i in rules in $L.rule, true);if (evaluate($L.cond) and (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0)) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=str($L.field in $L.old);$L.x in $L.exception.new=str($L.field in $L.orig.file)))</descript>
      <descript sctype="string">panel: get.file.copy</descript>
      <descript sctype="string">changed exit if no records selected by query from init.reconcile to decide.get.file.copy.again</descript>
      <descript sctype="string"/>
      <descript sctype="string">created new decision panel with name: decide.get.file.copy.again</descript>
      <descript sctype="string">added exit get.file.copy.again with codition nullsub($L.from.ucmdb, false) and not null(logical.name in $L.file)</descript>
      <descript sctype="string">exit normal: init.reconcile, error: exit.error.msg</descript>
      <descript sctype="string"/>
      <descript sctype="string">create new select panel with name: get.file.copy.again</descript>
      <descript sctype="string">file variable: $L.file.update</descript>
      <descript sctype="string">query: "logical.name=\""+logical.name in $L.file+"\" and ucmdb.id=NULL"</descript>
      <descript sctype="string">exit if no records selected by query: init.reconcile</descript>
      <descript sctype="string">exit if one records selected by query: create.update.copy</descript>
      <descript sctype="string">exit normal: create.update.copy, error: exit.error.msg</descript>
      <descript sctype="string">panel: merge.record</descript>
      <descript sctype="string">Change statements from</descript>
      <descript sctype="string">for $L.i = 1 to lng($L.fields) do ($L.field.name=$L.i in $L.fields;$L.index=index("[", $L.field.name);if ($L.index&gt;0) then ($L.tmpindex=$L.index;while ($L.tmpindex&gt;0) do ($L.index=$L.tmpindex+1;$L.tmpindex=index("[", $L.field.name, $L.index));$L.field.name=substr($L.field.name, $L.index, lng($L.field.name) - $L.index));$L.statement=$L.field.name+" in $L.file.update="+$L.field.name+" in $L.file";$L.void=evaluate(parse($L.statement, 11)))</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">for $L.i = 1 to lng($L.fields) do ($L.field.name=$L.i in $L.fields;$L.index=index("[", $L.field.name);if ($L.index&gt;0) then ($L.field.name=substr($L.field.name, 1, $L.index - 1));$L.statement=$L.field.name+" in $L.file.update="+$L.field.name+" in $L.file";$L.void=evaluate(parse($L.statement, 11)))</descript>
      <descript sctype="string">panel: get.old.setup</descript>
      <descript sctype="string">added statements in the end:</descript>
      <descript sctype="string">$L.sql=nullsub($L.sql, false)</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel: try.reconcile</descript>
      <descript sctype="string">added new sort fields in order: sequence, fieldName</descript>
      <descript sctype="string">panel: start</descript>
      <descript sctype="string">added statements:</descript>
      <descript sctype="string">$L.valid=true</descript>
      <descript sctype="string">$L.filename=filename($L.file)</descript>
      <descript sctype="string">if ($L.filename="cirelationship") then ($L.valid=jscall("discoveryEvent.translateUcmdbRelationship", $L.file))</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel: check.parameters</descript>
      <descript sctype="string">added new exit: set.invalid.data with condition: not $L.valid</descript>
      <descript sctype="string"/>
      <descript sctype="string">new panel: set.invalid.data in process type</descript>
      <descript sctype="string">added statements:</descript>
      <descript sctype="string">$L.exit="invalid.data"</descript>
      <descript sctype="string">exit:</descript>
      <descript sctype="string">normal: exit.normal, error: exit.error.msg</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel: get.old.setup</descript>
      <descript sctype="string">removed statements:</descript>
      <descript sctype="string">$L.filename=filename($L.file)</descript>
      <descript sctype="string">if ($L.filename="cirelationship") then ($L.valid=jscall("discoveryEvent.translateUcmdbRelationship", $L.file))</descript>
      <descript sctype="string">panel: start.loop</descript>
      <descript sctype="string">Change statements from</descript>
      <descript sctype="string">for $L.i = 1 to $L.lng do ($L.field=1 in $L.i in rules in $L.rule;$L.cond=nullsub(2 in $L.i in rules in $L.rule, true);if (evaluate($L.cond) and (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0)) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=$L.field in $L.old;$L.x in $L.exception.new=$L.field in $L.orig.file))</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">if ($L.action="add") then for $L.i = 1 to lng(denull($L.fields)) do ($L.field=$L.i in $L.fields;if (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=$L.field in $L.old;$L.x in $L.exception.new=$L.field in $L.orig.file)) else for $L.i = 1 to lng(denull(rules in $L.rule)) do ($L.field=1 in $L.i in rules in $L.rule;$L.cond=nullsub(2 in $L.i in rules in $L.rule, true);if (evaluate($L.cond) and (not same($L.field in $L.orig.file, $L.field in $L.old) or index($L.field, $L.active.fields)&gt;0)) then ($L.x=lng(denull($L.exception.field))+1;$L.x in $L.exception.field=$L.field;$L.x in $L.exception.old=$L.field in $L.old;$L.x in $L.exception.new=$L.field in $L.orig.file))</descript>
      <descript sctype="string">Add parameter, label: Fields to be updated:, Input Field: names, variable: $INTO.FIELDS</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: start, add statement, $L.fields=nullsub($INTO.FIELDS, {})</descript>
      <descript sctype="string"/>
      <descript sctype="string">Panel: create.update.copy, change exits normal from duplicate.copy to decide.merge</descript>
      <descript sctype="string"/>
      <descript sctype="string">Add panel, type: decision, name: decide.merge</descript>
      <descript sctype="string">exit: merge.record, condition for exit: lng($L.fields)&gt;0</descript>
      <descript sctype="string">exits normal: duplicate.copy, error: exit.error.msg</descript>
      <descript sctype="string"/>
      <descript sctype="string">New panel, type: process, name: merge.record</descript>
      <descript sctype="string">statements:</descript>
      <descript sctype="string">for $L.i = 1 to lng($L.fields) do ($L.field.name=$L.i in $L.fields;$L.index=index("[", $L.field.name);if ($L.index&gt;0) then ($L.tmpindex=$L.index;while ($L.tmpindex&gt;0) do ($L.index=$L.tmpindex+1;$L.tmpindex=index("[", $L.field.name, $L.index));$L.field.name=substr($L.field.name, $L.index, lng($L.field.name) - $L.index));$L.statement=$L.field.name+" in $L.file.update="+$L.field.name+" in $L.file";$L.void=evaluate(parse($L.statement, 11)))</descript>
      <descript sctype="string">on panel decide call engine added another exit.normal condition</descript>
      <descript sctype="string">on panel check.post.exception</descript>
      <descript sctype="string">added a line so that when no excption found, do not create another change or incident since one already exist</descript>
      <descript sctype="string">added the following line in panel prepare.rule.lookup</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (filename($L.orig.file)="cirelationship" and $L.action="delete") then for $L.i = 1 to lng(related.cis in $L.orig.file) do ($L.i in related.cis in $L.orig.file="")</descript>
      <descript sctype="string">QC48741 - Modified the 'set.add' panel to include the following expression:</descript>
      <descript sctype="string"/>
      <descript sctype="string">if (filename($L.file)="cirelationship") then ($L.id=logical.name in $L.file)</descript>
      <descript sctype="string"/>
      <descript sctype="string">This will prevent the 'Affected CI' field for all incidents and changes created for UCMDB relationships from being set to &lt;relationship.name&gt;;&lt;logical.name&gt;.</descript>
      <descript sctype="string">on panel set.reconsile.sql, add the line at the end to make sure reconciliation rule only applies to CI from same company in multi-tenant integration.</descript>
      <descript sctype="string">Set the company field in dataModEvent when replicating CIs from ucmdb.</descript>
      <descript sctype="string"/>
      <descript sctype="string">Modified start.loop panel and added:</descript>
      <descript sctype="string">$L.company=company in $L.file</descript>
      <descript sctype="string"/>
      <descript sctype="string">Modified set.event.fields and setup the company field. added:</descript>
      <descript sctype="string">company in $L.event=$L.company</descript>
      <descript sctype="string">on panel start.loop, save ucmdb.id first and set it to $L.file at the end. On panel set.recouncile.rule.sql, add ucmdb.id=NULL at the end of the sql</descript>
      <descript sctype="string">on setup.change, add $L.file when calling script populateChange</descript>
      <descript sctype="string">Added the following line to the panel 'setup.incident' in order to set the field to true when the incident is created via ucmdb discovery:</descript>
      <descript sctype="string"/>
      <descript sctype="string">modEvent in $L.incident=true</descript>
      <descript sctype="string">on panel setup.incident, pass in $L.file when calling javascript popualteIncident</descript>
      <descript sctype="string">add if ($L.action="add") then ($L.action="ignore") to set.incident.id os that we will not attempt to add the ci when the rule says to open incident.</descript>
      <descript sctype="string">convert company from id to company code which will be used as part of unique key for query replciated ci.</descript>
    </descript>
    <release type="string">7.11.000</release>
    <sysmodcount type="decimal">19</sysmodcount>
    <sysmoduser type="string">qiqingsong</sysmoduser>
    <sysmodtime type="dateTime">12/29/15 20:27:59</sysmodtime>
  </record>
</recordset>
