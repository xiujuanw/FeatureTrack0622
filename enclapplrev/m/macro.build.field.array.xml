<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="enclapplrev">
  <record id="application.name=&quot;macro.build.field.array&quot;" recordid="macro.build.field.array">
    <application.name type="string">macro.build.field.array</application.name>
    <rev.array sctype="array">
      <rev.array sctype="structure">
        <rev.name type="string">yuli</rev.name>
        <rev.date type="dateTime">08/15/11 14:39:23</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Dbdict fields are not occurring in Data Policy</rev.desc>
          <rev.desc sctype="string">Panel 'run'</rev.desc>
          <rev.desc sctype="string">solve new field couldn't be added into structure of structure</rev.desc>
          <rev.desc sctype="string">change from</rev.desc>
          <rev.desc sctype="string">if ($L.arraystructlvl=0 and $L.fldtyp=$L.type and 4 in $L.prev in $L.data~=8 and 4 in $L.next in $L.data~=9) then ($L.add=true)</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">if ($L.arraystructlvl=0 and $L.fldtyp=$L.type and 4 in $L.prev in $L.data~=8) then ($L.add=true)</rev.desc>
        </rev.desc>
        <change.no type="decimal">66089</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">06/18/07 23:50:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">on the 'run' panel I checked for whether or not '4 in $L.next in $L.data' was NULL.  Without this check the last field in a dbdict was not being added to the data policy record</rev.desc>
        </rev.desc>
        <change.no type="decimal">1168</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">06/14/07 21:45:32</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">updated the 'run' panel so that arrays of structures are no longer included in the data policy record.</rev.desc>
        </rev.desc>
        <change.no type="decimal">1026</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cblanck</rev.name>
        <rev.date type="dateTime">06/14/07 19:28:18</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">made these changes for acorvino.  Re-removes dummy rinit panel. We're now selecting the dbdict records directly and not doing the 1 in descriptor($L.dummy) calls any more. 1 in $L.dummy works in those cases. (ST1226)</rev.desc>
        </rev.desc>
        <change.no type="decimal">1226</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">acorvino</rev.name>
        <rev.date type="dateTime">06/13/07 09:53:33</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Re-removes dummy rinit panel. We're now selecting the dbdict records directly and not doing the 1 in descriptor($L.dummy) calls any more. 1 in $L.dummy works in those cases. (ST1226)</rev.desc>
        </rev.desc>
        <change.no type="decimal">1226</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">06/05/07 05:30:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Backed out last change.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">acorvino</rev.name>
        <rev.date type="dateTime">05/20/07 17:15:45</rev.date>
        <rev.desc sctype="array"/>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">acorvino</rev.name>
        <rev.date type="dateTime">05/20/07 16:09:12</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Removes dummy rinit panel to get dbdict records</rev.desc>
        </rev.desc>
        <change.no type="decimal">766</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">esoriano</rev.name>
        <rev.date type="dateTime">03/15/03 03:29:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Another modification for CenterPoint Change 24524.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">In the run.dbdictcompare panel, return types of 81, 82, 83 and 84 for Array of Number, Array of Character, Array of Data/Time, and Array of Logical, respectively. Prior to this, it was just returning a value of 8 (array), so you couldn't really tell what type of array it was.</rev.desc>
        </rev.desc>
        <change.no type="decimal">24524</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">esoriano</rev.name>
        <rev.date type="dateTime">02/17/03 04:44:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modification for CenterPoint Change 24524.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Added processing for a new build type called "dbdictcompare". See the MSWord document named CtrPntChg24524 attached to that change for details of what was done.</rev.desc>
        </rev.desc>
        <change.no type="decimal">24524</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">joeh</rev.name>
        <rev.date type="dateTime">10/08/02 18:11:36</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added new panel run.evmap that returns a modified  "type" back that is a composit of the array and type.</rev.desc>
          <rev.desc sctype="string">81=array of number</rev.desc>
          <rev.desc sctype="string">82=array of char</rev.desc>
          <rev.desc sctype="string">83=array of date/time</rev.desc>
          <rev.desc sctype="string">84=array of logical</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">esoriano</rev.name>
        <rev.date type="dateTime">09/14/02 11:57:08</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Change for CenterPoint Task 19808 for Request 18458.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Change made so that if this application fails, it issues the message "Unrecoverable error in application macro.build.field.array on panel xxx"  (where xxx is the panel name that it blew up on), and then it returns to the caller.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Previously, what was happening was that if this application blew up, it immediately returned to the caller, and the caller would issue the message "Unrecoverable error in application aaa on panel xxx"  (where aaa is the caller, and xxx is the panel within macro.build.field.array). This was misleading because the panel it abended on is really in macro.build.field.array, not in the application that called macro.build.field.array.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">For details of the changes, see the attached MS Word document named CtrPntTsk19808Rqs18458Log.doc</rev.desc>
        </rev.desc>
        <change.no type="decimal">19808</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">esoriano</rev.name>
        <rev.date type="dateTime">09/08/02 09:45:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Change for CenterPoint Task 19778 for Request 4433</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Made a new panel called run.formsdesign. This panel will return all the field in a dbdict, including all fields that are contained/nested in standalone structures. However, it will NOT return fields that are contained/nested within arrays of structures.</rev.desc>
        </rev.desc>
        <change.no type="decimal">19778</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">09/03/02 15:17:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Updated to process all types using what was the run.datadict panel.  For types "datadict" and "any", all scalar and array fields are added to the list.  They are only excluded if they are part of an array.</rev.desc>
        </rev.desc>
        <change.no type="decimal">22667</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">08/11/02 14:35:34</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Filled in all missing error exits with $error.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">esoriano</rev.name>
        <rev.date type="dateTime">01/16/02 07:25:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">This application was not properly building what was needed for the datadict. Specifically, it was getting lost if the dbdict that it was building the datadict for had multiple levels. See the document named ST22575Log.doc attached to Starteam Ticket ST22575 for details of what was done.</rev.desc>
        </rev.desc>
        <change.no type="decimal">22575</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">esoriano</rev.name>
        <rev.date type="dateTime">12/31/01 05:45:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Application modified so that on arrays are not duplicated. See document ST21776Log.doc attached to Starteam Ticket ST21776 for details of what was done.</rev.desc>
        </rev.desc>
        <change.no type="decimal">21776</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">07/28/01 11:11:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added "qbe" as a type for modify columns call.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">mprice</rev.name>
        <rev.date type="dateTime">02/20/99 03:31:46</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">put in decision to sort or not based on parameter passed into the application.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pcasey</rev.name>
        <rev.date type="dateTime">01/13/99 08:12:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">can now return data types as well as field names</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">01/12/99 03:04:16</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">scmsg</rev.desc>
        </rev.desc>
        <change.no type="decimal">856</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pcasey</rev.name>
        <rev.date type="dateTime">12/09/98 08:04:02</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">now can accept "scalar" as a type</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">09/29/98 17:27:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Don't display arrays as "name,name" - display as "name".</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pcasey</rev.name>
        <rev.date type="dateTime">02/01/98 12:23:53</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Now calls the us.sort.array instead of apm.sort.array</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
    </rev.array>
    <descript sctype="array">
      <descript sctype="string">Dbdict fields are not occurring in Data Policy</descript>
      <descript sctype="string">Panel 'run'</descript>
      <descript sctype="string">solve new field couldn't be added into structure of structure</descript>
      <descript sctype="string">change from</descript>
      <descript sctype="string">if ($L.arraystructlvl=0 and $L.fldtyp=$L.type and 4 in $L.prev in $L.data~=8 and 4 in $L.next in $L.data~=9) then ($L.add=true)</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">if ($L.arraystructlvl=0 and $L.fldtyp=$L.type and 4 in $L.prev in $L.data~=8) then ($L.add=true)</descript>
      <descript sctype="string">on the 'run' panel I checked for whether or not '4 in $L.next in $L.data' was NULL.  Without this check the last field in a dbdict was not being added to the data policy record</descript>
      <descript sctype="string">updated the 'run' panel so that arrays of structures are no longer included in the data policy record.</descript>
      <descript sctype="string">made these changes for acorvino.  Re-removes dummy rinit panel. We're now selecting the dbdict records directly and not doing the 1 in descriptor($L.dummy) calls any more. 1 in $L.dummy works in those cases. (ST1226)</descript>
      <descript sctype="string">Re-removes dummy rinit panel. We're now selecting the dbdict records directly and not doing the 1 in descriptor($L.dummy) calls any more. 1 in $L.dummy works in those cases. (ST1226)</descript>
      <descript sctype="string">Backed out last change.</descript>
      <descript sctype="string">Another modification for CenterPoint Change 24524.</descript>
      <descript sctype="string"/>
      <descript sctype="string">In the run.dbdictcompare panel, return types of 81, 82, 83 and 84 for Array of Number, Array of Character, Array of Data/Time, and Array of Logical, respectively. Prior to this, it was just returning a value of 8 (array), so you couldn't really tell what type of array it was.</descript>
      <descript sctype="string">Modification for CenterPoint Change 24524.</descript>
      <descript sctype="string"/>
      <descript sctype="string">Added processing for a new build type called "dbdictcompare". See the MSWord document named CtrPntChg24524 attached to that change for details of what was done.</descript>
      <descript sctype="string">Added new panel run.evmap that returns a modified  "type" back that is a composit of the array and type.</descript>
      <descript sctype="string">81=array of number</descript>
      <descript sctype="string">82=array of char</descript>
      <descript sctype="string">83=array of date/time</descript>
      <descript sctype="string">84=array of logical</descript>
      <descript sctype="string">Change for CenterPoint Task 19808 for Request 18458.</descript>
      <descript sctype="string"/>
      <descript sctype="string">Change made so that if this application fails, it issues the message "Unrecoverable error in application macro.build.field.array on panel xxx"  (where xxx is the panel name that it blew up on), and then it returns to the caller.</descript>
      <descript sctype="string"/>
      <descript sctype="string">Previously, what was happening was that if this application blew up, it immediately returned to the caller, and the caller would issue the message "Unrecoverable error in application aaa on panel xxx"  (where aaa is the caller, and xxx is the panel within macro.build.field.array). This was misleading because the panel it abended on is really in macro.build.field.array, not in the application that called macro.build.field.array.</descript>
      <descript sctype="string"/>
      <descript sctype="string">For details of the changes, see the attached MS Word document named CtrPntTsk19808Rqs18458Log.doc</descript>
      <descript sctype="string">Change for CenterPoint Task 19778 for Request 4433</descript>
      <descript sctype="string"/>
      <descript sctype="string">Made a new panel called run.formsdesign. This panel will return all the field in a dbdict, including all fields that are contained/nested in standalone structures. However, it will NOT return fields that are contained/nested within arrays of structures.</descript>
      <descript sctype="string">Updated to process all types using what was the run.datadict panel.  For types "datadict" and "any", all scalar and array fields are added to the list.  They are only excluded if they are part of an array.</descript>
      <descript sctype="string">Filled in all missing error exits with $error.</descript>
      <descript sctype="string">This application was not properly building what was needed for the datadict. Specifically, it was getting lost if the dbdict that it was building the datadict for had multiple levels. See the document named ST22575Log.doc attached to Starteam Ticket ST22575 for details of what was done.</descript>
      <descript sctype="string">Application modified so that on arrays are not duplicated. See document ST21776Log.doc attached to Starteam Ticket ST21776 for details of what was done.</descript>
      <descript sctype="string">Added "qbe" as a type for modify columns call.</descript>
      <descript sctype="string">put in decision to sort or not based on parameter passed into the application.</descript>
      <descript sctype="string">can now return data types as well as field names</descript>
      <descript sctype="string">scmsg</descript>
      <descript sctype="string">not can accept "scalar" as a type</descript>
      <descript sctype="string">Don't display arrays as "name,name" - display as "name".</descript>
      <descript sctype="string">Now calls the us.sort.array instead of apm.sort.array</descript>
    </descript>
    <release type="string">A9701 SP1</release>
    <sysmodcount type="decimal">20</sysmodcount>
    <sysmoduser type="string">yuli</sysmoduser>
    <sysmodtime type="dateTime">08/15/11 14:39:54</sysmodtime>
  </record>
</recordset>
