<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="enclapplrev">
  <record id="application.name=&quot;approval.generate&quot;" recordid="approval.generate">
    <application.name type="string">approval.generate</application.name>
    <rev.array sctype="array">
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">12/03/19 17:19:04</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">update panel empty.current.pending.groups, set approved.by to "System" if action is "Approved By System"</rev.desc>
        </rev.desc>
        <change.no type="decimal">156068</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">09/15/19 15:00:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">update panel decide.final.status, consider action "Denied By System"</rev.desc>
        </rev.desc>
        <change.no type="decimal">156068</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">01/19/17 05:37:40</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">update panel start, get.object, get.unique, add</rev.desc>
          <rev.desc sctype="string">$L.file.name=jscall("Workflow.getWorkflowTableName", filename($L.file))</rev.desc>
        </rev.desc>
        <change.no type="decimal">26543</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">06/06/16 03:32:40</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">update panel get.unique, add</rev.desc>
          <rev.desc sctype="string">$L.file.name=jscall("Workflow.getWorkflowTableName", filename($L.file))</rev.desc>
        </rev.desc>
        <change.no type="decimal">133373</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">miquan</rev.name>
        <rev.date type="dateTime">03/25/15 19:22:15</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">pane:</rev.desc>
          <rev.desc sctype="string">combine.approvals4</rev.desc>
          <rev.desc sctype="string">remove line: approval.status in $L.approval="pending"</rev.desc>
        </rev.desc>
        <change.no type="decimal">121458</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">miquan</rev.name>
        <rev.date type="dateTime">03/25/15 19:19:48</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: combine.approvals</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">changed from :</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(approved.seq in $L.i in $L.total.approvals)) do (approved.seq in $L.approvals=insert(approved.action in $L.approval, 1, 1, $L.j in approved.seq in $L.i in $L.total.approvals))</rev.desc>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(approved.seq in $L.i in $L.total.approvals)) do (approved.seq in $L.approval=insert(approved.seq in $L.approval, 1, 1, $L.j in approved.seq in $L.i in $L.total.approvals))</rev.desc>
        </rev.desc>
        <change.no type="decimal">121292</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">miquan</rev.name>
        <rev.date type="dateTime">04/23/14 18:53:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add controle for this: not  (null($lo.operator)</rev.desc>
          <rev.desc sctype="string">since when linker start, the link corresponded operator is still null.</rev.desc>
        </rev.desc>
        <change.no type="decimal">108253</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">miquan</rev.name>
        <rev.date type="dateTime">04/20/14 10:33:26</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">ManagerGroup Approval Supporting</rev.desc>
        </rev.desc>
        <change.no type="decimal">96986</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">dengxin</rev.name>
        <rev.date type="dateTime">08/17/13 21:08:27</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Approval notification is not generated if "Aggregate approval" is checked</rev.desc>
          <rev.desc sctype="string">CR 66544. it will put the panel=do.notify into the loop so that notification will be sent correctly for each approval. But  missed code for the Aggregate approval.</rev.desc>
          <rev.desc sctype="string">After panael build.all.status2, and check.notification2 and do.notify2 panel.</rev.desc>
        </rev.desc>
        <change.no type="decimal">91260</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lmingyan</rev.name>
        <rev.date type="dateTime">04/15/13 03:12:49</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">When ordering two items from SRC, both are approved when the first one is approved</rev.desc>
        </rev.desc>
        <change.no type="decimal">84320</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pengfei</rev.name>
        <rev.date type="dateTime">07/08/12 14:59:01</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Sort the future.seq and future.approvals in combine.approval2 panel</rev.desc>
        </rev.desc>
        <change.no type="decimal">77492</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">yiwen</rev.name>
        <rev.date type="dateTime">05/22/12 12:00:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add unmerge function</rev.desc>
        </rev.desc>
        <change.no type="decimal">75490</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">qiqingsong</rev.name>
        <rev.date type="dateTime">11/22/11 02:32:35</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">In panel: decide.final.status</rev.desc>
          <rev.desc sctype="string">From</rev.desc>
          <rev.desc sctype="string">$L.total.count=lng(denull(all.status in $L.approval))</rev.desc>
          <rev.desc sctype="string">To</rev.desc>
          <rev.desc sctype="string">$L.group1=denull(nullsub(current.pending.groups in $L.approval, {}))</rev.desc>
          <rev.desc sctype="string">$L.group2=denull(nullsub(future.groups in $L.approval, {}))</rev.desc>
          <rev.desc sctype="string">$L.group3=denull(nullsub(approved.groups in $L.approval, {}))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">$L.total.count=lng($L.group1)+lng($L.group2)+lng($L.group3)</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Change line</rev.desc>
          <rev.desc sctype="string">if ($L.appr.type="quorum" and $L.approved.count&gt;$L.total.count/2) then ($L.final.status="approved")</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">Add line:</rev.desc>
          <rev.desc sctype="string">if ($L.denied.count&gt;0 and $L.appr.type="quorum" and $L.denied.count&gt;=$L.total.count/2) then ($L.final.status="denied")</rev.desc>
        </rev.desc>
        <change.no type="decimal">70491</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">Weihua</rev.name>
        <rev.date type="dateTime">11/05/11 00:56:50</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Put the panel=do.notify into the loop so that notification will be sent correctly for each approval.</rev.desc>
        </rev.desc>
        <change.no type="decimal">66544</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">wantianl</rev.name>
        <rev.date type="dateTime">05/15/11 20:24:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">there is a field name mispelled in combine.approval4 panel,</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">correct it form deny.count into denied.count(Approval Table)</rev.desc>
        </rev.desc>
        <change.no type="decimal">64543</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">xxia</rev.name>
        <rev.date type="dateTime">01/15/11 04:58:24</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">panel: start.loop</rev.desc>
          <rev.desc sctype="string">added: $L.is.replace.groups=false</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel: replace.group</rev.desc>
          <rev.desc sctype="string">added: $L.is.replace.groups=true</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel: process.description</rev.desc>
          <rev.desc sctype="string">changed from</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.temp.current.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.current.groups=$L.j in $L.keep.role.new) then ($L.i in current.pending.groups in $L.approval.save.1=$L.j in $L.keep.role.old))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.temp.future.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.future.groups=$L.j in $L.keep.role.new) then ($L.i in future.groups in $L.approval.save.1=$L.j in $L.keep.role.old))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.temp.approved.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.approved.groups=$L.j in $L.keep.role.new) then ($L.i in approved.groups in $L.approval.save.1=$L.j in $L.keep.role.old))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">if $L.is.replace.groups then (for $L.i = 1 to lng(denull($L.temp.current.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.current.groups=$L.j in $L.keep.role.new) then ($L.i in current.pending.groups in $L.approval.save.1=$L.j in $L.keep.role.old));for $L.i = 1 to lng(denull($L.temp.future.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.future.groups=$L.j in $L.keep.role.new) then ($L.i in future.groups in $L.approval.save.1=$L.j in $L.keep.role.old));for $L.i = 1 to lng(denull($L.temp.approved.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.approved.groups=$L.j in $L.keep.role.new) then ($L.i in approved.groups in $L.approval.save.1=$L.j in $L.keep.role.old)))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">panel: check.add.update</rev.desc>
          <rev.desc sctype="string">changed from</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull(current.pending.groups in $L.approval)) do (if (index($L.i in current.pending.groups in $L.approval, $L.current.pending.groups)=0) then ($L.current.pending.groups=insert($L.current.pending.groups, 1, 1, $L.i in current.pending.groups in $L.approval)))</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull(future.groups in $L.approval)) do (if (index($L.i in future.groups in $L.approval, $L.future.groups)=0) then ($L.future.groups=insert($L.future.groups, 1, 1, $L.i in future.groups in $L.approval)))</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull(approved.groups in $L.approval)) do (if (index($L.i in approved.groups in $L.approval, $L.approved.groups)=0) then ($L.approved.groups=insert($L.approved.groups, 1, 1, $L.i in approved.groups in $L.approval)))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull(current.pending.groups in $L.approval)) do (if (index($L.i in current.pending.groups in $L.approval+":"+current.pending.seq in $L.approval, $L.tokens)=0) then ($L.current.pending.groups=insert($L.current.pending.groups, 1, 1, $L.i in current.pending.groups in $L.approval)))</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull(future.groups in $L.approval)) do (if (index($L.i in future.groups in $L.approval+":"+$L.i in future.seq in $L.approval, $L.tokens)=0) then ($L.future.groups=insert($L.future.groups, 1, 1, $L.i in future.groups in $L.approval)))</rev.desc>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull(approved.groups in $L.approval)) do (if (index($L.i in approved.groups in $L.approval+":"+$L.i in approved.seq in $L.approval, $L.tokens)=0) then ($L.approved.groups=insert($L.approved.groups, 1, 1, $L.i in approved.groups in $L.approval)))</rev.desc>
        </rev.desc>
        <change.no type="decimal">59426</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zouguo</rev.name>
        <rev.date type="dateTime">10/29/10 04:54:38</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Update panel: combine.approvals2 to slove issue "Approval Sequencing is not properly maintained".</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zouguo</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Update this application to support Line Item Approval.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">zhangqi</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">add panel resolve.role.identity.pre, pass new parameter $L.call in panel check.use.role</rev.desc>
        </rev.desc>
        <change.no type="decimal">49813</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified the following expressions on 'combine.approvals2' from:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(current.pending.groups in $L.i in $L.total.approvals)) do (if (index($L.j in current.pending.groups in $L.i in $L.total.approvals, current.pending.groups in $L.approval)&lt;1 and lng($L.j in current.pending.groups in $L.i in $L.total.approvals)&gt;1) then (current.pending.groups in $L.approval=insert(current.pending.groups in $L.approval, 1, 1, $L.j in current.pending.groups in $L.i in $L.total.approvals)))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(current.pending.groups in $L.i in $L.total.approvals)) do (if (index($L.j in current.pending.groups in $L.i in $L.total.approvals, current.pending.groups in $L.approval)&lt;1 and lng($L.j in current.pending.groups in $L.i in $L.total.approvals)&gt;0) then (current.pending.groups in $L.approval=insert(current.pending.groups in $L.approval, 0, 1, $L.j in current.pending.groups in $L.i in $L.total.approvals)))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">from:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(future.groups in $L.i in $L.total.approvals and lng($L.j in future.groups in $L.i in $L.total.approvals))) do (if (index($L.j in future.groups in $L.i in $L.total.approvals, future.groups in $L.approval)&lt;1 and lng($L.j in future.groups in $L.i in $L.total.approvals)&gt;0) then (future.groups in $L.approval=insert(future.groups in $L.approval, 1, 1, $L.j in future.groups in $L.i in $L.total.approvals)))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(future.groups in $L.i in $L.total.approvals)) do (if (index($L.j in future.groups in $L.i in $L.total.approvals, future.groups in $L.approval)&lt;1 and lng($L.j in future.groups in $L.i in $L.total.approvals)&gt;0) then (future.groups in $L.approval=insert(future.groups in $L.approval, 0, 1, $L.j in future.groups in $L.i in $L.total.approvals)))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">from:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(future.seq in $L.i in $L.total.approvals)) do (future.seq in $L.approval=insert(future.seq in $L.approval, 1, 1, $L.j in future.seq in $L.i in $L.total.approvals))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">to:</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(future.seq in $L.i in $L.total.approvals)) do (future.seq in $L.approval=insert(future.seq in $L.approval, 0, 1, $L.j in future.seq in $L.i in $L.total.approvals))</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">The second parameter for each 'insert' call was changed from '1' to '0' to ensure that elements are added to the end rather than the beginning of each array.  The 'for' statement in the second expression contained an invalid expression that was removed as well.</rev.desc>
        </rev.desc>
        <change.no type="decimal">43557</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hzhang</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array"/>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hzhang</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">modified panel combine.approvals2 and added if condition to first 2 for loop</rev.desc>
          <rev.desc sctype="string">if (index($L.j in current.pending.groups in $L.i in $L.total.approvals, current.pending.groups in $L.approval)&lt;1 and lng($L.j in current.pending.groups in $L.i in $L.total.approvals)&gt;1</rev.desc>
          <rev.desc sctype="string">and</rev.desc>
          <rev.desc sctype="string">if (index($L.j in future.groups in $L.i in $L.total.approvals, future.groups in $L.approval)&lt;1 and lng($L.j in future.groups in $L.i in $L.total.approvals)&gt;1</rev.desc>
        </rev.desc>
        <change.no type="decimal">41753</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hzhang</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">modified app approval.generate on panel process.description and check.use.role, and ScriptLibrary file Approval function processDescription to handle cases where multiple approval entries with same approver and  sequence when evaluate to true. If that happens, we will generate approval based on first match.</rev.desc>
        </rev.desc>
        <change.no type="decimal">4137</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">rolfel</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">DE3137 - Changed the variables $L.i and $L.j on the panel 'process.description' to start in 1 instead of 0 since in some expressions we used that value as index. i.e. $L.i in...</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">06/04/12 04:03:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Hua: fix issue with when combine approvals, multiple pending groups in 1 approval seq and multiple pending groups in another approval seq. Changed panel combine.approvals1</rev.desc>
        </rev.desc>
        <change.no type="decimal">40792</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">04/04/12 07:31:13</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">hua:40284 fix $L.current.pending.seq in combine.approvals1 and combine.approvals2</rev.desc>
        </rev.desc>
        <change.no type="decimal">40284</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">08/04/07 03:36:36</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Hua: added another panel combine.approvals1 to deal with different seq from different individual approvals when combine them.</rev.desc>
        </rev.desc>
        <change.no type="decimal">40284</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hzhang</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">fixed issue with role returns null or empty</rev.desc>
        </rev.desc>
        <change.no type="decimal">39972</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hzhang</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">more code for aggregate approvals</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hzhang</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">added code to aggregate multiple approval defs into 1 approvals, based on object defination</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">hzhang</rev.name>
        <rev.date type="dateTime">07/02/04 15:35:08</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added code to handle role management</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">ausman</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added code for build all.status in Approvals to display on Interactions this was formerly a trigger</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">sanderson</rev.name>
        <rev.date type="dateTime">10/31/08 16:21:47</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">	Panel approve.loop
		added $L.x in approved.by.fullname in $L.approval=nullsub($lo.ufname, operator())
		added $L.x in approved.by.fullname in $L.approval to the end of $L.info</rev.desc>
        </rev.desc>
        <change.no type="decimal">24582</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">esoriano</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modification made so that this application now takes into account the condition where an approval 1) has an approval type of something other than "All must approve" and 2) none of the group/operator conditions evaluate to true.</rev.desc>
          <rev.desc sctype="string"/>
          <rev.desc sctype="string">For details of what was done, see the MSWord document named SCR26316ResolutionLog.doc attached to CenterPoint SCR26316.</rev.desc>
        </rev.desc>
        <change.no type="decimal">26316</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">cfullert</rev.name>
        <rev.date type="dateTime">05/30/13 12:39:59</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">BUG11743:</rev.desc>
          <rev.desc sctype="string">on the log panel I changed the following line frome:</rev.desc>
          <rev.desc sctype="string">$L.info={$L.x in approved.date in $L.approval, $L.x in approved.by in $L.approval, $L.x in approved.for in $L.approval, $L.x in approved.groups in $L.approval,  name in $L.approval}</rev.desc>
          <rev.desc sctype="string">to</rev.desc>
          <rev.desc sctype="string">$L.info={$L.x in approved.date in $L.approval, $L.x in approved.by in $L.approval, $L.x in approved.for in $L.approval, $L.x in approved.groups in $L.approval, , name in $L.approval}</rev.desc>
        </rev.desc>
        <change.no type="decimal">11743</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">02/27/10 05:04:39</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">When a record is preapproved on open and approval comments are required, preset comments to "Preapproved on open".</rev.desc>
        </rev.desc>
        <change.no type="decimal">23545</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Now invokes format control (stored on the Object record) on preapprove approvals.</rev.desc>
        </rev.desc>
        <change.no type="decimal">24562</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified set.fields to set approvals.required to $L.future.groups if the field exists in the file.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">falcon</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Added the "All must approve - first denial" approval option.  Using this option all approvers must approve the record for it to be completely approved.  However, as soon as the first person denies it, the status is set immediately to "denied" instead of waiting for all approvers to register their approval action.</rev.desc>
        </rev.desc>
        <change.no type="decimal">22965</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">03/29/03 21:24:37</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Modified panel set.future to process the preapprove.cond field in the Object record.  True by default, the field determines if the record should be automatically approved if the person who opened it belongs to one of the pending approval groups.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">On decide.final.status panel, set $L.appr.type to the value in the approval definition, nullsubed to the object record value.</rev.desc>
        </rev.desc>
        <change.no type="decimal">16106</change.no>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">08/28/08 23:08:09</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Changed create.groups to parse out an array of groups.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">06/27/09 18:21:49</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">On create.groups, if ($L.i in 1 in $L.groups) contains a "$", call evaluate and parse on the string.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">lisa</rev.name>
        <rev.date type="dateTime">00:00:00</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">On start panel, nullsubed $L.def.query to false.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
      <rev.array sctype="structure">
        <rev.name type="string">pbudic</rev.name>
        <rev.date type="dateTime">03/28/02 08:02:33</rev.date>
        <rev.desc sctype="array">
          <rev.desc sctype="string">Will no longer generate approval records if no groups meet the approval conditions.</rev.desc>
        </rev.desc>
        <change.no NullValue="1" type="decimal"/>
      </rev.array>
    </rev.array>
    <descript sctype="array">
      <descript sctype="string">update panel empty.current.pending.groups, set approved.by to "System" if action is "Approved By System"</descript>
      <descript sctype="string">update panel decide.final.status, consider action "Denied By System"</descript>
      <descript sctype="string">update panel start, get.object, get.unique, add</descript>
      <descript sctype="string">$L.file.name=jscall("Workflow.getWorkflowTableName", filename($L.file))</descript>
      <descript sctype="string">update panel get.unique, add</descript>
      <descript sctype="string">$L.file.name=jscall("Workflow.getWorkflowTableName", filename($L.file))</descript>
      <descript sctype="string">pane:</descript>
      <descript sctype="string">combine.approvals4</descript>
      <descript sctype="string">remove line: approval.status in $L.approval="pending"</descript>
      <descript sctype="string">panel: combine.approvals</descript>
      <descript sctype="string"/>
      <descript sctype="string">changed from :</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(approved.seq in $L.i in $L.total.approvals)) do (approved.seq in $L.approvals=insert(approved.action in $L.approval, 1, 1, $L.j in approved.seq in $L.i in $L.total.approvals))</descript>
      <descript sctype="string">to:</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(approved.seq in $L.i in $L.total.approvals)) do (approved.seq in $L.approval=insert(approved.seq in $L.approval, 1, 1, $L.j in approved.seq in $L.i in $L.total.approvals))</descript>
      <descript sctype="string">add controle for this: not  (null($lo.operator)</descript>
      <descript sctype="string">since when linker start, the link corresponded operator is still null.</descript>
      <descript sctype="string">ManagerGroup Approval Supporting</descript>
      <descript sctype="string">Approval notification is not generated if "Aggregate approval" is checked</descript>
      <descript sctype="string">CR 66544. it will put the panel=do.notify into the loop so that notification will be sent correctly for each approval. But  missed code for the Aggregate approval.</descript>
      <descript sctype="string">After panael build.all.status, and check.notification2 and do.notify2 panel.</descript>
      <descript sctype="string">When ordering two items from SRC, both are approved when the first one is approved</descript>
      <descript sctype="string">Sort the future.seq and future.approvals in combine.approval2 panel</descript>
      <descript sctype="string">add unmerge function</descript>
      <descript sctype="string">In panel: decide.final.status</descript>
      <descript sctype="string">From</descript>
      <descript sctype="string">$L.total.count=lng(denull(all.status in $L.approval))</descript>
      <descript sctype="string">To</descript>
      <descript sctype="string">$L.group1=denull(nullsub(current.pending.groups in $L.approval, {}))</descript>
      <descript sctype="string">$L.group2=denull(nullsub(future.groups in $L.approval, {}))</descript>
      <descript sctype="string">$L.group3=denull(nullsub(approved.groups in $L.approval, {}))</descript>
      <descript sctype="string"/>
      <descript sctype="string">$L.total.count=lng($L.group1)+lng($L.group2)+lng($L.group3)</descript>
      <descript sctype="string"/>
      <descript sctype="string">Change line</descript>
      <descript sctype="string">if ($L.appr.type="quorum" and $L.approved.count&gt;$L.total.count/2) then ($L.final.status="approved")</descript>
      <descript sctype="string"/>
      <descript sctype="string">Add line:</descript>
      <descript sctype="string">if ($L.denied.count&gt;0 and $L.appr.type="quorum" and $L.denied.count&gt;=$L.total.count/2) then ($L.final.status="denied")</descript>
      <descript sctype="string">Put the panel=do.notify into the loop so that notification will be sent correctly for each approval.</descript>
      <descript sctype="string">there is a field name mispelled in combine.approval4 panel,</descript>
      <descript sctype="string"/>
      <descript sctype="string">correct it form deny.count into denied.count(Approval Table)</descript>
      <descript sctype="string">panel: start.loop</descript>
      <descript sctype="string">added: $L.is.replace.groups=false</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel: replace.group</descript>
      <descript sctype="string">added: $L.is.replace.groups=true</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel: process.description</descript>
      <descript sctype="string">changed from</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.temp.current.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.current.groups=$L.j in $L.keep.role.new) then ($L.i in current.pending.groups in $L.approval.save.1=$L.j in $L.keep.role.old))</descript>
      <descript sctype="string"/>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.temp.future.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.future.groups=$L.j in $L.keep.role.new) then ($L.i in future.groups in $L.approval.save.1=$L.j in $L.keep.role.old))</descript>
      <descript sctype="string"/>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.temp.approved.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.approved.groups=$L.j in $L.keep.role.new) then ($L.i in approved.groups in $L.approval.save.1=$L.j in $L.keep.role.old))</descript>
      <descript sctype="string"/>
      <descript sctype="string">to</descript>
      <descript sctype="string">if $L.is.replace.groups then (for $L.i = 1 to lng(denull($L.temp.current.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.current.groups=$L.j in $L.keep.role.new) then ($L.i in current.pending.groups in $L.approval.save.1=$L.j in $L.keep.role.old));for $L.i = 1 to lng(denull($L.temp.future.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.future.groups=$L.j in $L.keep.role.new) then ($L.i in future.groups in $L.approval.save.1=$L.j in $L.keep.role.old));for $L.i = 1 to lng(denull($L.temp.approved.groups)) do for $L.j = 1 to lng(denull($L.keep.role.new)) do (if ($L.i in $L.temp.approved.groups=$L.j in $L.keep.role.new) then ($L.i in approved.groups in $L.approval.save.1=$L.j in $L.keep.role.old)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">panel: check.add.update</descript>
      <descript sctype="string">changed from</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull(current.pending.groups in $L.approval)) do (if (index($L.i in current.pending.groups in $L.approval, $L.current.pending.groups)=0) then ($L.current.pending.groups=insert($L.current.pending.groups, 1, 1, $L.i in current.pending.groups in $L.approval)))</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull(future.groups in $L.approval)) do (if (index($L.i in future.groups in $L.approval, $L.future.groups)=0) then ($L.future.groups=insert($L.future.groups, 1, 1, $L.i in future.groups in $L.approval)))</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull(approved.groups in $L.approval)) do (if (index($L.i in approved.groups in $L.approval, $L.approved.groups)=0) then ($L.approved.groups=insert($L.approved.groups, 1, 1, $L.i in approved.groups in $L.approval)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">to</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull(current.pending.groups in $L.approval)) do (if (index($L.i in current.pending.groups in $L.approval+":"+current.pending.seq in $L.approval, $L.tokens)=0) then ($L.current.pending.groups=insert($L.current.pending.groups, 1, 1, $L.i in current.pending.groups in $L.approval)))</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull(future.groups in $L.approval)) do (if (index($L.i in future.groups in $L.approval+":"+$L.i in future.seq in $L.approval, $L.tokens)=0) then ($L.future.groups=insert($L.future.groups, 1, 1, $L.i in future.groups in $L.approval)))</descript>
      <descript sctype="string">for $L.i = 1 to lng(denull(approved.groups in $L.approval)) do (if (index($L.i in approved.groups in $L.approval+":"+$L.i in approved.seq in $L.approval, $L.tokens)=0) then ($L.approved.groups=insert($L.approved.groups, 1, 1, $L.i in approved.groups in $L.approval)))</descript>
      <descript sctype="string">Update panel: combine.approvals2 to slove issue "Approval Sequencing is not properly maintained".</descript>
      <descript sctype="string">add panel resolve.role.identity.pre, pass new parameter $L.call in panel check.use.role</descript>
      <descript sctype="string">Modified the following expressions on 'combine.approvals2' from:</descript>
      <descript sctype="string"/>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(current.pending.groups in $L.i in $L.total.approvals)) do (if (index($L.j in current.pending.groups in $L.i in $L.total.approvals, current.pending.groups in $L.approval)&lt;1 and lng($L.j in current.pending.groups in $L.i in $L.total.approvals)&gt;1) then (current.pending.groups in $L.approval=insert(current.pending.groups in $L.approval, 1, 1, $L.j in current.pending.groups in $L.i in $L.total.approvals)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">to:</descript>
      <descript sctype="string"/>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(current.pending.groups in $L.i in $L.total.approvals)) do (if (index($L.j in current.pending.groups in $L.i in $L.total.approvals, current.pending.groups in $L.approval)&lt;1 and lng($L.j in current.pending.groups in $L.i in $L.total.approvals)&gt;0) then (current.pending.groups in $L.approval=insert(current.pending.groups in $L.approval, 0, 1, $L.j in current.pending.groups in $L.i in $L.total.approvals)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">from:</descript>
      <descript sctype="string"/>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(future.groups in $L.i in $L.total.approvals and lng($L.j in future.groups in $L.i in $L.total.approvals))) do (if (index($L.j in future.groups in $L.i in $L.total.approvals, future.groups in $L.approval)&lt;1 and lng($L.j in future.groups in $L.i in $L.total.approvals)&gt;0) then (future.groups in $L.approval=insert(future.groups in $L.approval, 1, 1, $L.j in future.groups in $L.i in $L.total.approvals)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">to:</descript>
      <descript sctype="string"/>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(future.groups in $L.i in $L.total.approvals)) do (if (index($L.j in future.groups in $L.i in $L.total.approvals, future.groups in $L.approval)&lt;1 and lng($L.j in future.groups in $L.i in $L.total.approvals)&gt;0) then (future.groups in $L.approval=insert(future.groups in $L.approval, 0, 1, $L.j in future.groups in $L.i in $L.total.approvals)))</descript>
      <descript sctype="string"/>
      <descript sctype="string">from:</descript>
      <descript sctype="string"/>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(future.seq in $L.i in $L.total.approvals)) do (future.seq in $L.approval=insert(future.seq in $L.approval, 1, 1, $L.j in future.seq in $L.i in $L.total.approvals))</descript>
      <descript sctype="string"/>
      <descript sctype="string">to:</descript>
      <descript sctype="string"/>
      <descript sctype="string">for $L.i = 1 to lng(denull($L.total.approvals)) do for $L.j = 1 to lng(denull(future.seq in $L.i in $L.total.approvals)) do (future.seq in $L.approval=insert(future.seq in $L.approval, 0, 1, $L.j in future.seq in $L.i in $L.total.approvals))</descript>
      <descript sctype="string"/>
      <descript sctype="string">The second parameter for each 'insert' call was changed from '1' to '0' to ensure that elements are added to the end rather than the beginning of each array.  The 'for' statement in the second expression contained an invalid expression that was removed as well.</descript>
      <descript sctype="string">modified panel combine.approvals2 and added if condition to first 2 for loop</descript>
      <descript sctype="string">if (index($L.j in current.pending.groups in $L.i in $L.total.approvals, current.pending.groups in $L.approval)&lt;1 and lng($L.j in current.pending.groups in $L.i in $L.total.approvals)&gt;1</descript>
      <descript sctype="string">and</descript>
      <descript sctype="string">if (index($L.j in future.groups in $L.i in $L.total.approvals, future.groups in $L.approval)&lt;1 and lng($L.j in future.groups in $L.i in $L.total.approvals)&gt;1</descript>
      <descript sctype="string">modified app approval.generate on panel process.description and check.use.role, and ScriptLibrary file Approval function processDescription to handle cases where multiple approval entries with same approver and  sequence when evaluate to true. If that happens, we will generate approval based on first match.</descript>
      <descript sctype="string">DE3137 - Changed the variables $L.i and $L.j on the panel 'process.description' to start in 1 instead of 0 since in some expressions we used that value as index. i.e. $L.i in...</descript>
      <descript sctype="string">Hua: fix issue with when combine approvals, multiple pending groups in 1 approval seq and multiple pending groups in another approval seq. Changed panel combine.approvals1</descript>
      <descript sctype="string">hua:40284 fix $L.current.pending.seq in combine.approvals1 and combine.approvals2</descript>
      <descript sctype="string">Hua: added another panel combine.approvals1 to deal with different seq from different individual approvals when combine them.</descript>
      <descript sctype="string">fixed issue with role returns null or empty</descript>
      <descript sctype="string">more code for aggregate approvals</descript>
      <descript sctype="string">added code to aggregate multiple approval defs into 1 approvals, based on object defination</descript>
      <descript sctype="string">Added code to handle role management</descript>
      <descript sctype="string">Added code for build all.status in Approvals to display on Interactions this was formerly a trigger</descript>
      <descript sctype="string">	Panel approve.loop
		added $L.x in approved.by.fullname in $L.approval=nullsub($lo.ufname, operator())
		added $L.x in approved.by.fullname in $L.approval to the end of $L.info</descript>
      <descript sctype="string">Modification made so that this application now takes into account the condition where an approval 1) has an approval type of something other than "All must approve" and 2) none of the group/operator conditions evaluate to true.</descript>
      <descript sctype="string"/>
      <descript sctype="string">For details of what was done, see the MSWord document named SCR26316ResolutionLog.doc attached to CenterPoint SCR26316.</descript>
      <descript sctype="string">BUG11743:</descript>
      <descript sctype="string">on the log panel I changed the following line frome:</descript>
      <descript sctype="string">$L.info={$L.x in approved.date in $L.approval, $L.x in approved.by in $L.approval, $L.x in approved.for in $L.approval, $L.x in approved.groups in $L.approval,  name in $L.approval}</descript>
      <descript sctype="string">to</descript>
      <descript sctype="string">$L.info={$L.x in approved.date in $L.approval, $L.x in approved.by in $L.approval, $L.x in approved.for in $L.approval, $L.x in approved.groups in $L.approval, , name in $L.approval}</descript>
      <descript sctype="string">When a record is preapproved on open and approval comments are required, preset comments to "Preapproved on open".</descript>
      <descript sctype="string">Now invokes format control (stored on the Object record) on preapprove approvals.</descript>
      <descript sctype="string">Modified set.fields to set approvals.required to $L.future.groups if the field exists in the file.</descript>
      <descript sctype="string">Added the "All must approve - first denial" approval option.  Using this option all approvers must approve the record for it to be completely approved.  However, as soon as the first person denies it, the status is set immediately to "denied" instead of waiting for all approvers to register their approval action.</descript>
      <descript sctype="string">Modified panel set.future to process the preapprove.cond field in the Object record.  True by default, the field determines if the record should be automatically approved if the person who opened it belongs to one of the pending approval groups.</descript>
      <descript sctype="string">On decide.final.status panel, set $L.appr.type to the value in the approval definition, nullsubed to the object record value.</descript>
      <descript sctype="string">Changed create.groups to parse out an array of groups.</descript>
      <descript sctype="string">On create.groups, if ($L.i in 1 in $L.groups) contains a "$", call evaluate and parse on the string.</descript>
      <descript sctype="string">On start panel, nullsubed $L.def.query to false.</descript>
      <descript sctype="string">Will no longer generate approval records if no groups meet the approval conditions.</descript>
    </descript>
    <release type="string">A9902</release>
    <sysmodcount type="decimal">23</sysmodcount>
    <sysmoduser type="string">zhangqi</sysmoduser>
    <sysmodtime type="dateTime">12/03/19 17:21:31</sysmodtime>
  </record>
</recordset>
